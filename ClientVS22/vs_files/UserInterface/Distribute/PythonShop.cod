; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

	TITLE	e:\metin2_server\solwaynesf v6\clientvs22\vs_files\userinterface\distribute\pythonshop.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@ ; `string'
PUBLIC	??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@ ; `string'
PUBLIC	??_C@_06DKEIEPKC@IsOpen@			; `string'
PUBLIC	??_C@_04DNCDCIAE@Open@				; `string'
PUBLIC	??_C@_0BI@HHPKCPJD@IsMainPlayerPrivateShop@	; `string'
PUBLIC	??_C@_0O@EDCBOPPA@IsPrivateShop@		; `string'
PUBLIC	??_C@_0M@PGHDAHMM@GetTabCount@			; `string'
PUBLIC	??_C@_0N@OIFMMAOE@GetItemPrice@			; `string'
PUBLIC	??_C@_0P@CFALBIIJ@GetTabCoinType@		; `string'
PUBLIC	??_C@_0L@HEMHLKHB@GetTabName@			; `string'
PUBLIC	??_C@_0BI@JLNKJOOM@AddPrivateShopItemStock@	; `string'
PUBLIC	??_C@_0BG@BMKKEDKK@ClearPrivateShopStock@	; `string'
PUBLIC	??_C@_0BI@KLFPJJHF@GetPrivateShopItemPrice@	; `string'
PUBLIC	??_C@_0BI@FBMJKJEA@DelPrivateShopItemStock@	; `string'
PUBLIC	??_C@_04BFIJLIPK@shop@				; `string'
PUBLIC	??_C@_0BB@MDMPBIAN@BuildPrivateShop@		; `string'
PUBLIC	??_C@_0BE@FOBHCAAH@SHOP_COIN_TYPE_GOLD@		; `string'
PUBLIC	??_C@_0BA@MMIAEKCC@SHOP_SLOT_COUNT@		; `string'
PUBLIC	??_C@_0BO@GEPHLMDC@SHOP_COIN_TYPE_SECONDARY_COIN@ ; `string'
PUBLIC	??_R2CPythonShop@@8				; CPythonShop::`RTTI Base Class Array'
PUBLIC	??_R2?$CSingleton@VCPythonShop@@@@8		; CSingleton<CPythonShop>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8	; CSingleton<CPythonShop>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPythonShop@@8			; CPythonShop::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$CSingleton@VCPythonShop@@@@8		; CSingleton<CPythonShop>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3CPythonShop@@8				; CPythonShop::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$CSingleton@VCPythonShop@@@@@8		; CSingleton<CPythonShop> `RTTI Type Descriptor'
PUBLIC	??_R0?AVCPythonShop@@@8				; CPythonShop `RTTI Type Descriptor'
PUBLIC	??_R4?$CSingleton@VCPythonShop@@@@6B@		; CSingleton<CPythonShop>::`RTTI Complete Object Locator'
PUBLIC	??_R4CPythonShop@@6B@				; CPythonShop::`RTTI Complete Object Locator'
PUBLIC	??_7?$CSingleton@VCPythonShop@@@@6B@		; CSingleton<CPythonShop>::`vftable'
PUBLIC	??_7CPythonShop@@6B@				; CPythonShop::`vftable'
;	COMDAT ??_7CPythonShop@@6B@
CONST	SEGMENT
??_7CPythonShop@@6B@ DD FLAT:??_R4CPythonShop@@6B@	; CPythonShop::`vftable'
	DD	FLAT:??_ECPythonShop@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?s_methods@?1??initshop@@YAXXZ@4PAUPyMethodDef@@A
_DATA	SEGMENT
?s_methods@?1??initshop@@YAXXZ@4PAUPyMethodDef@@A DD FLAT:??_C@_04DNCDCIAE@Open@ ; `initshop'::`2'::s_methods
	DD	FLAT:?shopOpen@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_05LGELBCGM@Close@
	DD	FLAT:?shopClose@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_06DKEIEPKC@IsOpen@
	DD	FLAT:?shopIsOpen@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0O@EDCBOPPA@IsPrivateShop@
	DD	FLAT:?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@HHPKCPJD@IsMainPlayerPrivateShop@
	DD	FLAT:?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_09GMBNEEAB@GetItemID@
	DD	FLAT:?shopGetItemID@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@LEKALLIG@GetItemCount@
	DD	FLAT:?shopGetItemCount@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0N@OIFMMAOE@GetItemPrice@
	DD	FLAT:?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BD@JBOBKHIE@GetItemMetinSocket@
	DD	FLAT:?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@GOKPPDHH@GetItemAttribute@
	DD	FLAT:?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0M@PGHDAHMM@GetTabCount@
	DD	FLAT:?shopGetTabCount@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0L@HEMHLKHB@GetTabName@
	DD	FLAT:?shopGetTabName@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0P@CFALBIIJ@GetTabCoinType@
	DD	FLAT:?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BG@BMKKEDKK@ClearPrivateShopStock@
	DD	FLAT:?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@JLNKJOOM@AddPrivateShopItemStock@
	DD	FLAT:?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@FBMJKJEA@DelPrivateShopItemStock@
	DD	FLAT:?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BI@KLFPJJHF@GetPrivateShopItemPrice@
	DD	FLAT:?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	FLAT:??_C@_0BB@MDMPBIAN@BuildPrivateShop@
	DD	FLAT:?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z
	DD	01H
	ORG $+4
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
;	COMDAT ??_7?$CSingleton@VCPythonShop@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCPythonShop@@@@6B@ DD FLAT:??_R4?$CSingleton@VCPythonShop@@@@6B@ ; CSingleton<CPythonShop>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCPythonShop@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CPythonShop@@6B@
rdata$r	SEGMENT
??_R4CPythonShop@@6B@ DD 00H				; CPythonShop::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPythonShop@@@8
	DD	FLAT:??_R3CPythonShop@@8
rdata$r	ENDS
;	COMDAT ??_R4?$CSingleton@VCPythonShop@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCPythonShop@@@@6B@ DD 00H		; CSingleton<CPythonShop>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCPythonShop@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCPythonShop@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPythonShop@@@8
data$rs	SEGMENT
??_R0?AVCPythonShop@@@8 DD FLAT:??_7type_info@@6B@	; CPythonShop `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPythonShop@@', 00H
data$rs	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCPythonShop@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCPythonShop@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CPythonShop> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCPythonShop@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R3CPythonShop@@8
rdata$r	SEGMENT
??_R3CPythonShop@@8 DD 00H				; CPythonShop::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPythonShop@@8
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCPythonShop@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCPythonShop@@@@8 DD 00H		; CSingleton<CPythonShop>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCPythonShop@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPythonShop@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPythonShop@@8 DD FLAT:??_R0?AVCPythonShop@@@8 ; CPythonShop::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPythonShop@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCPythonShop@@@@@8 ; CSingleton<CPythonShop>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCPythonShop@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCPythonShop@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCPythonShop@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8 ; CSingleton<CPythonShop>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2CPythonShop@@8
rdata$r	SEGMENT
??_R2CPythonShop@@8 DD FLAT:??_R1A@?0A@EA@CPythonShop@@8 ; CPythonShop::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCPythonShop@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BO@GEPHLMDC@SHOP_COIN_TYPE_SECONDARY_COIN@
CONST	SEGMENT
??_C@_0BO@GEPHLMDC@SHOP_COIN_TYPE_SECONDARY_COIN@ DB 'SHOP_COIN_TYPE_SECO'
	DB	'NDARY_COIN', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MMIAEKCC@SHOP_SLOT_COUNT@
CONST	SEGMENT
??_C@_0BA@MMIAEKCC@SHOP_SLOT_COUNT@ DB 'SHOP_SLOT_COUNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FOBHCAAH@SHOP_COIN_TYPE_GOLD@
CONST	SEGMENT
??_C@_0BE@FOBHCAAH@SHOP_COIN_TYPE_GOLD@ DB 'SHOP_COIN_TYPE_GOLD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MDMPBIAN@BuildPrivateShop@
CONST	SEGMENT
??_C@_0BB@MDMPBIAN@BuildPrivateShop@ DB 'BuildPrivateShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFIJLIPK@shop@
CONST	SEGMENT
??_C@_04BFIJLIPK@shop@ DB 'shop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FBMJKJEA@DelPrivateShopItemStock@
CONST	SEGMENT
??_C@_0BI@FBMJKJEA@DelPrivateShopItemStock@ DB 'DelPrivateShopItemStock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KLFPJJHF@GetPrivateShopItemPrice@
CONST	SEGMENT
??_C@_0BI@KLFPJJHF@GetPrivateShopItemPrice@ DB 'GetPrivateShopItemPrice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BMKKEDKK@ClearPrivateShopStock@
CONST	SEGMENT
??_C@_0BG@BMKKEDKK@ClearPrivateShopStock@ DB 'ClearPrivateShopStock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLNKJOOM@AddPrivateShopItemStock@
CONST	SEGMENT
??_C@_0BI@JLNKJOOM@AddPrivateShopItemStock@ DB 'AddPrivateShopItemStock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HEMHLKHB@GetTabName@
CONST	SEGMENT
??_C@_0L@HEMHLKHB@GetTabName@ DB 'GetTabName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CFALBIIJ@GetTabCoinType@
CONST	SEGMENT
??_C@_0P@CFALBIIJ@GetTabCoinType@ DB 'GetTabCoinType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIFMMAOE@GetItemPrice@
CONST	SEGMENT
??_C@_0N@OIFMMAOE@GetItemPrice@ DB 'GetItemPrice', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGHDAHMM@GetTabCount@
CONST	SEGMENT
??_C@_0M@PGHDAHMM@GetTabCount@ DB 'GetTabCount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EDCBOPPA@IsPrivateShop@
CONST	SEGMENT
??_C@_0O@EDCBOPPA@IsPrivateShop@ DB 'IsPrivateShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HHPKCPJD@IsMainPlayerPrivateShop@
CONST	SEGMENT
??_C@_0BI@HHPKCPJD@IsMainPlayerPrivateShop@ DB 'IsMainPlayerPrivateShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DNCDCIAE@Open@
CONST	SEGMENT
??_C@_04DNCDCIAE@Open@ DB 'Open', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKEIEPKC@IsOpen@
CONST	SEGMENT
??_C@_06DKEIEPKC@IsOpen@ DB 'IsOpen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
CONST	SEGMENT
??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@ DB 'Ou'
	DB	't of Index. tabIdx(%d) must be less than %d.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
CONST	SEGMENT
??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@ DB 'Ou'
	DB	't of Index. tabIdx(%d) must be less than %d. dwSlotPos(%d) mu'
	DB	'st be less than %d', 00H			; `string'
PUBLIC	??MSItemPos@@QBE_NABU0@@Z			; SItemPos::operator<
PUBLIC	??$forward@USItemPos@@@std@@YA$$QAUSItemPos@@AAU1@@Z ; std::forward<SItemPos>
PUBLIC	??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@$0A@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@AAPAU10@@Z ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>
PUBLIC	??$_Voidify_iter@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAXPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z ; std::_Voidify_iter<std::pair<SItemPos const ,SShopItemTable> *>
PUBLIC	??$construct_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@$0A@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@QAU10@$$QAU?$pair@USItemPos@@USShopItemTable@@@0@@Z ; std::construct_at<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable>,0>
PUBLIC	??$?0USItemPos@@USShopItemTable@@$0A@@?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@QAE@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::pair<SItemPos const ,SShopItemTable>::pair<SItemPos const ,SShopItemTable><SItemPos,SShopItemTable,0>
PUBLIC	??$forward@AAPAUSShopItemTable@@@std@@YAAAPAUSShopItemTable@@AAPAU1@@Z ; std::forward<SShopItemTable * &>
PUBLIC	??$swap@USShopItemTable@@$0A@@std@@YAXAAUSShopItemTable@@0@Z ; std::swap<SShopItemTable,0>
PUBLIC	??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Pop_heap_hole_unchecked@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_unchecked<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
PUBLIC	??$_Push_heap_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Push_heap_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
PUBLIC	??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
PUBLIC	??$forward@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
PUBLIC	??$construct@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::construct<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Allocate
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::nullptr_t>
PUBLIC	??$construct_at@USShopItemTable@@U1@$0A@@std@@YAPAUSShopItemTable@@QAU1@$$QAU1@@Z ; std::construct_at<SShopItemTable,SShopItemTable,0>
PUBLIC	??$_Voidify_iter@PAUSShopItemTable@@@std@@YAPAXPAUSShopItemTable@@@Z ; std::_Voidify_iter<SShopItemTable *>
PUBLIC	??$construct_at@USShopItemTable@@ABU1@$0A@@std@@YAPAUSShopItemTable@@QAU1@ABU1@@Z ; std::construct_at<SShopItemTable,SShopItemTable const &,0>
PUBLIC	??$addressof@USShopItemTable@@@std@@YAPAUSShopItemTable@@AAU1@@Z ; std::addressof<SShopItemTable>
PUBLIC	??$?0AAPAUSShopItemTable@@AAPAU0@$0A@@?$pair@PAUSShopItemTable@@PAU1@@std@@QAE@AAPAUSShopItemTable@@0@Z ; std::pair<SShopItemTable *,SShopItemTable *>::pair<SShopItemTable *,SShopItemTable *><SShopItemTable * &,SShopItemTable * &,0>
PUBLIC	??$iter_swap@PAUSShopItemTable@@PAU1@@std@@YAXPAUSShopItemTable@@0@Z ; std::iter_swap<SShopItemTable *,SShopItemTable *>
PUBLIC	??$_Next_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ; std::_Next_iter<SShopItemTable *>
PUBLIC	??$_Guess_median_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Guess_median_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Prev_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ; std::_Prev_iter<SShopItemTable *>
PUBLIC	??$_Pop_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Pop_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
PUBLIC	??$_Move_backward_unchecked@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Move_backward_unchecked<SShopItemTable *,SShopItemTable *>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > > >
PUBLIC	??$?0PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool,0>
PUBLIC	??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,bool,0>
PUBLIC	??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > ><std::pair<SItemPos,SShopItemTable> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::max_size
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::max_size
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Check_grow_by_1
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Release
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	?_Extract@?$_In_place_key_extract_map@USItemPos@@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@SAABUSItemPos@@ABU?$pair@USItemPos@@USShopItemTable@@@2@@Z ; std::_In_place_key_extract_map<SItemPos,std::pair<SItemPos,SShopItemTable> >::_Extract
PUBLIC	??$destroy_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAXQAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z ; std::destroy_at<std::pair<SItemPos const ,SShopItemTable> >
PUBLIC	??$_Voidify_iter@PAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z ; std::_Voidify_iter<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * *>
PUBLIC	??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@$0A@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@ABQAU10@@Z ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &,0>
PUBLIC	??$forward@ABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
PUBLIC	??$construct@USShopItemTable@@U1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@$$QAU3@@Z ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable>
PUBLIC	??$forward@USShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z ; std::forward<SShopItemTable>
PUBLIC	??$to_address@USShopItemTable@@@std@@YAPAUSShopItemTable@@QAU1@@Z ; std::to_address<SShopItemTable>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
PUBLIC	??$construct@USShopItemTable@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable const &>
PUBLIC	??$_Construct_in_place@USShopItemTable@@ABU1@@std@@YAXAAUSShopItemTable@@ABU1@@Z ; std::_Construct_in_place<SShopItemTable,SShopItemTable const &>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Partition_by_median_guess_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Sort_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Sort_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Make_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Insertion_sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAPAUSShopItemTable@@QAU1@0UItemStockSortFunc@@@Z ; std::_Insertion_sort_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@1@AB_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool const &,0>
PUBLIC	??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Emplace<std::pair<SItemPos,SShopItemTable> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::deallocate
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::deallocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >
PUBLIC	?_Calculate_growth@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEII@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Calculate_growth
PUBLIC	?_Orphan_range@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEXPAUSShopItemTable@@0@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Orphan_range
PUBLIC	??$destroy@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::destroy<std::pair<SItemPos const ,SShopItemTable> >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
PUBLIC	??$forward@ABU?$less@USItemPos@@@std@@@std@@YAABU?$less@USItemPos@@@0@ABU10@@Z ; std::forward<std::less<SItemPos> const &>
PUBLIC	??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >
PUBLIC	??$_Emplace_back@USShopItemTable@@@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEX$$QAUSShopItemTable@@@Z ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Emplace_back<SShopItemTable>
PUBLIC	??$_To_address@PAUSShopItemTable@@@std@@YA?A_PABQAUSShopItemTable@@@Z ; std::_To_address<SShopItemTable *>
PUBLIC	??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
PUBLIC	??$move@AAUSShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z ; std::move<SShopItemTable &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
PUBLIC	??$_Lower_bound_duplicate@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Lower_bound_duplicate<SItemPos>
PUBLIC	??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
PUBLIC	??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_back_with_unused_capacity<SShopItemTable const &>
PUBLIC	??$forward@ABUSShopItemTable@@@std@@YAABUSShopItemTable@@ABU1@@Z ; std::forward<SShopItemTable const &>
PUBLIC	??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>
PUBLIC	??$_Pass_fn@UItemStockSortFunc@@$0A@@std@@YA?AUItemStockSortFunc@@U1@@Z ; std::_Pass_fn<ItemStockSortFunc,0>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > >
PUBLIC	??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU01@$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@0@Z ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>
PUBLIC	??$_Kfn@$$CBUSItemPos@@USShopItemTable@@@?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@SAABUSItemPos@@ABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z ; std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0>::_Kfn<SItemPos const ,SShopItemTable>
PUBLIC	??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::emplace<std::pair<SItemPos,SShopItemTable> >
PUBLIC	??$forward@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@YA$$QAU?$pair@USItemPos@@USShopItemTable@@@0@AAU10@@Z ; std::forward<std::pair<SItemPos,SShopItemTable> >
PUBLIC	??$?0AAUSItemPos@@AAUSShopItemTable@@$0A@@?$pair@USItemPos@@USShopItemTable@@@std@@QAE@AAUSItemPos@@AAUSShopItemTable@@@Z ; std::pair<SItemPos,SShopItemTable>::pair<SItemPos,SShopItemTable><SItemPos &,SShopItemTable &,0>
PUBLIC	??$forward@AAUSShopItemTable@@@std@@YAAAUSShopItemTable@@AAU1@@Z ; std::forward<SShopItemTable &>
PUBLIC	??$forward@AAUSItemPos@@@std@@YAAAUSItemPos@@AAU1@@Z ; std::forward<SItemPos &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1><>
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@USItemPos@@@2@XZ ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Get_first
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocate
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABU?$less@USItemPos@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getcomp
PUBLIC	??R?$less@USItemPos@@@std@@QBE_NABUSItemPos@@0@Z ; std::less<SItemPos>::operator()
PUBLIC	??0?$allocator@USShopItemTable@@@std@@QAE@XZ	; std::allocator<SShopItemTable>::allocator<SShopItemTable>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<SShopItemTable> >::_Vector_val<std::_Simple_types<SShopItemTable> >
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@PAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Uninitialized_backout_al<std::allocator<SShopItemTable> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::~_Uninitialized_backout_al<std::allocator<SShopItemTable> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEPAUSShopItemTable@@XZ ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Release
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$_Get_size_of_n@$0BB@@std@@YAII@Z		; std::_Get_size_of_n<17>
PUBLIC	??$?0ABU?$less@USItemPos@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@USItemPos@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1><std::less<SItemPos> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Get_unwrapped@AAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> &>
PUBLIC	??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > const >
PUBLIC	??$_Uninitialized_move@PAUSShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@QAU1@0PAU1@AAV?$allocator@USShopItemTable@@@0@@Z ; std::_Uninitialized_move<SShopItemTable *,std::allocator<SShopItemTable> >
PUBLIC	??$_Get_unwrapped@ABQAUSShopItemTable@@@std@@YA?A_TABQAUSShopItemTable@@@Z ; std::_Get_unwrapped<SShopItemTable * const &>
PUBLIC	??$_Destroy_range@V?$allocator@USShopItemTable@@@std@@@std@@YAXPAUSShopItemTable@@QAU1@AAV?$allocator@USShopItemTable@@@0@@Z ; std::_Destroy_range<std::allocator<SShopItemTable> >
PUBLIC	??$addressof@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@AAU10@@Z ; std::addressof<std::pair<SItemPos const ,SShopItemTable> >
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
PUBLIC	??$_Find@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find<SItemPos>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1><>
PUBLIC	??$_Emplace_one_at_back@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_one_at_back<SShopItemTable const &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEPAUSShopItemTable@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Unwrapped
PUBLIC	??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > const &>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@UItemStockSortFunc@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0UItemStockSortFunc@@@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,ItemStockSortFunc>
PUBLIC	??$_Eqrange@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Eqrange<SItemPos>
PUBLIC	??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::insert<std::pair<SItemPos,SShopItemTable>,0>
PUBLIC	??$make_pair@AAUSItemPos@@AAUSShopItemTable@@@std@@YA?AU?$pair@USItemPos@@USShopItemTable@@@0@AAUSItemPos@@AAUSShopItemTable@@@Z ; std::make_pair<SItemPos &,SShopItemTable &>
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Max
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
PUBLIC	??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
PUBLIC	?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Unchecked_begin
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Min
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE?AV01@H@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++
PUBLIC	??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator==
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAEAAV?$allocator@USShopItemTable@@@2@XZ ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QBEABV?$allocator@USShopItemTable@@@2@XZ ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*
PUBLIC	?deallocate@?$allocator@USShopItemTable@@@std@@QAEXQAUSShopItemTable@@I@Z ; std::allocator<SShopItemTable>::deallocate
PUBLIC	?allocate@?$allocator@USShopItemTable@@@std@@QAEPAUSShopItemTable@@I@Z ; std::allocator<SShopItemTable>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAIABV?$allocator@USShopItemTable@@@2@@Z ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::max_size
PUBLIC	?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array
PUBLIC	?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAV?$allocator@USShopItemTable@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal
PUBLIC	?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEABV?$allocator@USShopItemTable@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal
PUBLIC	??0?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@USItemPos@@@1@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEIU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@2@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Orphan_ptr
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*
PUBLIC	?_Reallocate_exactly@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXI@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocate_exactly
PUBLIC	?max_size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::max_size
PUBLIC	?capacity@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::capacity
PUBLIC	?_Tidy@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Tidy
PUBLIC	?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@SAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@2@AAU32@@Z ; std::pointer_traits<std::pair<SItemPos const ,SShopItemTable> *>::pointer_to
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
PUBLIC	??_G?$CSingleton@VCPythonShop@@@@UAEPAXI@Z	; CSingleton<CPythonShop>::`scalar deleting destructor'
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
PUBLIC	??0?$CSingleton@VCPythonShop@@@@QAE@XZ		; CSingleton<CPythonShop>::CSingleton<CPythonShop>
PUBLIC	??1?$CSingleton@VCPythonShop@@@@UAE@XZ		; CSingleton<CPythonShop>::~CSingleton<CPythonShop>
PUBLIC	??1?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::~_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::find
PUBLIC	??0?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator==
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator->
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++
PUBLIC	??0?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::vector<SShopItemTable,std::allocator<SShopItemTable> >
PUBLIC	??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::~vector<SShopItemTable,std::allocator<SShopItemTable> >
PUBLIC	?push_back@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXABUSShopItemTable@@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::push_back
PUBLIC	?reserve@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXI@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::reserve
PUBLIC	?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
PUBLIC	?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end
PUBLIC	?initshop@@YAXXZ				; initshop
PUBLIC	?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z	; shopGetTabCoinType
PUBLIC	?shopGetTabName@@YAPAU_object@@PAU1@0@Z		; shopGetTabName
PUBLIC	?shopGetTabCount@@YAPAU_object@@PAU1@0@Z	; shopGetTabCount
PUBLIC	?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z	; shopBuildPrivateShop
PUBLIC	?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z ; shopGetPrivateShopItemPrice
PUBLIC	?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z ; shopDelPrivateShopItemStock
PUBLIC	?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z ; shopAddPrivateShopItemStock
PUBLIC	?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z ; shopClearPrivateShopStock
PUBLIC	?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z	; shopGetItemAttribute
PUBLIC	?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z	; shopGetItemMetinSocket
PUBLIC	?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z	; shopGetItemPrice
PUBLIC	?shopGetItemCount@@YAPAU_object@@PAU1@0@Z	; shopGetItemCount
PUBLIC	?shopGetItemID@@YAPAU_object@@PAU1@0@Z		; shopGetItemID
PUBLIC	?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z ; shopIsMainPlayerPrivateShop
PUBLIC	?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z	; shopIsPrviateShop
PUBLIC	?shopIsOpen@@YAPAU_object@@PAU1@0@Z		; shopIsOpen
PUBLIC	?shopClose@@YAPAU_object@@PAU1@0@Z		; shopClose
PUBLIC	?shopOpen@@YAPAU_object@@PAU1@0@Z		; shopOpen
PUBLIC	??1?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::~map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >
PUBLIC	??1ShopTab@CPythonShop@@QAE@XZ			; CPythonShop::ShopTab::~ShopTab
PUBLIC	??_GCPythonShop@@UAEPAXI@Z			; CPythonShop::`scalar deleting destructor'
PUBLIC	?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ	; CPythonShop::IsMainPlayerPrivateShop
PUBLIC	?IsPrivateShop@CPythonShop@@QAEHXZ		; CPythonShop::IsPrivateShop
PUBLIC	?Close@CPythonShop@@QAEXXZ			; CPythonShop::Close
PUBLIC	?Open@CPythonShop@@QAEXHH@Z			; CPythonShop::Open
PUBLIC	?BuildPrivateShop@CPythonShop@@QAEXPBD@Z	; CPythonShop::BuildPrivateShop
PUBLIC	??RItemStockSortFunc@@QAE_NAAUSShopItemTable@@0@Z ; ItemStockSortFunc::operator()
PUBLIC	?GetPrivateShopItemPrice@CPythonShop@@QAE_JUSItemPos@@@Z ; CPythonShop::GetPrivateShopItemPrice
PUBLIC	?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z ; CPythonShop::DelPrivateShopItemStock
PUBLIC	??0SShopItemTable@@QAE@XZ			; SShopItemTable::SShopItemTable
PUBLIC	?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z ; CPythonShop::AddPrivateShopItemStock
PUBLIC	?ClearPrivateShopStock@CPythonShop@@QAEXXZ	; CPythonShop::ClearPrivateShopStock
PUBLIC	?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
PUBLIC	?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
PUBLIC	?GetTabName@CPythonShop@@QAEPBDE@Z		; CPythonShop::GetTabName
PUBLIC	?GetTabCoinType@CPythonShop@@QAEEE@Z		; CPythonShop::GetTabCoinType
PUBLIC	??0ShopTab@CPythonShop@@QAE@XZ			; CPythonShop::ShopTab::ShopTab
PUBLIC	?GetTabCount@CPythonShop@@QAEEXZ		; CPythonShop::GetTabCount
PUBLIC	?IsOpen@CPythonShop@@QAEHXZ			; CPythonShop::IsOpen
PUBLIC	?Clear@CPythonShop@@QAEXXZ			; CPythonShop::Clear
PUBLIC	?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData
PUBLIC	?SetTabCoinType@CPythonShop@@QAEXEE@Z		; CPythonShop::SetTabCoinType
PUBLIC	?SetTabName@CPythonShop@@QAEXEPBD@Z		; CPythonShop::SetTabName
PUBLIC	?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData
PUBLIC	??0CPythonShop@@QAE@XZ				; CPythonShop::CPythonShop
PUBLIC	??1CPythonShop@@UAE@XZ				; CPythonShop::~CPythonShop
EXTRN	??_ECPythonShop@@UAEPAXI@Z:PROC			; CPythonShop::`vector deleting destructor'
EXTRN	??_E?$CSingleton@VCPythonShop@@@@UAEPAXI@Z:PROC	; CSingleton<CPythonShop>::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPythonShop@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPythonShop@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CPythonShop@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CPythonShop@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPythonShop@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CPythonShop@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z$0
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\eterBase\Singleton.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ??1CPythonShop@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CPythonShop@@UAE@XZ PROC				; CPythonShop::~CPythonShop, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CPythonShop@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx

; 209  : }

  00026	8d b7 78 2c 00
	00		 lea	 esi, DWORD PTR [edi+11384]
  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonShop@@6B@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	8b ce		 mov	 ecx, esi
  00036	ff 70 04	 push	 DWORD PTR [eax+4]
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0003f	6a 24		 push	 36			; 00000024H
  00041	ff 36		 push	 DWORD PTR [esi]
  00043	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00048	83 c4 08	 add	 esp, 8
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 209  : }

  0004b	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  0004e	68 00 00 00 00	 push	 OFFSET ??1ShopTab@CPythonShop@@QAE@XZ
  00053	6a 03		 push	 3
  00055	68 cc 0e 00 00	 push	 3788			; 00000eccH
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\eterBase\Singleton.h

; 19   : 	{ 

  00060	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CSingleton@VCPythonShop@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00066	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, 0 ; CSingleton<CPythonShop>::ms_singleton
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 209  : }

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
  00081	cc		 int	 3
  00082	cc		 int	 3
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CPythonShop@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CPythonShop@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CPythonShop@@UAE@XZ ENDP				; CPythonShop::~CPythonShop
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\eterBase\Singleton.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ??0CPythonShop@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CPythonShop@@QAE@XZ PROC				; CPythonShop::CPythonShop, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CPythonShop@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\eterBase\Singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, edi ; CSingleton<CPythonShop>::ms_singleton
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 203  : {

  00032	68 00 00 00 00	 push	 OFFSET ??1ShopTab@CPythonShop@@QAE@XZ
  00037	68 00 00 00 00	 push	 OFFSET ??0ShopTab@CPythonShop@@QAE@XZ ; CPythonShop::ShopTab::ShopTab
  0003c	6a 03		 push	 3
  0003e	68 cc 0e 00 00	 push	 3788			; 00000eccH
  00043	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	50		 push	 eax
  0004e	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CPythonShop@@6B@
  00054	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00059	8d b7 78 2c 00
	00		 lea	 esi, DWORD PTR [edi+11384]
  0005f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00063	6a 24		 push	 36			; 00000024H
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 203  : {

  00065	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00068	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0006e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00075	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007a	83 c4 04	 add	 esp, 4
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 204  : 	Clear();

  0007d	8b cf		 mov	 ecx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0007f	89 00		 mov	 DWORD PTR [eax], eax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00081	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00084	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 350  :         _Pnode->_Color = _Black;

  00087	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0008d	89 06		 mov	 DWORD PTR [esi], eax
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 204  : 	Clear();

  0008f	e8 00 00 00 00	 call	 ?Clear@CPythonShop@@QAEXXZ ; CPythonShop::Clear

; 205  : }

  00094	8b c7		 mov	 eax, edi
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00099	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a0	59		 pop	 ecx
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPythonShop@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCPythonShop@@@@UAE@XZ ; CSingleton<CPythonShop>::~CSingleton<CPythonShop>
__unwindfunclet$??0CPythonShop@@QAE@XZ$1:
  00008	68 00 00 00 00	 push	 OFFSET ??1ShopTab@CPythonShop@@QAE@XZ
  0000d	6a 03		 push	 3
  0000f	68 cc 0e 00 00	 push	 3788			; 00000eccH
  00014	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 c0 14	 add	 eax, 20			; 00000014H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00020	c3		 ret	 0
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$??0CPythonShop@@QAE@XZ:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CPythonShop@@QAE@XZ
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CPythonShop@@QAE@XZ ENDP				; CPythonShop::CPythonShop
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
_dwSlotPos$ = 12					; size = 4
_c_rShopItemData$ = 16					; size = 4
?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z PROC ; CPythonShop::SetItemData, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   : 	if (tabIdx >= SHOP_TAB_COUNT_MAX || dwSlotPos >= SHOP_HOST_ITEM_MAX_NUM)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _dwSlotPos$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3c 03		 cmp	 al, 3
  0000e	73 4a		 jae	 SHORT $LN3@SetItemDat
  00010	83 fa 50	 cmp	 edx, 80			; 00000050H
  00013	73 45		 jae	 SHORT $LN3@SetItemDat

; 78   : 		return;
; 79   : 	}
; 80   : 
; 81   : 	m_aShoptabs[tabIdx].items[dwSlotPos] = c_rShopItemData;

  00015	0f b6 c0	 movzx	 eax, al
  00018	69 c8 cc 0e 00
	00		 imul	 ecx, eax, 3788
  0001e	6b d2 2f	 imul	 edx, edx, 47
  00021	03 ce		 add	 ecx, esi
  00023	03 d1		 add	 edx, ecx
  00025	8b 4d 10	 mov	 ecx, DWORD PTR _c_rShopItemData$[ebp]
  00028	5e		 pop	 esi
  00029	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0002c	0f 11 42 30	 movups	 XMMWORD PTR [edx+48], xmm0
  00030	0f 10 41 10	 movups	 xmm0, XMMWORD PTR [ecx+16]
  00034	0f 11 42 40	 movups	 XMMWORD PTR [edx+64], xmm0
  00038	f3 0f 7e 41 20	 movq	 xmm0, QWORD PTR [ecx+32]
  0003d	66 0f d6 42 50	 movq	 QWORD PTR [edx+80], xmm0
  00042	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00045	89 42 58	 mov	 DWORD PTR [edx+88], eax
  00048	66 8b 41 2c	 mov	 ax, WORD PTR [ecx+44]
  0004c	66 89 42 5c	 mov	 WORD PTR [edx+92], ax
  00050	8a 41 2e	 mov	 al, BYTE PTR [ecx+46]
  00053	88 42 5e	 mov	 BYTE PTR [edx+94], al

; 82   : }

  00056	5d		 pop	 ebp
  00057	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SetItemDat:

; 76   : 	{
; 77   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d. dwSlotPos(%d) must be less than %d", tabIdx, SHOP_TAB_COUNT_MAX, dwSlotPos, SHOP_HOST_ITEM_MAX_NUM);

  0005a	6a 50		 push	 80			; 00000050H
  0005c	52		 push	 edx
  0005d	6a 03		 push	 3
  0005f	0f b6 c0	 movzx	 eax, al
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00068	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0006d	83 c4 14	 add	 esp, 20			; 00000014H
  00070	5e		 pop	 esi

; 82   : }

  00071	5d		 pop	 ebp
  00072	c2 0c 00	 ret	 12			; 0000000cH
?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z ENDP ; CPythonShop::SetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?SetTabName@CPythonShop@@QAEXEPBD@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
_name$ = 12						; size = 4
?SetTabName@CPythonShop@@QAEXEPBD@Z PROC		; CPythonShop::SetTabName, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	if (tabIdx >= m_bTabCount)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	0f b6 d0	 movzx	 edx, al
  0000c	3a 46 10	 cmp	 al, BYTE PTR [esi+16]
  0000f	72 15		 jb	 SHORT $LN2@SetTabName

; 39   : 	{	
; 40   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d.", tabIdx, SHOP_TAB_COUNT_MAX);

  00011	6a 03		 push	 3
  00013	52		 push	 edx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00019	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	5e		 pop	 esi

; 44   : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN2@SetTabName:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 415  :             return __builtin_strlen(_First);

  00026	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00029	53		 push	 ebx
  0002a	8d 59 01	 lea	 ebx, DWORD PTR [ecx+1]
  0002d	0f 1f 00	 npad	 3
$LL10@SetTabName:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	41		 inc	 ecx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL10@SetTabName
  00037	2b cb		 sub	 ecx, ebx

; 3546 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00039	51		 push	 ecx
  0003a	ff 75 0c	 push	 DWORD PTR _name$[ebp]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 43   : 	m_aShoptabs[tabIdx].name = name;

  0003d	69 ca cc 0e 00
	00		 imul	 ecx, edx, 3788
  00043	83 c1 18	 add	 ecx, 24			; 00000018H
  00046	03 ce		 add	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 3546 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00048	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0004d	5b		 pop	 ebx
  0004e	5e		 pop	 esi
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 44   : }

  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?SetTabName@CPythonShop@@QAEXEPBD@Z ENDP		; CPythonShop::SetTabName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?SetTabCoinType@CPythonShop@@QAEXEE@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
_coinType$ = 12						; size = 1
?SetTabCoinType@CPythonShop@@QAEXEE@Z PROC		; CPythonShop::SetTabCoinType, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   : 	if (tabIdx >= m_bTabCount)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	0f b6 d0	 movzx	 edx, al
  0000c	3a 46 10	 cmp	 al, BYTE PTR [esi+16]
  0000f	72 15		 jb	 SHORT $LN2@SetTabCoin

; 19   : 	{	
; 20   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d.", tabIdx, SHOP_TAB_COUNT_MAX);

  00011	6a 03		 push	 3
  00013	52		 push	 edx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00019	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	5e		 pop	 esi

; 24   : }

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN2@SetTabCoin:

; 21   : 		return;
; 22   : 	}
; 23   : 	m_aShoptabs[tabIdx].coinType = coinType;

  00026	8a 45 0c	 mov	 al, BYTE PTR _coinType$[ebp]
  00029	69 ca cc 0e 00
	00		 imul	 ecx, edx, 3788
  0002f	88 44 31 14	 mov	 BYTE PTR [ecx+esi+20], al
  00033	5e		 pop	 esi

; 24   : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?SetTabCoinType@CPythonShop@@QAEXEE@Z ENDP		; CPythonShop::SetTabCoinType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
_c_rShopItemData$ = 12					; size = 4
?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z PROC ; CPythonShop::SetItemData, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 59   : 	BYTE tabIdx = dwIndex / SHOP_HOST_ITEM_MAX_NUM;
; 60   : 	DWORD dwSlotPos = dwIndex % SHOP_HOST_ITEM_MAX_NUM;

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwIndex$[ebp]
  00007	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH

; 61   : 	
; 62   : 	SetItemData(tabIdx, dwSlotPos, c_rShopItemData);

  0000c	ff 75 0c	 push	 DWORD PTR _c_rShopItemData$[ebp]
  0000f	f7 e6		 mul	 esi
  00011	c1 ea 06	 shr	 edx, 6
  00014	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00017	c1 e0 04	 shl	 eax, 4
  0001a	2b f0		 sub	 esi, eax
  0001c	56		 push	 esi
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?SetItemData@CPythonShop@@QAEXEKABUpacket_shop_item@@@Z ; CPythonShop::SetItemData
  00023	5e		 pop	 esi

; 63   : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?SetItemData@CPythonShop@@QAEXKABUpacket_shop_item@@@Z ENDP ; CPythonShop::SetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?Clear@CPythonShop@@QAEXXZ
_TEXT	SEGMENT
?Clear@CPythonShop@@QAEXXZ PROC				; CPythonShop::Clear, COMDAT
; _this$ = ecx

; 191  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 192  : 	m_isShoping = FALSE;

  00004	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 193  : 	m_isPrivateShop = FALSE;

  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 194  : 	m_isMainPlayerPrivateShop = FALSE;

  00012	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 195  : 	ClearPrivateShopStock();

  00019	e8 00 00 00 00	 call	 ?ClearPrivateShopStock@CPythonShop@@QAEXXZ ; CPythonShop::ClearPrivateShopStock

; 196  : 	m_bTabCount = 1;

  0001e	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
  00022	bf 03 00 00 00	 mov	 edi, 3
  00027	83 c6 30	 add	 esi, 48			; 00000030H
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Clear:

; 197  : 
; 198  : 	for (int i = 0; i < SHOP_TAB_COUNT_MAX; i++)
; 199  : 		memset (m_aShoptabs[i].items, 0, sizeof(TShopItemData) * SHOP_HOST_ITEM_MAX_NUM);

  00030	68 b0 0e 00 00	 push	 3760			; 00000eb0H
  00035	6a 00		 push	 0
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 _memset
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	81 c6 cc 0e 00
	00		 add	 esi, 3788		; 00000eccH
  00046	83 ef 01	 sub	 edi, 1
  00049	75 e5		 jne	 SHORT $LL4@Clear

; 200  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	c3		 ret	 0
?Clear@CPythonShop@@QAEXXZ ENDP				; CPythonShop::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?IsOpen@CPythonShop@@QAEHXZ
_TEXT	SEGMENT
?IsOpen@CPythonShop@@QAEHXZ PROC			; CPythonShop::IsOpen, COMDAT
; _this$ = ecx

; 177  : 	return m_isShoping;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 178  : }

  00003	c3		 ret	 0
?IsOpen@CPythonShop@@QAEHXZ ENDP			; CPythonShop::IsOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.h
;	COMDAT ?GetTabCount@CPythonShop@@QAEEXZ
_TEXT	SEGMENT
?GetTabCount@CPythonShop@@QAEEXZ PROC			; CPythonShop::GetTabCount, COMDAT
; _this$ = ecx

; 35   : 		BYTE GetTabCount() { return m_bTabCount; }

  00000	8a 41 10	 mov	 al, BYTE PTR [ecx+16]
  00003	c3		 ret	 0
?GetTabCount@CPythonShop@@QAEEXZ ENDP			; CPythonShop::GetTabCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.h
;	COMDAT ??0ShopTab@CPythonShop@@QAE@XZ
_TEXT	SEGMENT
??0ShopTab@CPythonShop@@QAE@XZ PROC			; CPythonShop::ShopTab::ShopTab, COMDAT
; _this$ = ecx

; 68   : 			ShopTab()

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 71   : 			}

  00003	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2339 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00005	0f 11 41 04	 movups	 XMMWORD PTR [ecx+4], xmm0

; 4995 :         _My_data._Mysize = 0;

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 4996 :         _My_data._Myres  = _BUF_SIZE - 1;

  00010	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH

; 4997 :         _My_data._Activate_SSO_buffer();
; 4998 : 
; 4999 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5000 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00017	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.h

; 70   : 				coinType = SHOP_COIN_TYPE_GOLD;

  0001b	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 71   : 			}

  0001e	c3		 ret	 0
??0ShopTab@CPythonShop@@QAE@XZ ENDP			; CPythonShop::ShopTab::ShopTab
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetTabCoinType@CPythonShop@@QAEEE@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
?GetTabCoinType@CPythonShop@@QAEEE@Z PROC		; CPythonShop::GetTabCoinType, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : 	if (tabIdx >= m_bTabCount)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	0f b6 d0	 movzx	 edx, al
  00009	3a 41 10	 cmp	 al, BYTE PTR [ecx+16]
  0000c	72 16		 jb	 SHORT $LN2@GetTabCoin

; 29   : 	{
; 30   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d.", tabIdx, SHOP_TAB_COUNT_MAX);

  0000e	6a 03		 push	 3
  00010	52		 push	 edx
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00016	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 31   : 		return 0xff;

  0001e	0c ff		 or	 al, 255			; 000000ffH

; 34   : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN2@GetTabCoin:

; 32   : 	}
; 33   : 	return m_aShoptabs[tabIdx].coinType;

  00024	69 c2 cc 0e 00
	00		 imul	 eax, edx, 3788
  0002a	8a 44 08 14	 mov	 al, BYTE PTR [eax+ecx+20]

; 34   : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
?GetTabCoinType@CPythonShop@@QAEEE@Z ENDP		; CPythonShop::GetTabCoinType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetTabName@CPythonShop@@QAEPBDE@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
?GetTabName@CPythonShop@@QAEPBDE@Z PROC			; CPythonShop::GetTabName, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 	if (tabIdx >= m_bTabCount)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	0f b6 d0	 movzx	 edx, al
  00009	3a 41 10	 cmp	 al, BYTE PTR [ecx+16]
  0000c	72 16		 jb	 SHORT $LN2@GetTabName

; 49   : 	{
; 50   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d.", tabIdx, SHOP_TAB_COUNT_MAX);

  0000e	6a 03		 push	 3
  00010	52		 push	 edx
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FJEENICJ@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00016	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 		return NULL;

  0001e	33 c0		 xor	 eax, eax

; 55   : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN2@GetTabName:

; 52   : 	}
; 53   : 
; 54   : 	return m_aShoptabs[tabIdx].name.c_str();

  00024	69 c2 cc 0e 00
	00		 imul	 eax, edx, 3788
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 4256 :         return _Mypair._Myval2._Myptr();

  0002a	83 c0 18	 add	 eax, 24			; 00000018H
  0002d	03 c1		 add	 eax, ecx

; 2301 :         return _BUF_SIZE <= _Myres;

  0002f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2293 :         if (_Large_string_engaged()) {

  00033	72 02		 jb	 SHORT $LN1@GetTabName

; 2294 :             _Result = _Unfancy(_Bx._Ptr);

  00035	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@GetTabName:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 55   : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?GetTabName@CPythonShop@@QAEPBDE@Z ENDP			; CPythonShop::GetTabName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z
_TEXT	SEGMENT
_dwIndex$ = 8						; size = 4
_c_ppItemData$ = 12					; size = 4
?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z PROC ; CPythonShop::GetItemData, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 67   : 	BYTE tabIdx = dwIndex / SHOP_HOST_ITEM_MAX_NUM;
; 68   : 	DWORD dwSlotPos = dwIndex % SHOP_HOST_ITEM_MAX_NUM;

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwIndex$[ebp]
  00007	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH

; 69   : 
; 70   : 	return GetItemData(tabIdx, dwSlotPos, c_ppItemData);

  0000c	ff 75 0c	 push	 DWORD PTR _c_ppItemData$[ebp]
  0000f	f7 e6		 mul	 esi
  00011	c1 ea 06	 shr	 edx, 6
  00014	8d 04 92	 lea	 eax, DWORD PTR [edx+edx*4]
  00017	c1 e0 04	 shl	 eax, 4
  0001a	2b f0		 sub	 esi, eax
  0001c	56		 push	 esi
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  00023	5e		 pop	 esi

; 71   : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ENDP ; CPythonShop::GetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z
_TEXT	SEGMENT
_tabIdx$ = 8						; size = 1
_dwSlotPos$ = 12					; size = 4
_c_ppItemData$ = 16					; size = 4
?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z PROC ; CPythonShop::GetItemData, COMDAT
; _this$ = ecx

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   : 	if (tabIdx >= SHOP_TAB_COUNT_MAX || dwSlotPos >= SHOP_HOST_ITEM_MAX_NUM)

  00003	8a 45 08	 mov	 al, BYTE PTR _tabIdx$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _dwSlotPos$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	3c 03		 cmp	 al, 3
  0000e	73 27		 jae	 SHORT $LN3@GetItemDat
  00010	83 fa 50	 cmp	 edx, 80			; 00000050H
  00013	73 22		 jae	 SHORT $LN3@GetItemDat

; 90   : 	}
; 91   : 
; 92   : 	*c_ppItemData = &m_aShoptabs[tabIdx].items[dwSlotPos];

  00015	0f b6 c0	 movzx	 eax, al
  00018	69 c8 cc 0e 00
	00		 imul	 ecx, eax, 3788
  0001e	6b c2 2f	 imul	 eax, edx, 47
  00021	03 ce		 add	 ecx, esi
  00023	83 c0 30	 add	 eax, 48			; 00000030H
  00026	03 c8		 add	 ecx, eax
  00028	8b 45 10	 mov	 eax, DWORD PTR _c_ppItemData$[ebp]
  0002b	5e		 pop	 esi
  0002c	89 08		 mov	 DWORD PTR [eax], ecx

; 93   : 
; 94   : 	return TRUE;

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 95   : }

  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
$LN3@GetItemDat:

; 87   : 	{
; 88   : 		TraceError("Out of Index. tabIdx(%d) must be less than %d. dwSlotPos(%d) must be less than %d", tabIdx, SHOP_TAB_COUNT_MAX, dwSlotPos, SHOP_HOST_ITEM_MAX_NUM);

  00037	6a 50		 push	 80			; 00000050H
  00039	52		 push	 edx
  0003a	6a 03		 push	 3
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@PFANBFHB@Out?5of?5Index?4?5tabIdx?$CI?$CFd?$CJ?5must?5b@
  00045	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0004a	83 c4 14	 add	 esp, 20			; 00000014H

; 89   : 		return FALSE;

  0004d	33 c0		 xor	 eax, eax
  0004f	5e		 pop	 esi

; 95   : }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
?GetItemData@CPythonShop@@QAEHEKPAPBUpacket_shop_item@@@Z ENDP ; CPythonShop::GetItemData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?ClearPrivateShopStock@CPythonShop@@QAEXXZ
_TEXT	SEGMENT
?ClearPrivateShopStock@CPythonShop@@QAEXXZ PROC		; CPythonShop::ClearPrivateShopStock, COMDAT
; _this$ = ecx

; 106  : {

  00000	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1356 :         auto _Head = _Scary->_Myhead;

  00001	8b b1 78 2c 00
	00		 mov	 esi, DWORD PTR [ecx+11384]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 106  : {

  00007	57		 push	 edi

; 107  : 	m_PrivateShopItemStock.clear();

  00008	8d b9 78 2c 00
	00		 lea	 edi, DWORD PTR [ecx+11384]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1357 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  0000e	8b cf		 mov	 ecx, edi
  00010	ff 76 04	 push	 DWORD PTR [esi+4]
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1358 :         _Head->_Parent  = _Head;

  00019	89 76 04	 mov	 DWORD PTR [esi+4], esi

; 1359 :         _Head->_Left    = _Head;

  0001c	89 36		 mov	 DWORD PTR [esi], esi

; 1360 :         _Head->_Right   = _Head;

  0001e	89 76 08	 mov	 DWORD PTR [esi+8], esi

; 1361 :         _Scary->_Mysize = 0;

  00021	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 108  : }

  0002a	c3		 ret	 0
?ClearPrivateShopStock@CPythonShop@@QAEXXZ ENDP		; CPythonShop::ClearPrivateShopStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z
_TEXT	SEGMENT
_SellingItem$ = -72					; size = 17
$T2 = -52						; size = 20
__Loc$3 = -44						; size = 12
$T4 = -32						; size = 12
$T5 = -28						; size = 8
$T6 = -20						; size = 2
$T7 = -17						; size = 1
__$EHRec$ = -12						; size = 12
_ItemPos$ = 8						; size = 3
_dwDisplayPos$ = 12					; size = 1
_dwPrice$ = 16						; size = 8
?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z PROC ; CPythonShop::AddPrivateShopItemStock, COMDAT
; _this$ = ecx

; 110  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 ec 38	 sub	 esp, 56			; 00000038H
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b f1		 mov	 esi, ecx

; 111  : 	DelPrivateShopItemStock(ItemPos);

  0003d	66 8b 43 08	 mov	 ax, WORD PTR _ItemPos$[ebx]
  00041	51		 push	 ecx
  00042	8b d4		 mov	 edx, esp
  00044	66 89 02	 mov	 WORD PTR [edx], ax
  00047	8a 43 0a	 mov	 al, BYTE PTR _ItemPos$[ebx+2]
  0004a	88 42 02	 mov	 BYTE PTR [edx+2], al
  0004d	e8 00 00 00 00	 call	 ?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z ; CPythonShop::DelPrivateShopItemStock

; 116  : 	SellingItem.pos = ItemPos;

  00052	66 8b 43 09	 mov	 ax, WORD PTR _ItemPos$[ebx+1]

; 118  : 	SellingItem.display_pos = dwDisplayPos;
; 119  : 	m_PrivateShopItemStock.insert(std::make_pair(ItemPos, SellingItem));

  00056	8d be 78 2c 00
	00		 lea	 edi, DWORD PTR [esi+11384]
  0005c	66 8b 53 08	 mov	 dx, WORD PTR _ItemPos$[ebx]
  00060	8b 4b 14	 mov	 ecx, DWORD PTR _dwPrice$[ebx+4]
  00063	88 65 bf	 mov	 BYTE PTR _SellingItem$[ebp+7], ah
  00066	8b 43 10	 mov	 eax, DWORD PTR _dwPrice$[ebx]
  00069	89 45 c0	 mov	 DWORD PTR _SellingItem$[ebp+8], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0006c	8a 43 0a	 mov	 al, BYTE PTR _ItemPos$[ebx+2]
  0006f	88 45 ef	 mov	 BYTE PTR $T7[ebp], al
  00072	88 45 ce	 mov	 BYTE PTR $T2[ebp+2], al
  00075	8a 43 0c	 mov	 al, BYTE PTR _dwDisplayPos$[ebx]
  00078	88 45 df	 mov	 BYTE PTR $T2[ebp+19], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  0007b	8d 45 cc	 lea	 eax, DWORD PTR $T2[ebp]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 117  : 	SellingItem.price = dwPrice;

  0007e	89 4d c4	 mov	 DWORD PTR _SellingItem$[ebp+12], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  00081	8b cf		 mov	 ecx, edi
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 116  : 	SellingItem.pos = ItemPos;

  00083	66 89 55 bd	 mov	 WORD PTR _SellingItem$[ebp+5], dx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  00087	50		 push	 eax
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 114  : 	SellingItem.vnum = 0;

  00088	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _SellingItem$[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  0008f	8d 45 e0	 lea	 eax, DWORD PTR $T4[ebp]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 115  : 	SellingItem.count = 0;

  00092	c6 45 bc 00	 mov	 BYTE PTR _SellingItem$[ebp+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00096	0f 10 45 b8	 movups	 xmm0, XMMWORD PTR _SellingItem$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  0009a	50		 push	 eax
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 116  : 	SellingItem.pos = ItemPos;

  0009b	66 89 55 ec	 mov	 WORD PTR $T6[ebp], dx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0009f	66 89 55 cc	 mov	 WORD PTR $T2[ebp], dx
  000a3	0f 11 45 cf	 movups	 XMMWORD PTR $T2[ebp+3], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  000a7	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
  000ac	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000af	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  000b3	66 0f d6 45 d4	 movq	 QWORD PTR __Loc$3[ebp], xmm0

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  000b8	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  000bc	75 15		 jne	 SHORT $LN122@AddPrivate
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  000be	66 8b 45 ec	 mov	 ax, WORD PTR $T6[ebp]
  000c2	3a 42 0e	 cmp	 al, BYTE PTR [edx+14]
  000c5	72 0c		 jb	 SHORT $LN122@AddPrivate
  000c7	75 68		 jne	 SHORT $LN109@AddPrivate
  000c9	66 8b 43 09	 mov	 ax, WORD PTR _ItemPos$[ebx+1]
  000cd	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  000d1	73 5e		 jae	 SHORT $LN109@AddPrivate
$LN122@AddPrivate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

  000d3	81 7f 04 c7 71
	1c 07		 cmp	 DWORD PTR [edi+4], 119304647 ; 071c71c7H
  000da	74 6b		 je	 SHORT $LN127@AddPrivate

; 1007 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000dc	8b 37		 mov	 esi, DWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  000de	89 7d e4	 mov	 DWORD PTR $T5[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  000e1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  000e8	6a 24		 push	 36			; 00000024H

; 1012 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  000ea	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], 0

; 77   :         return ::operator new(_Bytes);

  000f1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000f6	66 8b 4d ec	 mov	 cx, WORD PTR $T6[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  000fa	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000fd	0f 10 45 b8	 movups	 xmm0, XMMWORD PTR _SellingItem$[ebp]
  00101	66 89 48 0e	 mov	 WORD PTR [eax+14], cx
  00105	8a 4d ef	 mov	 cl, BYTE PTR $T7[ebp]
  00108	88 48 10	 mov	 BYTE PTR [eax+16], cl
  0010b	8a 4b 0c	 mov	 cl, BYTE PTR _dwDisplayPos$[ebx]
  0010e	0f 11 40 11	 movups	 XMMWORD PTR [eax+17], xmm0
  00112	88 48 21	 mov	 BYTE PTR [eax+33], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00115	8b cf		 mov	 ecx, edi
  00117	50		 push	 eax
  00118	ff 75 d8	 push	 DWORD PTR __Loc$3[ebp+4]

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0011b	89 30		 mov	 DWORD PTR [eax], esi

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0011d	ff 75 d4	 push	 DWORD PTR __Loc$3[ebp]

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00120	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00123	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 811  :         this->_Ptr->_Color = _Red;

  00126	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0012c	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
$LN109@AddPrivate:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 120  : }

  00131	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00134	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013b	59		 pop	 ecx
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	8b e3		 mov	 esp, ebx
  00143	5b		 pop	 ebx
  00144	c2 10 00	 ret	 16			; 00000010H
$LN127@AddPrivate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1630 :             _Throw_tree_length_error();

  00147	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN125@AddPrivate:
  0014c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z$2:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z ENDP ; CPythonShop::AddPrivateShopItemStock
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
;	COMDAT ??0SShopItemTable@@QAE@XZ
_TEXT	SEGMENT
??0SShopItemTable@@QAE@XZ PROC				; SShopItemTable::SShopItemTable, COMDAT
; _this$ = ecx

; 202  : 		cell = WORD_MAX;

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00005	c6 41 05 01	 mov	 BYTE PTR [ecx+5], 1
  00009	66 89 41 06	 mov	 WORD PTR [ecx+6], ax
  0000d	8b c1		 mov	 eax, ecx
  0000f	c3		 ret	 0
??0SShopItemTable@@QAE@XZ ENDP				; SShopItemTable::SShopItemTable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
_ItemPos$ = 8						; size = 3
?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z PROC ; CPythonShop::DelPrivateShopItemStock, COMDAT
; _this$ = ecx

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1367 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00007	8d 45 08	 lea	 eax, DWORD PTR _ItemPos$[ebp]
  0000a	50		 push	 eax

; 1136 :         return iterator(_Scary->_Myhead, _Scary);

  0000b	8d b1 78 2c 00
	00		 lea	 esi, DWORD PTR [ecx+11384]

; 1367 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00011	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]
  00014	8b ce		 mov	 ecx, esi
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001c	8b 55 fc	 mov	 edx, DWORD PTR __Loc$1[ebp+8]
  0001f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00023	75 23		 jne	 SHORT $LN1@DelPrivate
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00025	8a 42 0e	 mov	 al, BYTE PTR [edx+14]
  00028	38 45 08	 cmp	 BYTE PTR _ItemPos$[ebp], al
  0002b	72 1b		 jb	 SHORT $LN1@DelPrivate
  0002d	75 0a		 jne	 SHORT $LN36@DelPrivate
  0002f	66 8b 45 09	 mov	 ax, WORD PTR _ItemPos$[ebp+1]
  00033	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  00037	72 0f		 jb	 SHORT $LN1@DelPrivate
$LN36@DelPrivate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 233  :         return this->_Ptr == _Right._Ptr;

  00039	39 16		 cmp	 DWORD PTR [esi], edx
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 123  : 	if (m_PrivateShopItemStock.end() == m_PrivateShopItemStock.find(ItemPos))

  0003b	74 0b		 je	 SHORT $LN1@DelPrivate

; 124  : 		return;
; 125  : 
; 126  : 	m_PrivateShopItemStock.erase(ItemPos);

  0003d	8d 45 08	 lea	 eax, DWORD PTR _ItemPos$[ebp]
  00040	8b ce		 mov	 ecx, esi
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::erase
$LN1@DelPrivate:

; 127  : }

  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z ENDP ; CPythonShop::DelPrivateShopItemStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?GetPrivateShopItemPrice@CPythonShop@@QAE_JUSItemPos@@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
_ItemPos$ = 8						; size = 3
?GetPrivateShopItemPrice@CPythonShop@@QAE_JUSItemPos@@@Z PROC ; CPythonShop::GetPrivateShopItemPrice, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1367 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00007	8d 45 08	 lea	 eax, DWORD PTR _ItemPos$[ebp]
  0000a	50		 push	 eax
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 130  : 	TPrivateShopItemStock::iterator itor = m_PrivateShopItemStock.find(ItemPos);

  0000b	8d b1 78 2c 00
	00		 lea	 esi, DWORD PTR [ecx+11384]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1367 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00011	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]
  00014	8b ce		 mov	 ecx, esi
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001c	8b 55 fc	 mov	 edx, DWORD PTR __Loc$1[ebp+8]
  0001f	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00023	75 25		 jne	 SHORT $LN42@GetPrivate
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00025	8a 42 0e	 mov	 al, BYTE PTR [edx+14]
  00028	38 45 08	 cmp	 BYTE PTR _ItemPos$[ebp], al
  0002b	72 1d		 jb	 SHORT $LN42@GetPrivate
  0002d	75 0a		 jne	 SHORT $LN43@GetPrivate
  0002f	66 8b 45 09	 mov	 ax, WORD PTR _ItemPos$[ebp+1]
  00033	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  00037	72 11		 jb	 SHORT $LN42@GetPrivate
$LN43@GetPrivate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00039	39 16		 cmp	 DWORD PTR [esi], edx
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 132  : 	if (m_PrivateShopItemStock.end() == itor)

  0003b	74 0d		 je	 SHORT $LN42@GetPrivate

; 134  : 
; 135  : 	TShopItemTable & rShopItemTable = itor->second;
; 136  : 	return rShopItemTable.price;

  0003d	8b 42 19	 mov	 eax, DWORD PTR [edx+25]
  00040	8b 52 1d	 mov	 edx, DWORD PTR [edx+29]
  00043	5e		 pop	 esi

; 137  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN42@GetPrivate:

; 133  : 		return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	33 d2		 xor	 edx, edx
  0004e	5e		 pop	 esi

; 137  : }

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?GetPrivateShopItemPrice@CPythonShop@@QAE_JUSItemPos@@@Z ENDP ; CPythonShop::GetPrivateShopItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ??RItemStockSortFunc@@QAE_NAAUSShopItemTable@@0@Z
_TEXT	SEGMENT
_rkLeft$ = 8						; size = 4
_rkRight$ = 12						; size = 4
??RItemStockSortFunc@@QAE_NAAUSShopItemTable@@0@Z PROC	; ItemStockSortFunc::operator(), COMDAT
; _this$dead$ = ecx

; 141  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00003	8b 45 08	 mov	 eax, DWORD PTR _rkLeft$[ebp]
  00006	8a 48 10	 mov	 cl, BYTE PTR [eax+16]
  00009	8b 45 0c	 mov	 eax, DWORD PTR _rkRight$[ebp]
  0000c	3a 48 10	 cmp	 cl, BYTE PTR [eax+16]
  0000f	0f 92 c0	 setb	 al

; 143  : 	}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??RItemStockSortFunc@@QAE_NAAUSShopItemTable@@0@Z ENDP	; ItemStockSortFunc::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?BuildPrivateShop@CPythonShop@@QAEXPBD@Z
_TEXT	SEGMENT
_ItemStock$ = -28					; size = 12
_itor$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 1
_c_szName$ = 8						; size = 4
?BuildPrivateShop@CPythonShop@@QAEXPBD@Z PROC		; CPythonShop::BuildPrivateShop, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00029	33 f6		 xor	 esi, esi
  0002b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _ItemStock$[ebp], 0
  00032	89 75 e8	 mov	 DWORD PTR _ItemStock$[ebp+4], esi
  00035	89 75 ec	 mov	 DWORD PTR _ItemStock$[ebp+8], esi
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 147  : 	std::vector<TShopItemTable> ItemStock;

  00038	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi

; 148  : 	ItemStock.reserve(m_PrivateShopItemStock.size());

  0003b	8b 87 7c 2c 00
	00		 mov	 eax, DWORD PTR [edi+11388]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1743 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00041	85 c0		 test	 eax, eax
  00043	74 17		 je	 SHORT $LN88@BuildPriva

; 1744 :             if (_Newcapacity > max_size()) {

  00045	3d 0f 0f 0f 0f	 cmp	 eax, 252645135		; 0f0f0f0fH
  0004a	0f 87 d9 00 00
	00		 ja	 $LN108@BuildPriva

; 1746 :             }
; 1747 : 
; 1748 :             _Reallocate_exactly(_Newcapacity);

  00050	50		 push	 eax
  00051	8d 4d e4	 lea	 ecx, DWORD PTR _ItemStock$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXI@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocate_exactly
  00059	8b 75 e8	 mov	 esi, DWORD PTR _ItemStock$[ebp+4]
$LN88@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1126 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  0005c	8b 8f 78 2c 00
	00		 mov	 ecx, DWORD PTR [edi+11384]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00062	8b 01		 mov	 eax, DWORD PTR [ecx]
  00064	89 45 f0	 mov	 DWORD PTR _itor$[ebp], eax
  00067	3b c1		 cmp	 eax, ecx
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 151  : 	for (; itor != m_PrivateShopItemStock.end(); ++itor)

  00069	74 41		 je	 SHORT $LN3@BuildPriva
  0006b	0f 1f 44 00 00	 npad	 5
$LL20@BuildPriva:

; 152  : 	{
; 153  : 		ItemStock.push_back(itor->second);

  00070	83 c0 11	 add	 eax, 17			; 00000011H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 844  :         if (_Mylast != _My_data._Myend) {

  00073	3b 75 ec	 cmp	 esi, DWORD PTR _ItemStock$[ebp+8]
  00076	74 14		 je	 SHORT $LN30@BuildPriva
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00078	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0007b	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0007e	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00081	88 46 10	 mov	 BYTE PTR [esi+16], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 869  :         ++_Mylast;

  00084	83 c6 11	 add	 esi, 17			; 00000011H
  00087	89 75 e8	 mov	 DWORD PTR _ItemStock$[ebp+4], esi

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0008a	eb 0d		 jmp	 SHORT $LN2@BuildPriva
$LN30@BuildPriva:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0008c	50		 push	 eax
  0008d	56		 push	 esi
  0008e	8d 4d e4	 lea	 ecx, DWORD PTR _ItemStock$[ebp]
  00091	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>
  00096	8b 75 e8	 mov	 esi, DWORD PTR _ItemStock$[ebp+4]
$LN2@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 199  :         _Mybase::operator++();

  00099	8d 4d f0	 lea	 ecx, DWORD PTR _itor$[ebp]
  0009c	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 233  :         return this->_Ptr == _Right._Ptr;

  000a1	8b 45 f0	 mov	 eax, DWORD PTR _itor$[ebp]
  000a4	3b 87 78 2c 00
	00		 cmp	 eax, DWORD PTR [edi+11384]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 151  : 	for (; itor != m_PrivateShopItemStock.end(); ++itor)

  000aa	75 c4		 jne	 SHORT $LL20@BuildPriva
$LN3@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7669 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  000ac	8b 4d e4	 mov	 ecx, DWORD PTR _ItemStock$[ebp]
  000af	8b c6		 mov	 eax, esi
  000b1	ff 75 08	 push	 DWORD PTR $T2[ebp]
  000b4	2b c1		 sub	 eax, ecx
  000b6	8b d6		 mov	 edx, esi
  000b8	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 158  : 	CPythonNetworkStream::Instance().SendBuildPrivateShopPacket(c_szName, ItemStock);

  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  000ca	8d 45 e4	 lea	 eax, DWORD PTR _ItemStock$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7669 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  000cd	83 c4 08	 add	 esp, 8
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 158  : 	CPythonNetworkStream::Instance().SendBuildPrivateShopPacket(c_szName, ItemStock);

  000d0	50		 push	 eax
  000d1	ff 75 08	 push	 DWORD PTR _c_szName$[ebp]
  000d4	e8 00 00 00 00	 call	 ?SendBuildPrivateShopPacket@CPythonNetworkStream@@QAE_NPBDABV?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@@Z ; CPythonNetworkStream::SendBuildPrivateShopPacket
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2107 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 55 e4	 mov	 edx, DWORD PTR _ItemStock$[ebp]
  000dc	85 d2		 test	 edx, edx
  000de	74 36		 je	 SHORT $LN63@BuildPriva

; 2108 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2109 :             _ASAN_VECTOR_REMOVE;
; 2110 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e0	8b 45 ec	 mov	 eax, DWORD PTR _ItemStock$[ebp+8]
  000e3	2b c2		 sub	 eax, edx
  000e5	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000eb	8b c8		 mov	 ecx, eax
  000ed	c1 e1 04	 shl	 ecx, 4
  000f0	03 c8		 add	 ecx, eax
  000f2	8b c2		 mov	 eax, edx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000fa	72 10		 jb	 SHORT $LN75@BuildPriva

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000fc	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000ff	83 c1 23	 add	 ecx, 35			; 00000023H
  00102	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00104	83 c0 fc	 add	 eax, -4			; fffffffcH
  00107	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010a	77 22		 ja	 SHORT $LN109@BuildPriva
$LN75@BuildPriva:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0010c	51		 push	 ecx
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00113	83 c4 08	 add	 esp, 8
$LN63@BuildPriva:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 159  : }

  00116	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00119	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00120	59		 pop	 ecx
  00121	5f		 pop	 edi
  00122	5e		 pop	 esi
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 04 00	 ret	 4
$LN108@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1745 :                 _Xlength();

  00129	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
$LN109@BuildPriva:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN106@BuildPriva:
  00133	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _ItemStock$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::~vector<SShopItemTable,std::allocator<SShopItemTable> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?BuildPrivateShop@CPythonShop@@QAEXPBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?BuildPrivateShop@CPythonShop@@QAEXPBD@Z ENDP		; CPythonShop::BuildPrivateShop
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?Open@CPythonShop@@QAEXHH@Z
_TEXT	SEGMENT
_isPrivateShop$ = 8					; size = 4
_isMainPrivateShop$ = 12				; size = 4
?Open@CPythonShop@@QAEXHH@Z PROC			; CPythonShop::Open, COMDAT
; _this$ = ecx

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  : 	m_isShoping = TRUE;
; 164  : 	m_isPrivateShop = isPrivateShop;

  00003	8b 45 08	 mov	 eax, DWORD PTR _isPrivateShop$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 165  : 	m_isMainPlayerPrivateShop = isMainPrivateShop;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _isMainPrivateShop$[ebp]
  0000c	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  00013	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 166  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
?Open@CPythonShop@@QAEXHH@Z ENDP			; CPythonShop::Open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?Close@CPythonShop@@QAEXXZ
_TEXT	SEGMENT
?Close@CPythonShop@@QAEXXZ PROC				; CPythonShop::Close, COMDAT
; _this$ = ecx

; 170  : 	m_isShoping = FALSE;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 171  : 	m_isPrivateShop = FALSE;

  00007	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 172  : 	m_isMainPlayerPrivateShop = FALSE;

  0000e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 173  : }

  00015	c3		 ret	 0
?Close@CPythonShop@@QAEXXZ ENDP				; CPythonShop::Close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?IsPrivateShop@CPythonShop@@QAEHXZ
_TEXT	SEGMENT
?IsPrivateShop@CPythonShop@@QAEHXZ PROC			; CPythonShop::IsPrivateShop, COMDAT
; _this$ = ecx

; 182  : 	return m_isPrivateShop;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 183  : }

  00003	c3		 ret	 0
?IsPrivateShop@CPythonShop@@QAEHXZ ENDP			; CPythonShop::IsPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ
_TEXT	SEGMENT
?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ PROC	; CPythonShop::IsMainPlayerPrivateShop, COMDAT
; _this$ = ecx

; 187  : 	return m_isMainPlayerPrivateShop;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 188  : }

  00003	c3		 ret	 0
?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ ENDP	; CPythonShop::IsMainPlayerPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCPythonShop@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCPythonShop@@UAEPAXI@Z PROC				; CPythonShop::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CPythonShop@@UAE@XZ	; CPythonShop::~CPythonShop
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 80 2c 00 00	 push	 11392			; 00002c80H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCPythonShop@@UAEPAXI@Z ENDP				; CPythonShop::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??1ShopTab@CPythonShop@@QAE@XZ
_TEXT	SEGMENT
??1ShopTab@CPythonShop@@QAE@XZ PROC			; CPythonShop::ShopTab::~ShopTab, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2301 :         return _BUF_SIZE <= _Myres;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 5008 :         if (_My_data._Large_string_engaged()) {

  00009	72 28		 jb	 SHORT $LN15@ShopTab
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5013 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0000e	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN27@ShopTab

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 20		 ja	 SHORT $LN24@ShopTab

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN27@ShopTab:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8
$LN15@ShopTab:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5016 :         _My_data._Mysize = 0;

  00033	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 5017 :         _My_data._Myres  = _BUF_SIZE - 1;

  0003a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH

; 5018 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5019 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00041	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  00045	5e		 pop	 esi
  00046	c3		 ret	 0
$LN24@ShopTab:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00047	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN33@ShopTab:
  0004c	cc		 int	 3
??1ShopTab@CPythonShop@@QAE@XZ ENDP			; CPythonShop::ShopTab::~ShopTab
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??1?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ PROC ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::~map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 24		 push	 36			; 00000024H
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::~map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopOpen@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_isPrivateShop$ = -8					; size = 4
_isMainPrivateShop$ = -4				; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopOpen@@YAPAU_object@@PAU1@0@Z PROC			; shopOpen, COMDAT

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 213  : 	int isPrivateShop = false;
; 214  : 	PyTuple_GetInteger(poArgs, 0, &isPrivateShop);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _isPrivateShop$[ebp]
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _isPrivateShop$[ebp], 0
  00010	50		 push	 eax
  00011	6a 00		 push	 0
  00013	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00016	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger

; 215  : 	int isMainPrivateShop = false;
; 216  : 	PyTuple_GetInteger(poArgs, 1, &isMainPrivateShop);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _isMainPrivateShop$[ebp]
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _isMainPrivateShop$[ebp], 0
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0002b	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger

; 217  : 
; 218  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 219  : 	rkShop.Open(isPrivateShop, isMainPrivateShop);

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00036	83 c4 18	 add	 esp, 24			; 00000018H
  00039	ff 75 fc	 push	 DWORD PTR _isMainPrivateShop$[ebp]
  0003c	ff 75 f8	 push	 DWORD PTR _isPrivateShop$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Open@CPythonShop@@QAEXHH@Z ; CPythonShop::Open

; 220  : 	return Py_BuildNone();

  00044	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 221  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?shopOpen@@YAPAU_object@@PAU1@0@Z ENDP			; shopOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopClose@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopClose@@YAPAU_object@@PAU1@0@Z PROC			; shopClose, COMDAT

; 225  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 226  : 	rkShop.Close();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?Close@CPythonShop@@QAEXXZ ; CPythonShop::Close

; 227  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?shopClose@@YAPAU_object@@PAU1@0@Z ENDP			; shopClose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopIsOpen@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopIsOpen@@YAPAU_object@@PAU1@0@Z PROC		; shopIsOpen, COMDAT

; 232  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 233  : 	return Py_BuildValue("i", rkShop.IsOpen());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsOpen@CPythonShop@@QAEHXZ ; CPythonShop::IsOpen
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 234  : }

  0001a	c3		 ret	 0
?shopIsOpen@@YAPAU_object@@PAU1@0@Z ENDP		; shopIsOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z PROC		; shopIsPrviateShop, COMDAT

; 238  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 239  : 	return Py_BuildValue("i", rkShop.IsPrivateShop());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsPrivateShop@CPythonShop@@QAEHXZ ; CPythonShop::IsPrivateShop
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 240  : }

  0001a	c3		 ret	 0
?shopIsPrviateShop@@YAPAU_object@@PAU1@0@Z ENDP		; shopIsPrviateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z PROC ; shopIsMainPlayerPrivateShop, COMDAT

; 244  : 	CPythonShop& rkShop=CPythonShop::Instance();
; 245  : 	return Py_BuildValue("i", rkShop.IsMainPlayerPrivateShop());

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?IsMainPlayerPrivateShop@CPythonShop@@QAEHXZ ; CPythonShop::IsMainPlayerPrivateShop
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00017	83 c4 08	 add	 esp, 8

; 246  : }

  0001a	c3		 ret	 0
?shopIsMainPlayerPrivateShop@@YAPAU_object@@PAU1@0@Z ENDP ; shopIsMainPlayerPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemID@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$ = -8					; size = 4
_nPos$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemID@@YAPAU_object@@PAU1@0@Z PROC		; shopGetItemID, COMDAT

; 249  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 250  : 	int nPos;
; 251  : 	if (!PyTuple_GetInteger(poArgs, 0, &nPos))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _nPos$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte

; 252  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 259  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 253  : 
; 254  : 	const TShopItemData * c_pItemData;
; 255  : 	if (CPythonShop::Instance().GetItemData(nPos, &c_pItemData))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _c_pItemData$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _nPos$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  0003b	85 c0		 test	 eax, eax
  0003d	74 17		 je	 SHORT $LN3@shopGetIte

; 256  : 		return Py_BuildValue("i", c_pItemData->vnum);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _c_pItemData$[ebp]
  00042	ff 30		 push	 DWORD PTR [eax]

; 259  : }

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0004f	83 c4 08	 add	 esp, 8
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN3@shopGetIte:

; 257  : 
; 258  : 	return Py_BuildValue("i", 0);

  00056	6a 00		 push	 0

; 259  : }

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00063	83 c4 08	 add	 esp, 8
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?shopGetItemID@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetItemID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemCount@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$ = -8					; size = 4
_iIndex$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemCount@@YAPAU_object@@PAU1@0@Z PROC		; shopGetItemCount, COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 263  : 	int iIndex;
; 264  : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte

; 265  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 272  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 266  : 
; 267  : 	const TShopItemData * c_pItemData;
; 268  : 	if (CPythonShop::Instance().GetItemData(iIndex, &c_pItemData))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _c_pItemData$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iIndex$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  0003b	85 c0		 test	 eax, eax
  0003d	74 1a		 je	 SHORT $LN3@shopGetIte

; 269  : 		return Py_BuildValue("i", c_pItemData->count);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _c_pItemData$[ebp]
  00042	0f b6 40 0c	 movzx	 eax, BYTE PTR [eax+12]
  00046	50		 push	 eax

; 272  : }

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00052	83 c4 08	 add	 esp, 8
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN3@shopGetIte:

; 270  : 
; 271  : 	return Py_BuildValue("i", 0);

  00059	6a 00		 push	 0

; 272  : }

  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00066	83 c4 08	 add	 esp, 8
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?shopGetItemCount@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetItemCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$ = -8					; size = 4
_iIndex$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z PROC		; shopGetItemPrice, COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 276  : 	int iIndex;
; 277  : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte

; 278  : 		return Py_BuildException();

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4

; 285  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 279  : 
; 280  : 	const TShopItemData * c_pItemData;
; 281  : 	if (CPythonShop::Instance().GetItemData(iIndex, &c_pItemData))

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0002f	8d 45 f8	 lea	 eax, DWORD PTR _c_pItemData$[ebp]
  00032	50		 push	 eax
  00033	ff 75 fc	 push	 DWORD PTR _iIndex$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  0003b	85 c0		 test	 eax, eax
  0003d	74 1b		 je	 SHORT $LN3@shopGetIte

; 282  : 		return Py_BuildValue("L", c_pItemData->price);	

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _c_pItemData$[ebp]
  00042	ff 70 08	 push	 DWORD PTR [eax+8]
  00045	ff 70 04	 push	 DWORD PTR [eax+4]
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_01OCOKONAJ@L@
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 285  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN3@shopGetIte:

; 283  : 
; 284  : 	return Py_BuildValue("i", 0);

  0005a	6a 00		 push	 0
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00067	83 c4 08	 add	 esp, 8

; 285  : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?shopGetItemPrice@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$ = -12					; size = 4
_iMetinSocketIndex$ = -8				; size = 4
_iIndex$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z PROC	; shopGetItemMetinSocket, COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 289  : 	int iIndex;
; 290  : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte
$LN7@shopGetIte:

; 301  : }

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 291  : 		return Py_BuildException();
; 292  : 	int iMetinSocketIndex;
; 293  : 	if (!PyTuple_GetInteger(poArgs, 1, &iMetinSocketIndex))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _iMetinSocketIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@shopGetIte

; 294  : 		return Py_BuildException();
; 295  : 
; 296  : 	const TShopItemData * c_pItemData;
; 297  : 	if (CPythonShop::Instance().GetItemData(iIndex, &c_pItemData))

  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00044	8d 45 f4	 lea	 eax, DWORD PTR _c_pItemData$[ebp]
  00047	50		 push	 eax
  00048	ff 75 fc	 push	 DWORD PTR _iIndex$[ebp]
  0004b	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  00050	85 c0		 test	 eax, eax
  00052	74 1c		 je	 SHORT $LN4@shopGetIte

; 298  : 		return Py_BuildValue("i", c_pItemData->alSockets[iMetinSocketIndex]);

  00054	8b 4d f8	 mov	 ecx, DWORD PTR _iMetinSocketIndex$[ebp]
  00057	8b 45 f4	 mov	 eax, DWORD PTR _c_pItemData$[ebp]
  0005a	ff 74 88 0e	 push	 DWORD PTR [eax+ecx*4+14]

; 301  : }

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00069	83 c4 08	 add	 esp, 8
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
$LN4@shopGetIte:

; 299  : 
; 300  : 	return Py_BuildValue("i", 0);

  00070	6a 00		 push	 0

; 301  : }

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0007d	83 c4 08	 add	 esp, 8
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?shopGetItemMetinSocket@@YAPAU_object@@PAU1@0@Z ENDP	; shopGetItemMetinSocket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_c_pItemData$1 = -12					; size = 4
_iIndex$ = -8						; size = 4
_iAttrSlotIndex$ = -4					; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z PROC	; shopGetItemAttribute, COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 305  : 	int iIndex;
; 306  : 	if (!PyTuple_GetInteger(poArgs, 0, &iIndex))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _iIndex$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetIte
$LN8@shopGetIte:

; 320  : }

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetIte:

; 307  : 		return Py_BuildException();
; 308  : 	int iAttrSlotIndex;
; 309  : 	if (!PyTuple_GetInteger(poArgs, 1, &iAttrSlotIndex))

  00029	8d 45 fc	 lea	 eax, DWORD PTR _iAttrSlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN8@shopGetIte

; 310  : 		return Py_BuildException();
; 311  : 
; 312  : 	if (iAttrSlotIndex >= 0 && iAttrSlotIndex < ITEM_ATTRIBUTE_SLOT_MAX_NUM)

  0003e	83 7d fc 06	 cmp	 DWORD PTR _iAttrSlotIndex$[ebp], 6
  00042	77 40		 ja	 SHORT $LN5@shopGetIte

; 313  : 	{
; 314  : 		const TShopItemData * c_pItemData;
; 315  : 		if (CPythonShop::Instance().GetItemData(iIndex, &c_pItemData))

  00044	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  0004a	8d 45 f4	 lea	 eax, DWORD PTR _c_pItemData$1[ebp]
  0004d	50		 push	 eax
  0004e	ff 75 f8	 push	 DWORD PTR _iIndex$[ebp]
  00051	e8 00 00 00 00	 call	 ?GetItemData@CPythonShop@@QAEHKPAPBUpacket_shop_item@@@Z ; CPythonShop::GetItemData
  00056	85 c0		 test	 eax, eax
  00058	74 2a		 je	 SHORT $LN5@shopGetIte

; 316  : 			return Py_BuildValue("ii", c_pItemData->aAttr[iAttrSlotIndex].bType, c_pItemData->aAttr[iAttrSlotIndex].sValue);

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _iAttrSlotIndex$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _c_pItemData$1[ebp]
  00060	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00063	0f bf 44 02 1b	 movsx	 eax, WORD PTR [edx+eax+27]
  00068	50		 push	 eax
  00069	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  0006c	0f b6 44 02 1a	 movzx	 eax, BYTE PTR [edx+eax+26]
  00071	50		 push	 eax

; 320  : }

  00072	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii@
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN5@shopGetIte:

; 317  : 	}
; 318  : 
; 319  : 	return Py_BuildValue("ii", 0, 0);

  00084	6a 00		 push	 0
  00086	6a 00		 push	 0

; 320  : }

  00088	68 00 00 00 00	 push	 OFFSET ??_C@_02PDIHAGKM@ii@
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?shopGetItemAttribute@@YAPAU_object@@PAU1@0@Z ENDP	; shopGetItemAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z PROC	; shopClearPrivateShopStock, COMDAT

; 324  : 	CPythonShop::Instance().ClearPrivateShopStock();

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00006	e8 00 00 00 00	 call	 ?ClearPrivateShopStock@CPythonShop@@QAEXXZ ; CPythonShop::ClearPrivateShopStock

; 325  : 	return Py_BuildNone();

  0000b	e9 00 00 00 00	 jmp	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone
?shopClearPrivateShopStock@@YAPAU_object@@PAU1@0@Z ENDP	; shopClearPrivateShopStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_bItemWindowType$ = -21					; size = 1
_wItemSlotIndex$ = -20					; size = 2
$T1 = -15						; size = 3
_iDisplaySlotIndex$ = -12				; size = 4
_iPrice$ = -8						; size = 8
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z PROC ; shopAddPrivateShopItemStock, COMDAT

; 328  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 329  : 	BYTE bItemWindowType;
; 330  : 	if (!PyTuple_GetInteger(poArgs, 0, &bItemWindowType))

  00009	8d 44 24 07	 lea	 eax, DWORD PTR _bItemWindowType$[esp+28]
  0000d	56		 push	 esi
  0000e	8b 75 0c	 mov	 esi, DWORD PTR _poArgs$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	84 c0		 test	 al, al
  0001f	75 0f		 jne	 SHORT $LN2@shopAddPri
$LN9@shopAddPri:

; 344  : }

  00021	6a 00		 push	 0
  00023	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00028	83 c4 04	 add	 esp, 4
  0002b	5e		 pop	 esi
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN2@shopAddPri:

; 331  : 		return Py_BuildException();
; 332  : 	WORD wItemSlotIndex;
; 333  : 	if (!PyTuple_GetInteger(poArgs, 1, &wItemSlotIndex))

  00030	8d 44 24 0c	 lea	 eax, DWORD PTR _wItemSlotIndex$[esp+32]
  00034	50		 push	 eax
  00035	6a 01		 push	 1
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	84 c0		 test	 al, al
  00042	74 dd		 je	 SHORT $LN9@shopAddPri

; 334  : 		return Py_BuildException();
; 335  : 	int iDisplaySlotIndex;
; 336  : 	if (!PyTuple_GetInteger(poArgs, 2, &iDisplaySlotIndex))

  00044	8d 44 24 14	 lea	 eax, DWORD PTR _iDisplaySlotIndex$[esp+32]
  00048	50		 push	 eax
  00049	6a 02		 push	 2
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAH@Z ; PyTuple_GetInteger
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	84 c0		 test	 al, al
  00056	74 c9		 je	 SHORT $LN9@shopAddPri

; 337  : 		return Py_BuildException();
; 338  : 	long long iPrice;
; 339  : 	if (!PyTuple_GetLongLong(poArgs, 3, &iPrice))

  00058	8d 44 24 18	 lea	 eax, DWORD PTR _iPrice$[esp+32]
  0005c	50		 push	 eax
  0005d	6a 03		 push	 3
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?PyTuple_GetLongLong@@YA_NPAU_object@@HPA_J@Z ; PyTuple_GetLongLong
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	84 c0		 test	 al, al
  0006a	74 b5		 je	 SHORT $LN9@shopAddPri

; 342  : 	CPythonShop::Instance().AddPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex), iDisplaySlotIndex, iPrice);

  0006c	ff 74 24 1c	 push	 DWORD PTR _iPrice$[esp+36]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 206  :         window_type = _window_type;

  00070	8a 44 24 0f	 mov	 al, BYTE PTR _bItemWindowType$[esp+36]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 342  : 	CPythonShop::Instance().AddPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex), iDisplaySlotIndex, iPrice);

  00074	ff 74 24 1c	 push	 DWORD PTR _iPrice$[esp+36]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 206  :         window_type = _window_type;

  00078	88 44 24 19	 mov	 BYTE PTR $T1[esp+40], al
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 342  : 	CPythonShop::Instance().AddPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex), iDisplaySlotIndex, iPrice);

  0007c	ff 74 24 1c	 push	 DWORD PTR _iDisplaySlotIndex$[esp+40]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 207  :         cell = _cell;

  00080	0f b7 44 24 18	 movzx	 eax, WORD PTR _wItemSlotIndex$[esp+44]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 342  : 	CPythonShop::Instance().AddPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex), iDisplaySlotIndex, iPrice);

  00085	51		 push	 ecx
  00086	8b cc		 mov	 ecx, esp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 207  :         cell = _cell;

  00088	66 89 44 24 22	 mov	 WORD PTR $T1[esp+49], ax
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 342  : 	CPythonShop::Instance().AddPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex), iDisplaySlotIndex, iPrice);

  0008d	0f b7 44 24 21	 movzx	 eax, WORD PTR $T1[esp+48]
  00092	66 89 01	 mov	 WORD PTR [ecx], ax
  00095	8a 44 24 23	 mov	 al, BYTE PTR $T1[esp+50]
  00099	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  000a2	e8 00 00 00 00	 call	 ?AddPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@E_J@Z ; CPythonShop::AddPrivateShopItemStock

; 343  : 	return Py_BuildNone();

  000a7	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 344  : }

  000ac	5e		 pop	 esi
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
?shopAddPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z ENDP ; shopAddPrivateShopItemStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
$T1 = -11						; size = 3
_wItemSlotIndex$ = -8					; size = 2
_bItemWindowType$ = -1					; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z PROC ; shopDelPrivateShopItemStock, COMDAT

; 346  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 347  : 	BYTE bItemWindowType;
; 348  : 	if (!PyTuple_GetInteger(poArgs, 0, &bItemWindowType))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _bItemWindowType$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopDelPri
$LN7@shopDelPri:

; 356  : }

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopDelPri:

; 349  : 		return Py_BuildException();
; 350  : 	WORD wItemSlotIndex;
; 351  : 	if (!PyTuple_GetInteger(poArgs, 1, &wItemSlotIndex))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _wItemSlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@shopDelPri
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 206  :         window_type = _window_type;

  0003e	8a 45 ff	 mov	 al, BYTE PTR _bItemWindowType$[ebp]
  00041	88 45 f5	 mov	 BYTE PTR $T1[ebp], al

; 207  :         cell = _cell;

  00044	0f b7 45 f8	 movzx	 eax, WORD PTR _wItemSlotIndex$[ebp]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 354  : 	CPythonShop::Instance().DelPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex));

  00048	51		 push	 ecx
  00049	8b cc		 mov	 ecx, esp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 207  :         cell = _cell;

  0004b	66 89 45 f6	 mov	 WORD PTR $T1[ebp+1], ax
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 354  : 	CPythonShop::Instance().DelPrivateShopItemStock(TItemPos(bItemWindowType, wItemSlotIndex));

  0004f	0f b7 45 f5	 movzx	 eax, WORD PTR $T1[ebp]
  00053	66 89 01	 mov	 WORD PTR [ecx], ax
  00056	8a 45 f7	 mov	 al, BYTE PTR $T1[ebp+2]
  00059	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00062	e8 00 00 00 00	 call	 ?DelPrivateShopItemStock@CPythonShop@@QAEXUSItemPos@@@Z ; CPythonShop::DelPrivateShopItemStock

; 355  : 	return Py_BuildNone();

  00067	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 356  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?shopDelPrivateShopItemStock@@YAPAU_object@@PAU1@0@Z ENDP ; shopDelPrivateShopItemStock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
$T1 = -11						; size = 3
_wItemSlotIndex$ = -8					; size = 2
_bItemWindowType$ = -1					; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z PROC ; shopGetPrivateShopItemPrice, COMDAT

; 358  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 359  : 	BYTE bItemWindowType;
; 360  : 	if (!PyTuple_GetInteger(poArgs, 0, &bItemWindowType))

  00006	8d 45 ff	 lea	 eax, DWORD PTR _bItemWindowType$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000f	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	84 c0		 test	 al, al
  00019	75 0e		 jne	 SHORT $LN2@shopGetPri
$LN7@shopGetPri:

; 368  : }

  0001b	6a 00		 push	 0
  0001d	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00022	83 c4 04	 add	 esp, 4
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN2@shopGetPri:

; 361  : 		return Py_BuildException();
; 362  : 	WORD wItemSlotIndex;
; 363  : 	if (!PyTuple_GetInteger(poArgs, 1, &wItemSlotIndex))

  00029	8d 45 f8	 lea	 eax, DWORD PTR _wItemSlotIndex$[ebp]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  00032	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAG@Z ; PyTuple_GetInteger
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	84 c0		 test	 al, al
  0003c	74 dd		 je	 SHORT $LN7@shopGetPri
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 206  :         window_type = _window_type;

  0003e	8a 45 ff	 mov	 al, BYTE PTR _bItemWindowType$[ebp]
  00041	88 45 f5	 mov	 BYTE PTR $T1[ebp], al

; 207  :         cell = _cell;

  00044	0f b7 45 f8	 movzx	 eax, WORD PTR _wItemSlotIndex$[ebp]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 366  : 	long long iValue = CPythonShop::Instance().GetPrivateShopItemPrice(TItemPos(bItemWindowType, wItemSlotIndex));

  00048	51		 push	 ecx
  00049	8b cc		 mov	 ecx, esp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 207  :         cell = _cell;

  0004b	66 89 45 f6	 mov	 WORD PTR $T1[ebp+1], ax
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 366  : 	long long iValue = CPythonShop::Instance().GetPrivateShopItemPrice(TItemPos(bItemWindowType, wItemSlotIndex));

  0004f	0f b7 45 f5	 movzx	 eax, WORD PTR $T1[ebp]
  00053	66 89 01	 mov	 WORD PTR [ecx], ax
  00056	8a 45 f7	 mov	 al, BYTE PTR $T1[ebp+2]
  00059	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00062	e8 00 00 00 00	 call	 ?GetPrivateShopItemPrice@CPythonShop@@QAE_JUSItemPos@@@Z ; CPythonShop::GetPrivateShopItemPrice

; 367  : 	return Py_BuildValue("L", iValue);

  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_01OCOKONAJ@L@
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 368  : }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?shopGetPrivateShopItemPrice@@YAPAU_object@@PAU1@0@Z ENDP ; shopGetPrivateShopItemPrice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_szName$ = -4						; size = 4
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z PROC	; shopBuildPrivateShop, COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 371  : 	char * szName;
; 372  : 	if (!PyTuple_GetString(poArgs, 0, &szName))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _szName$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetString@@YA_NPAU_object@@HPAPAD@Z ; PyTuple_GetString
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN2@shopBuildP

; 373  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 377  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@shopBuildP:

; 374  : 
; 375  : 	CPythonShop::Instance().BuildPrivateShop(szName);

  00027	ff 75 fc	 push	 DWORD PTR _szName$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?BuildPrivateShop@CPythonShop@@QAEXPBD@Z ; CPythonShop::BuildPrivateShop

; 376  : 	return Py_BuildNone();

  00035	e8 00 00 00 00	 call	 ?Py_BuildNone@@YAPAU_object@@XZ ; Py_BuildNone

; 377  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?shopBuildPrivateShop@@YAPAU_object@@PAU1@0@Z ENDP	; shopBuildPrivateShop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetTabCount@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetTabCount@@YAPAU_object@@PAU1@0@Z PROC		; shopGetTabCount, COMDAT

; 381  : 	return Py_BuildValue("i", CPythonShop::instance().GetTabCount());

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00005	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00009	50		 push	 eax
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00015	83 c4 08	 add	 esp, 8

; 382  : }

  00018	c3		 ret	 0
?shopGetTabCount@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetTabCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetTabName@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_bTabIdx$ = -4						; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetTabName@@YAPAU_object@@PAU1@0@Z PROC		; shopGetTabName, COMDAT

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 386  : 	BYTE bTabIdx;
; 387  : 	if (!PyTuple_GetInteger(poArgs, 0, &bTabIdx))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _bTabIdx$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN2@shopGetTab

; 388  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 391  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@shopGetTab:

; 389  : 
; 390  : 	return Py_BuildValue("s", CPythonShop::instance().GetTabName(bTabIdx));

  00027	ff 75 fc	 push	 DWORD PTR _bTabIdx$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?GetTabName@CPythonShop@@QAEPBDE@Z ; CPythonShop::GetTabName
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00041	83 c4 08	 add	 esp, 8

; 391  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?shopGetTabName@@YAPAU_object@@PAU1@0@Z ENDP		; shopGetTabName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z
_TEXT	SEGMENT
_bTabIdx$ = -4						; size = 1
_poSelf$ = 8						; size = 4
_poArgs$ = 12						; size = 4
?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z PROC	; shopGetTabCoinType, COMDAT

; 394  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 395  : 	BYTE bTabIdx;
; 396  : 	if (!PyTuple_GetInteger(poArgs, 0, &bTabIdx))

  00004	8d 45 fc	 lea	 eax, DWORD PTR _bTabIdx$[ebp]
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	ff 75 0c	 push	 DWORD PTR _poArgs$[ebp]
  0000d	e8 00 00 00 00	 call	 ?PyTuple_GetInteger@@YA_NPAU_object@@HPAE@Z ; PyTuple_GetInteger
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	84 c0		 test	 al, al
  00017	75 0e		 jne	 SHORT $LN2@shopGetTab

; 397  : 		return Py_BuildException();

  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?Py_BuildException@@YAPAU_object@@PBDZZ ; Py_BuildException
  00020	83 c4 04	 add	 esp, 4

; 400  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN2@shopGetTab:

; 398  : 
; 399  : 	return Py_BuildValue("i", CPythonShop::instance().GetTabCoinType(bTabIdx));

  00027	ff 75 fc	 push	 DWORD PTR _bTabIdx$[ebp]
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A ; CSingleton<CPythonShop>::ms_singleton
  00030	e8 00 00 00 00	 call	 ?GetTabCoinType@CPythonShop@@QAEEE@Z ; CPythonShop::GetTabCoinType
  00035	0f b6 c0	 movzx	 eax, al
  00038	50		 push	 eax
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00044	83 c4 08	 add	 esp, 8

; 400  : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?shopGetTabCoinType@@YAPAU_object@@PAU1@0@Z ENDP	; shopGetTabCoinType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
;	COMDAT ?initshop@@YAXXZ
_TEXT	SEGMENT
?initshop@@YAXXZ PROC					; initshop, COMDAT

; 403  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 404  : 	static PyMethodDef s_methods[] =
; 405  : 	{
; 406  : 		// Shop
; 407  : 		{ "Open",						shopOpen,						METH_VARARGS },
; 408  : 		{ "Close",						shopClose,						METH_VARARGS },
; 409  : 		{ "IsOpen",						shopIsOpen,						METH_VARARGS },
; 410  : 		{ "IsPrivateShop",				shopIsPrviateShop,				METH_VARARGS },
; 411  : 		{ "IsMainPlayerPrivateShop",	shopIsMainPlayerPrivateShop,	METH_VARARGS },
; 412  : 		{ "GetItemID",					shopGetItemID,					METH_VARARGS },
; 413  : 		{ "GetItemCount",				shopGetItemCount,				METH_VARARGS },
; 414  : 		{ "GetItemPrice",				shopGetItemPrice,				METH_VARARGS },
; 415  : 		{ "GetItemMetinSocket",			shopGetItemMetinSocket,			METH_VARARGS },
; 416  : 		{ "GetItemAttribute",			shopGetItemAttribute,			METH_VARARGS },
; 417  : 		{ "GetTabCount",				shopGetTabCount,				METH_VARARGS },
; 418  : 		{ "GetTabName",					shopGetTabName,					METH_VARARGS },
; 419  : 		{ "GetTabCoinType",				shopGetTabCoinType,				METH_VARARGS },
; 420  : 
; 421  : 		// Private Shop
; 422  : 		{ "ClearPrivateShopStock",		shopClearPrivateShopStock,		METH_VARARGS },
; 423  : 		{ "AddPrivateShopItemStock",	shopAddPrivateShopItemStock,	METH_VARARGS },
; 424  : 		{ "DelPrivateShopItemStock",	shopDelPrivateShopItemStock,	METH_VARARGS },
; 425  : 		{ "GetPrivateShopItemPrice",	shopGetPrivateShopItemPrice,	METH_VARARGS },
; 426  : 		{ "BuildPrivateShop",			shopBuildPrivateShop,			METH_VARARGS },
; 427  : 		{ NULL,							NULL,							NULL },
; 428  : 	};
; 429  : 	PyObject * poModule = Py_InitModule("shop", s_methods);

  00002	68 f5 03 00 00	 push	 1013			; 000003f5H
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	68 00 00 00 00	 push	 OFFSET ?s_methods@?1??initshop@@YAXXZ@4PAUPyMethodDef@@A
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_04BFIJLIPK@shop@
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_InitModule4

; 430  : 
; 431  : 	PyModule_AddIntConstant(poModule, "SHOP_SLOT_COUNT", SHOP_HOST_ITEM_MAX_NUM);

  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__PyModule_AddIntConstant
  00021	8b f8		 mov	 edi, eax
  00023	6a 50		 push	 80			; 00000050H
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MMIAEKCC@SHOP_SLOT_COUNT@
  0002a	57		 push	 edi
  0002b	ff d6		 call	 esi

; 432  : 	PyModule_AddIntConstant(poModule, "SHOP_COIN_TYPE_GOLD", SHOP_COIN_TYPE_GOLD);

  0002d	6a 00		 push	 0
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FOBHCAAH@SHOP_COIN_TYPE_GOLD@
  00034	57		 push	 edi
  00035	ff d6		 call	 esi

; 433  : 	PyModule_AddIntConstant(poModule, "SHOP_COIN_TYPE_SECONDARY_COIN", SHOP_COIN_TYPE_SECONDARY_COIN);

  00037	6a 01		 push	 1
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GEPHLMDC@SHOP_COIN_TYPE_SECONDARY_COIN@
  0003e	57		 push	 edi
  0003f	ff d6		 call	 esi
  00041	83 c4 38	 add	 esp, 56			; 00000038H
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 434  : }

  00046	c3		 ret	 0
?initshop@@YAXXZ ENDP					; initshop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end, COMDAT
; _this$ = ecx

; 1867 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1868 :         auto& _My_data = _Mypair._Myval2;
; 1869 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));
; 1870 :     }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QAE@PAUSShopItemTable@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin, COMDAT
; _this$ = ecx

; 1857 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 41   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1858 :         auto& _My_data = _Mypair._Myval2;
; 1859 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));
; 1860 :     }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?reserve@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXI@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::reserve, COMDAT
; _this$ = ecx

; 1741 :     _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1942 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1742 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1743 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00008	8b 55 08	 mov	 edx, DWORD PTR __Newcapacity$[ebp]

; 1942 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000b	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135

; 1742 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1743 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00011	3b d0		 cmp	 edx, eax
  00013	76 11		 jbe	 SHORT $LN2@reserve

; 1744 :             if (_Newcapacity > max_size()) {

  00015	81 fa 0f 0f 0f
	0f		 cmp	 edx, 252645135		; 0f0f0f0fH
  0001b	77 0d		 ja	 SHORT $LN10@reserve

; 1746 :             }
; 1747 : 
; 1748 :             _Reallocate_exactly(_Newcapacity);

  0001d	89 55 08	 mov	 DWORD PTR __Newcapacity$[ebp], edx

; 1749 :         }
; 1750 :     }

  00020	5d		 pop	 ebp

; 1746 :             }
; 1747 : 
; 1748 :             _Reallocate_exactly(_Newcapacity);

  00021	e9 00 00 00 00	 jmp	 ?_Reallocate_exactly@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXI@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocate_exactly
$LN2@reserve:

; 1749 :         }
; 1750 :     }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN10@reserve:

; 1745 :                 _Xlength();

  0002a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
$LN8@reserve:
  0002f	cc		 int	 3
?reserve@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXI@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?push_back@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXABUSShopItemTable@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXABUSShopItemTable@@@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::push_back, COMDAT
; _this$ = ecx

; 935  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 844  :         if (_Mylast != _My_data._Myend) {

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00009	74 17		 je	 SHORT $LN4@push_back
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0000b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000e	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00011	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00014	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00017	88 42 10	 mov	 BYTE PTR [edx+16], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 869  :         ++_Mylast;

  0001a	83 41 04 11	 add	 DWORD PTR [ecx+4], 17	; 00000011H

; 936  :         _Emplace_one_at_back(_Val);
; 937  :     }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN4@push_back:

; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00022	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>

; 936  :         _Emplace_one_at_back(_Val);
; 937  :     }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?push_back@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAEXABUSShopItemTable@@@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::~vector<SShopItemTable,std::allocator<SShopItemTable> >, COMDAT
; _this$ = ecx

; 829  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2107 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 16		 mov	 edx, DWORD PTR [esi]
  00005	85 d2		 test	 edx, edx
  00007	74 4c		 je	 SHORT $LN4@vector

; 2108 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2109 :             _ASAN_VECTOR_REMOVE;
; 2110 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c2		 sub	 eax, edx
  0000e	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00014	8b c8		 mov	 ecx, eax
  00016	c1 e1 04	 shl	 ecx, 4
  00019	03 c8		 add	 ecx, eax

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00021	72 14		 jb	 SHORT $LN22@vector

; 147  :     _Bytes += _Non_user_size;

  00023	57		 push	 edi

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00024	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  00027	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002a	2b d7		 sub	 edx, edi

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002c	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  0002f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00032	77 23		 ja	 SHORT $LN19@vector

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00034	8b d7		 mov	 edx, edi
  00036	5f		 pop	 edi
$LN22@vector:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2112 :             _Myfirst = nullptr;

  0003e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00044	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2113 :             _Mylast  = nullptr;

  00047	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2114 :             _Myend   = nullptr;

  0004e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00055	5e		 pop	 esi

; 835  :     }

  00056	c3		 ret	 0
$LN19@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@vector:
  0005c	cc		 int	 3
??1?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::~vector<SShopItemTable,std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??0?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::vector<SShopItemTable,std::allocator<SShopItemTable> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 674  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 675  :     }

  00006	8b c1		 mov	 eax, ecx

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 674  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 675  :     }

  00016	c3		 ret	 0
??0?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::vector<SShopItemTable,std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++, COMDAT
; _this$ = ecx

; 282  :     _Tree_iterator& operator++() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 199  :         _Mybase::operator++();

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 283  :         _Mybase::operator++();
; 284  :         return *this;

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 285  :     }

  0000b	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator->, COMDAT
; _this$ = ecx

; 186  :         return this->_Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0e	 add	 eax, 14			; 0000000eH

; 279  :         return pointer_traits<pointer>::pointer_to(**this);
; 280  :     }

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator==, COMDAT
; _this$ = ecx

; 228  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  : #if _ITERATOR_DEBUG_LEVEL == 2
; 230  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 231  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 232  : 
; 233  :         return this->_Ptr == _Right._Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 234  :     }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map
;	COMDAT ??0?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ PROC ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >, COMDAT
; _this$ = ecx

; 105  :     map() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00007	6a 24		 push	 36			; 00000024H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map

; 105  :     map() : _Mybase(key_compare()) {}

  00009	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00012	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00026	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 350  :         _Pnode->_Color = _Black;

  00029	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0002f	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map

; 105  :     map() : _Mybase(key_compare()) {}

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??0?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@ABUSItemPos@@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::find, COMDAT
; _this$ = ecx

; 1376 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1367 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00007	8b 75 0c	 mov	 esi, DWORD PTR __Keyval$[ebp]
  0000a	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]

; 1376 :     _NODISCARD iterator find(const key_type& _Keyval) {

  0000d	57		 push	 edi

; 1367 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0000e	56		 push	 esi
  0000f	50		 push	 eax

; 1376 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00010	8b f9		 mov	 edi, ecx

; 1367 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00012	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00017	8b 55 fc	 mov	 edx, DWORD PTR __Loc$1[ebp+8]
  0001a	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0001e	75 20		 jne	 SHORT $LN4@find
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00020	8a 06		 mov	 al, BYTE PTR [esi]
  00022	3a 42 0e	 cmp	 al, BYTE PTR [edx+14]
  00025	72 19		 jb	 SHORT $LN4@find
  00027	75 0a		 jne	 SHORT $LN23@find
  00029	66 8b 46 01	 mov	 ax, WORD PTR [esi+1]
  0002d	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  00031	72 0d		 jb	 SHORT $LN4@find
$LN23@find:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00036	5f		 pop	 edi

; 1377 :         return iterator(_Find(_Keyval), _Get_scary());
; 1378 :     }

  00037	5e		 pop	 esi

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00038	89 10		 mov	 DWORD PTR [eax], edx

; 1377 :         return iterator(_Find(_Keyval), _Get_scary());
; 1378 :     }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN4@find:

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1372 :         return _Get_scary()->_Myhead;

  00043	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00045	5f		 pop	 edi

; 1377 :         return iterator(_Find(_Keyval), _Get_scary());
; 1378 :     }

  00046	5e		 pop	 esi

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00047	89 08		 mov	 DWORD PTR [eax], ecx

; 1377 :         return iterator(_Find(_Keyval), _Get_scary());
; 1378 :     }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::clear, COMDAT
; _this$ = ecx

; 1353 :     void clear() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 1354 :         const auto _Scary = _Get_scary();
; 1355 :         _Scary->_Orphan_ptr(nullptr);
; 1356 :         auto _Head = _Scary->_Myhead;

  00004	8b 37		 mov	 esi, DWORD PTR [edi]

; 1357 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00006	ff 76 04	 push	 DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1358 :         _Head->_Parent  = _Head;

  0000f	89 76 04	 mov	 DWORD PTR [esi+4], esi

; 1359 :         _Head->_Left    = _Head;

  00012	89 36		 mov	 DWORD PTR [esi], esi

; 1360 :         _Head->_Right   = _Head;

  00014	89 76 08	 mov	 DWORD PTR [esi+8], esi

; 1361 :         _Scary->_Mysize = 0;

  00017	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 1362 :     }

  00020	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Off$1$ = -20						; size = 4
__First$1$ = -16					; size = 4
__First$ = -16						; size = 4
__Head$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
tv844 = -4						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::erase, COMDAT
; _this$ = ecx

; 1341 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Eqrange(_Keyval))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 14	 sub	 esp, 20			; 00000014H
  00009	8b c1		 mov	 eax, ecx
  0000b	89 44 24 0c	 mov	 DWORD PTR _this$1$[esp+20], eax
  0000f	53		 push	 ebx

; 1698 :         while (!_Pnode->_Isnil) {

  00010	8b 5d 08	 mov	 ebx, DWORD PTR __Keyval$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]

; 1341 :     size_type erase(const key_type& _Keyval) noexcept(noexcept(_Eqrange(_Keyval))) /* strengthened */ {

  00015	56		 push	 esi
  00016	57		 push	 edi

; 1695 :         _Nodeptr _Lonode  = _Scary->_Myhead; // end() if search fails

  00017	8b f8		 mov	 edi, eax
  00019	89 44 24 14	 mov	 DWORD PTR __Head$1$[esp+32], eax
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1696 :         _Nodeptr _Hinode  = _Scary->_Myhead; // end() if search fails

  00020	8b f0		 mov	 esi, eax
  00022	8b d1		 mov	 edx, ecx
  00024	89 4c 24 1c	 mov	 DWORD PTR tv844[esp+32], ecx

; 1698 :         while (!_Pnode->_Isnil) {

  00028	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0002b	89 7c 24 10	 mov	 DWORD PTR __First$1$[esp+32], edi
  0002f	89 44 24 0c	 mov	 DWORD PTR $T1[esp+32], eax
  00033	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00037	75 5c		 jne	 SHORT $LN162@erase
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00039	8a 1b		 mov	 bl, BYTE PTR [ebx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1698 :         while (!_Pnode->_Isnil) {

  0003b	eb 07		 jmp	 SHORT $LN4@erase
  0003d	0f 1f 00	 npad	 3
$LL169@erase:
  00040	8b 44 24 0c	 mov	 eax, DWORD PTR $T1[esp+32]
$LN4@erase:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00044	8a 4a 0e	 mov	 cl, BYTE PTR [edx+14]
  00047	3a cb		 cmp	 cl, bl
  00049	72 38		 jb	 SHORT $LN166@erase
  0004b	75 15		 jne	 SHORT $LN8@erase
  0004d	8b 7c 24 0c	 mov	 edi, DWORD PTR $T1[esp+32]
  00051	66 8b 42 0f	 mov	 ax, WORD PTR [edx+15]
  00055	66 3b 07	 cmp	 ax, WORD PTR [edi]
  00058	8b 7c 24 10	 mov	 edi, DWORD PTR __First$1$[esp+32]
  0005c	72 25		 jb	 SHORT $LN166@erase
  0005e	8b 44 24 0c	 mov	 eax, DWORD PTR $T1[esp+32]
$LN8@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1703 :                 if (_Hinode->_Isnil && _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey)) {

  00062	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00066	74 11		 je	 SHORT $LN10@erase
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00068	3a d9		 cmp	 bl, cl
  0006a	72 0b		 jb	 SHORT $LN165@erase
  0006c	75 0b		 jne	 SHORT $LN10@erase
  0006e	66 8b 00	 mov	 ax, WORD PTR [eax]
  00071	66 3b 42 0f	 cmp	 ax, WORD PTR [edx+15]
  00075	73 02		 jae	 SHORT $LN10@erase
$LN165@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1704 :                     _Hinode = _Pnode; // _Pnode greater, remember it

  00077	8b f2		 mov	 esi, edx
$LN10@erase:

; 1705 :                 }
; 1706 : 
; 1707 :                 _Lonode = _Pnode;

  00079	8b fa		 mov	 edi, edx

; 1708 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  0007b	8b 12		 mov	 edx, DWORD PTR [edx]
  0007d	89 7c 24 10	 mov	 DWORD PTR __First$1$[esp+32], edi
  00081	eb 03		 jmp	 SHORT $LN9@erase
$LN166@erase:

; 1699 :             const auto& _Nodekey = _Traits::_Kfn(_Pnode->_Myval);
; 1700 :             if (_DEBUG_LT_PRED(_Comp, _Nodekey, _Keyval)) {
; 1701 :                 _Pnode = _Pnode->_Right; // descend right subtree

  00083	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
$LN9@erase:

; 1698 :         while (!_Pnode->_Isnil) {

  00086	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0008a	74 b4		 je	 SHORT $LL169@erase
  0008c	8b 5d 08	 mov	 ebx, DWORD PTR __Keyval$[ebp]
  0008f	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv844[esp+32]
  00093	eb 04		 jmp	 SHORT $LN5@erase
$LN162@erase:
  00095	89 44 24 0c	 mov	 DWORD PTR $T1[esp+32], eax
$LN5@erase:

; 1709 :             }
; 1710 :         }
; 1711 : 
; 1712 :         _Pnode = _Hinode->_Isnil ? _Scary->_Myhead->_Parent : _Hinode->_Left; // continue scan for upper bound

  00099	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0009d	75 02		 jne	 SHORT $LN15@erase
  0009f	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN15@erase:

; 1713 :         while (!_Pnode->_Isnil) {

  000a1	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000a5	75 2c		 jne	 SHORT $LN7@erase
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  000a7	8a 13		 mov	 dl, BYTE PTR [ebx]
  000a9	8b 7c 24 0c	 mov	 edi, DWORD PTR $T1[esp+32]
  000ad	0f 1f 00	 npad	 3
$LL6@erase:
  000b0	3a 51 0e	 cmp	 dl, BYTE PTR [ecx+14]
  000b3	72 10		 jb	 SHORT $LN164@erase
  000b5	75 09		 jne	 SHORT $LN11@erase
  000b7	66 8b 07	 mov	 ax, WORD PTR [edi]
  000ba	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  000be	72 05		 jb	 SHORT $LN164@erase
$LN11@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1719 :                 _Pnode = _Pnode->_Right; // descend right subtree

  000c0	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000c3	eb 04		 jmp	 SHORT $LN12@erase
$LN164@erase:

; 1714 :             if (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Pnode->_Myval))) {
; 1715 :                 // _Pnode greater than _Keyval, remember it
; 1716 :                 _Hinode = _Pnode;

  000c5	8b f1		 mov	 esi, ecx

; 1717 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  000c7	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN12@erase:

; 1713 :         while (!_Pnode->_Isnil) {

  000c9	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000cd	74 e1		 je	 SHORT $LL6@erase
  000cf	8b 7c 24 10	 mov	 edi, DWORD PTR __First$1$[esp+32]
$LN7@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1165 :         auto _UFirst             = _Get_unwrapped(_First);

  000d3	8b c7		 mov	 eax, edi

; 1166 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1167 :         _Iter_diff_t<_InIt> _Off = 0;

  000d5	33 db		 xor	 ebx, ebx
  000d7	89 5c 24 0c	 mov	 DWORD PTR __Off$1$[esp+32], ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  000db	3b c6		 cmp	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1168 :         for (; _UFirst != _ULast; ++_UFirst) {

  000dd	74 46		 je	 SHORT $LN47@erase
  000df	90		 npad	 1
$LL56@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  000e0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1169 :             ++_Off;

  000e3	43		 inc	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  000e4	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000e8	74 1d		 je	 SHORT $LN55@erase

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  000ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ed	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000f1	75 10		 jne	 SHORT $LN54@erase
$LL53@erase:
  000f3	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  000f6	75 0b		 jne	 SHORT $LN54@erase

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

  000f8	8b c1		 mov	 eax, ecx
  000fa	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000fd	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00101	74 f0		 je	 SHORT $LL53@erase
$LN54@erase:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

  00103	8b c1		 mov	 eax, ecx

; 58   :         } else {

  00105	eb 16		 jmp	 SHORT $LN141@erase
$LN55@erase:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00107	8b c1		 mov	 eax, ecx

; 453  :         while (!_Pnode->_Left->_Isnil) {

  00109	8b 10		 mov	 edx, DWORD PTR [eax]
  0010b	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0010f	75 0c		 jne	 SHORT $LN141@erase
$LL59@erase:
  00111	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 454  :             _Pnode = _Pnode->_Left;

  00113	8b c2		 mov	 eax, edx
  00115	8b d1		 mov	 edx, ecx
  00117	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0011b	74 f4		 je	 SHORT $LL59@erase
$LN141@erase:

; 97   :         return _Ptr == _Right._Ptr;

  0011d	3b c6		 cmp	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1168 :         for (; _UFirst != _ULast; ++_UFirst) {

  0011f	75 bf		 jne	 SHORT $LL56@erase
  00121	89 5c 24 0c	 mov	 DWORD PTR __Off$1$[esp+32], ebx
$LN47@erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  00125	8b 44 24 14	 mov	 eax, DWORD PTR __Head$1$[esp+32]

; 1313 :         _Erase_unchecked(_First, _Last);

  00129	89 7c 24 10	 mov	 DWORD PTR __First$[esp+32], edi

; 97   :         return _Ptr == _Right._Ptr;

  0012d	3b 38		 cmp	 edi, DWORD PTR [eax]

; 1295 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  0012f	75 33		 jne	 SHORT $LN138@erase
  00131	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00135	74 2d		 je	 SHORT $LN138@erase

; 1357 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00137	ff 70 04	 push	 DWORD PTR [eax+4]
  0013a	8b 74 24 1c	 mov	 esi, DWORD PTR _this$1$[esp+36]
  0013e	8b ce		 mov	 ecx, esi
  00140	56		 push	 esi
  00141	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1358 :         _Head->_Parent  = _Head;

  00146	8b 44 24 14	 mov	 eax, DWORD PTR __Head$1$[esp+32]
  0014a	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1359 :         _Head->_Left    = _Head;

  0014d	89 00		 mov	 DWORD PTR [eax], eax

; 1360 :         _Head->_Right   = _Head;

  0014f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1361 :         _Scary->_Mysize = 0;

  00152	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN167@erase:

; 1342 :         return _Erase(_Eqrange(_Keyval));
; 1343 :     }

  00159	8b c3		 mov	 eax, ebx
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 04 00	 ret	 4
$LN138@erase:

; 97   :         return _Ptr == _Right._Ptr;

  00164	3b fe		 cmp	 edi, esi

; 1302 :         while (_First != _Last) {

  00166	74 f1		 je	 SHORT $LN167@erase
  00168	8b 5c 24 18	 mov	 ebx, DWORD PTR _this$1$[esp+32]
  0016c	0f 1f 40 00	 npad	 4
$LL63@erase:

; 67   :         ++*this;

  00170	8d 4c 24 10	 lea	 ecx, DWORD PTR __First$[esp+32]
  00174	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 1287 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  00179	57		 push	 edi
  0017a	8b cb		 mov	 ecx, ebx
  0017c	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00181	6a 24		 push	 36			; 00000024H
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  00189	8b 7c 24 18	 mov	 edi, DWORD PTR __First$[esp+40]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0018d	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  00190	3b fe		 cmp	 edi, esi

; 1302 :         while (_First != _Last) {

  00192	75 dc		 jne	 SHORT $LL63@erase

; 1342 :         return _Erase(_Eqrange(_Keyval));
; 1343 :     }

  00194	8b 44 24 0c	 mov	 eax, DWORD PTR __Off$1$[esp+32]
  00198	5f		 pop	 edi
  00199	5e		 pop	 esi
  0019a	5b		 pop	 ebx
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c2 04 00	 ret	 4
?erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAEIABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::size, COMDAT
; _this$ = ecx

; 1193 :         return _Get_scary()->_Mysize;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1194 :     }

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::end, COMDAT
; _this$ = ecx

; 1134 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 1135 :         const auto _Scary = _Get_scary();
; 1136 :         return iterator(_Scary->_Myhead, _Scary);
; 1137 :     }

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::begin, COMDAT
; _this$ = ecx

; 1124 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1125 :         const auto _Scary = _Get_scary();
; 1126 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1127 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::~_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >, COMDAT
; _this$ = ecx

; 1079 :     ~_Tree() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 24		 push	 36			; 00000024H
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1086 :     }

  0001b	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::~_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCPythonShop@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCPythonShop@@@@UAE@XZ PROC		; CSingleton<CPythonShop>::~CSingleton<CPythonShop>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonShop@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, 0 ; CSingleton<CPythonShop>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCPythonShop@@@@UAE@XZ ENDP		; CSingleton<CPythonShop>::~CSingleton<CPythonShop>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ??0?$CSingleton@VCPythonShop@@@@QAE@XZ
_TEXT	SEGMENT
??0?$CSingleton@VCPythonShop@@@@QAE@XZ PROC		; CSingleton<CPythonShop>::CSingleton<CPythonShop>, COMDAT
; _this$ = ecx

; 12   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCPythonShop@@@@6B@

; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 
; 15   : 		ms_singleton = (T*) ((int) this + offset);
; 16   : 	} 

  00006	8b c1		 mov	 eax, ecx
  00008	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, ecx ; CSingleton<CPythonShop>::ms_singleton
  0000e	c3		 ret	 0
??0?$CSingleton@VCPythonShop@@@@QAE@XZ ENDP		; CSingleton<CPythonShop>::CSingleton<CPythonShop>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCPythonShop@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCPythonShop@@@@UAEPAXI@Z PROC		; CSingleton<CPythonShop>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1

; 19   : 	{ 

  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCPythonShop@@@@0PAVCPythonShop@@A, 0 ; CSingleton<CPythonShop>::ms_singleton
  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCPythonShop@@@@6B@
  0001a	74 0b		 je	 SHORT $LN6@scalar
  0001c	6a 04		 push	 4
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CSingleton@VCPythonShop@@@@UAEPAXI@Z ENDP		; CSingleton<CPythonShop>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@SAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@SAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<SItemPos const ,SShopItemTable> *>::pointer_to, COMDAT
; __Val$ = ecx

; 268  :         return _STD addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 269  :     }

  00002	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@SAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<SItemPos const ,SShopItemTable> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength, COMDAT

; 2201 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Tidy@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Tidy, COMDAT
; _this$ = ecx

; 2098 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2099 :         auto& _Al         = _Getal();
; 2100 :         auto& _My_data    = _Mypair._Myval2;
; 2101 :         pointer& _Myfirst = _My_data._Myfirst;
; 2102 :         pointer& _Mylast  = _My_data._Mylast;
; 2103 :         pointer& _Myend   = _My_data._Myend;
; 2104 : 
; 2105 :         _My_data._Orphan_all();
; 2106 : 
; 2107 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 16		 mov	 edx, DWORD PTR [esi]
  00005	85 d2		 test	 edx, edx
  00007	74 4c		 je	 SHORT $LN2@Tidy

; 2108 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2109 :             _ASAN_VECTOR_REMOVE;
; 2110 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c2		 sub	 eax, edx
  0000e	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00014	8b c8		 mov	 ecx, eax
  00016	c1 e1 04	 shl	 ecx, 4
  00019	03 c8		 add	 ecx, eax

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00021	72 14		 jb	 SHORT $LN20@Tidy

; 147  :     _Bytes += _Non_user_size;

  00023	57		 push	 edi

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00024	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  00027	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002a	2b d7		 sub	 edx, edi

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002c	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  0002f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00032	77 23		 ja	 SHORT $LN17@Tidy

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00034	8b d7		 mov	 edx, edi
  00036	5f		 pop	 edi
$LN20@Tidy:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2112 :             _Myfirst = nullptr;

  0003e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00044	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2113 :             _Mylast  = nullptr;

  00047	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2114 :             _Myend   = nullptr;

  0004e	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 2116 :     }

  00055	5e		 pop	 esi
  00056	c3		 ret	 0
$LN17@Tidy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@Tidy:
  0005c	cc		 int	 3
?_Tidy@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?capacity@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::capacity, COMDAT
; _this$ = ecx

; 1941 :         auto& _My_data = _Mypair._Myval2;
; 1942 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135

; 1943 :     }

  0000b	c3		 ret	 0
?capacity@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?max_size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::max_size, COMDAT
; _this$dead$ = ecx

; 1936 :         return (_STD min)(

  00000	b8 0f 0f 0f 0f	 mov	 eax, 252645135		; 0f0f0f0fH

; 1937 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1938 :     }

  00005	c3		 ret	 0
?max_size@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@QBEIXZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Size$1$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXI@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1664 :     _CONSTEXPR20 void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi
  00008	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00009	8b 7d 08	 mov	 edi, DWORD PTR __Newcapacity$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1671 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  0000c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0000f	2b 03		 sub	 eax, DWORD PTR [ebx]
  00011	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
  00017	89 45 fc	 mov	 DWORD PTR __Size$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  0001a	81 ff 0f 0f 0f
	0f		 cmp	 edi, 252645135		; 0f0f0f0fH
  00020	77 51		 ja	 SHORT $LN46@Reallocate

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	8b c7		 mov	 eax, edi
  00024	c1 e0 04	 shl	 eax, 4
  00027	03 c7		 add	 eax, edi

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00029	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0002e	72 0d		 jb	 SHORT $LN16@Reallocate

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00036	83 c4 04	 add	 esp, 4
  00039	8b f0		 mov	 esi, eax
  0003b	eb 13		 jmp	 SHORT $LN14@Reallocate
$LN16@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  0003d	85 c0		 test	 eax, eax
  0003f	74 0d		 je	 SHORT $LN17@Reallocate

; 77   :         return ::operator new(_Bytes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00047	83 c4 04	 add	 esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

  0004a	8b f0		 mov	 esi, eax
  0004c	eb 02		 jmp	 SHORT $LN14@Reallocate
$LN17@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  0004e	33 f6		 xor	 esi, esi
$LN14@Reallocate:

; 1800 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00050	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00053	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00055	56		 push	 esi
  00056	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
  0005b	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 1686 :         _Change_array(_Newvec, _Size, _Newcapacity);

  0005e	8b cb		 mov	 ecx, ebx
  00060	57		 push	 edi
  00061	ff 75 fc	 push	 DWORD PTR __Size$1$[ebp]
  00064	56		 push	 esi
  00065	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx

; 1687 :     }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN46@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00073	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN44@Reallocate:
  00078	cc		 int	 3
?_Reallocate_exactly@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXI@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Reallocate_exactly
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*, COMDAT
; _this$ = ecx

; 186  :         return this->_Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0e	 add	 eax, 14			; 0000000eH

; 275  :         return const_cast<reference>(_Mybase::operator*());
; 276  :     }

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++, COMDAT
; _this$ = ecx

; 193  :     _Tree_const_iterator& operator++() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 194  : #if _ITERATOR_DEBUG_LEVEL == 2
; 195  :         _STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");
; 196  :         _STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");
; 197  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 198  : 
; 199  :         _Mybase::operator++();

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 200  :         return *this;

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 201  :     }

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$dead$ = 12					; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 39   :         this->_Adopt(_Plist);
; 40   :     }

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Orphan_ptr, COMDAT
; _this$dead$ = ecx

; 716  : #if _ITERATOR_DEBUG_LEVEL == 2
; 717  :         _Lockit _Lock(_LOCK_DEBUG);
; 718  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 719  :         while (*_Pnext) {
; 720  :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 721  :             if (_Pnextptr == _Myhead || (_Ptr != nullptr && _Pnextptr != _Ptr)) {
; 722  :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 723  :             } else { // orphan the iterator
; 724  :                 (*_Pnext)->_Myproxy = nullptr;
; 725  :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 726  :             }
; 727  :         }
; 728  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 729  :         (void) _Ptr;
; 730  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 731  :     }

  00000	c2 04 00	 ret	 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 1971 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 1972 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 1967 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00000	8b c1		 mov	 eax, ecx

; 1968 :     }

  00002	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 1959 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1960 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEIU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@2@@Z
_TEXT	SEGMENT
__First$ = -12						; size = 4
_this$1$ = -8						; size = 4
__Off$1$ = -4						; size = 4
__Where$ = 8						; size = 8
?_Erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEIU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1309 :     size_type _Erase(const pair<_Nodeptr, _Nodeptr> _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1167 :         _Iter_diff_t<_InIt> _Off = 0;

  00008	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1309 :     size_type _Erase(const pair<_Nodeptr, _Nodeptr> _Where) noexcept {

  0000b	8b d1		 mov	 edx, ecx
  0000d	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1165 :         auto _UFirst             = _Get_unwrapped(_First);

  0000e	8b 7d 08	 mov	 edi, DWORD PTR __Where$[ebp]

; 1167 :         _Iter_diff_t<_InIt> _Off = 0;

  00011	33 c9		 xor	 ecx, ecx
  00013	8b c7		 mov	 eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1309 :     size_type _Erase(const pair<_Nodeptr, _Nodeptr> _Where) noexcept {

  00015	89 55 f8	 mov	 DWORD PTR _this$1$[ebp], edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1167 :         _Iter_diff_t<_InIt> _Off = 0;

  00018	89 4d fc	 mov	 DWORD PTR __Off$1$[ebp], ecx
  0001b	3b c6		 cmp	 eax, esi

; 1168 :         for (; _UFirst != _ULast; ++_UFirst) {

  0001d	74 4f		 je	 SHORT $LN9@Erase
  0001f	33 ff		 xor	 edi, edi
$LL18@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00021	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1169 :             ++_Off;

  00024	47		 inc	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00025	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00029	74 1d		 je	 SHORT $LN17@Erase

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0002b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00032	75 10		 jne	 SHORT $LN111@Erase
$LL15@Erase:
  00034	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00037	75 0b		 jne	 SHORT $LN111@Erase

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00039	8b c1		 mov	 eax, ecx
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00042	74 f0		 je	 SHORT $LL15@Erase
$LN111@Erase:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

  00044	8b c1		 mov	 eax, ecx

; 58   :         } else {

  00046	eb 16		 jmp	 SHORT $LN22@Erase
$LN17@Erase:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00048	8b c1		 mov	 eax, ecx

; 453  :         while (!_Pnode->_Left->_Isnil) {

  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00050	75 0c		 jne	 SHORT $LN22@Erase
$LL21@Erase:
  00052	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 454  :             _Pnode = _Pnode->_Left;

  00054	8b c2		 mov	 eax, edx
  00056	8b d1		 mov	 edx, ecx
  00058	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0005c	74 f4		 je	 SHORT $LL21@Erase
$LN22@Erase:

; 97   :         return _Ptr == _Right._Ptr;

  0005e	3b c6		 cmp	 eax, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1168 :         for (; _UFirst != _ULast; ++_UFirst) {

  00060	75 bf		 jne	 SHORT $LL18@Erase
  00062	8b 55 f8	 mov	 edx, DWORD PTR _this$1$[ebp]
  00065	89 7d fc	 mov	 DWORD PTR __Off$1$[ebp], edi
  00068	8b 7d 08	 mov	 edi, DWORD PTR __Where$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Off$1$[ebp]
$LN9@Erase:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1145 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  0006e	8b 1a		 mov	 ebx, DWORD PTR [edx]

; 1310 :         const _Unchecked_const_iterator _First(_Where.first, nullptr);
; 1311 :         const _Unchecked_const_iterator _Last(_Where.second, nullptr);
; 1312 :         const auto _Num = static_cast<size_type>(_STD distance(_First, _Last));
; 1313 :         _Erase_unchecked(_First, _Last);

  00070	89 7d f4	 mov	 DWORD PTR __First$[ebp], edi

; 97   :         return _Ptr == _Right._Ptr;

  00073	3b 3b		 cmp	 edi, DWORD PTR [ebx]

; 1295 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  00075	75 2f		 jne	 SHORT $LN97@Erase
  00077	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0007b	74 29		 je	 SHORT $LN97@Erase

; 1357 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  0007d	ff 73 04	 push	 DWORD PTR [ebx+4]
  00080	8b ca		 mov	 ecx, edx
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1314 :         return _Num;

  00088	8b 45 fc	 mov	 eax, DWORD PTR __Off$1$[ebp]

; 1358 :         _Head->_Parent  = _Head;

  0008b	89 5b 04	 mov	 DWORD PTR [ebx+4], ebx

; 1359 :         _Head->_Left    = _Head;

  0008e	89 1b		 mov	 DWORD PTR [ebx], ebx

; 1360 :         _Head->_Right   = _Head;

  00090	89 5b 08	 mov	 DWORD PTR [ebx+8], ebx

; 1361 :         _Scary->_Mysize = 0;

  00093	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00096	5f		 pop	 edi

; 1315 :     }

  00097	5e		 pop	 esi

; 1361 :         _Scary->_Mysize = 0;

  00098	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1315 :     }

  0009f	5b		 pop	 ebx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 08 00	 ret	 8
$LN97@Erase:

; 97   :         return _Ptr == _Right._Ptr;

  000a6	3b fe		 cmp	 edi, esi

; 1302 :         while (_First != _Last) {

  000a8	74 34		 je	 SHORT $LN110@Erase
  000aa	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000ad	0f 1f 00	 npad	 3
$LL25@Erase:

; 67   :         ++*this;

  000b0	8d 4d f4	 lea	 ecx, DWORD PTR __First$[ebp]
  000b3	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 1287 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  000b8	57		 push	 edi
  000b9	8b cb		 mov	 ecx, ebx
  000bb	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  000c0	6a 24		 push	 36			; 00000024H
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  000c8	8b 7d f4	 mov	 edi, DWORD PTR __First$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  000cb	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  000ce	3b fe		 cmp	 edi, esi

; 1302 :         while (_First != _Last) {

  000d0	75 de		 jne	 SHORT $LL25@Erase

; 1315 :     }

  000d2	8b 45 fc	 mov	 eax, DWORD PTR __Off$1$[ebp]
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 08 00	 ret	 8
$LN110@Erase:
  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	8b c1		 mov	 eax, ecx
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
?_Erase@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEIU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@USItemPos@@@1@@Z
_TEXT	SEGMENT
__Parg$dead$ = 8					; size = 4
??0?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@USItemPos@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >, COMDAT
; _this$ = ecx

; 882  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00003	6a 24		 push	 36			; 00000024H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0001a	89 00		 mov	 DWORD PTR [eax], eax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0001c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0001f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 350  :         _Pnode->_Color = _Black;

  00022	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00028	89 06		 mov	 DWORD PTR [esi], eax

; 883  :         _Alloc_sentinel_and_proxy();
; 884  :     }

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@USItemPos@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEABV?$allocator@USShopItemTable@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEABV?$allocator@USShopItemTable@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal, COMDAT
; _this$ = ecx

; 2248 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2249 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEABV?$allocator@USShopItemTable@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAV?$allocator@USShopItemTable@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAV?$allocator@USShopItemTable@@@2@XZ PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal, COMDAT
; _this$ = ecx

; 2244 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 2245 :     }

  00002	c3		 ret	 0
?_Getal@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAV?$allocator@USShopItemTable@@@2@XZ ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array, COMDAT
; _this$ = ecx

; 2076 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2077 :         // orphan all iterators, discard old array, acquire new array
; 2078 :         auto& _Al         = _Getal();
; 2079 :         auto& _My_data    = _Mypair._Myval2;
; 2080 :         pointer& _Myfirst = _My_data._Myfirst;
; 2081 :         pointer& _Mylast  = _My_data._Mylast;
; 2082 :         pointer& _Myend   = _My_data._Myend;
; 2083 : 
; 2084 :         _My_data._Orphan_all();
; 2085 : 
; 2086 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 16		 mov	 edx, DWORD PTR [esi]
  00008	85 d2		 test	 edx, edx
  0000a	74 38		 je	 SHORT $LN8@Change_arr

; 2087 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2088 :             _ASAN_VECTOR_REMOVE;
; 2089 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000f	2b c2		 sub	 eax, edx
  00011	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00017	8b c8		 mov	 ecx, eax
  00019	c1 e1 04	 shl	 ecx, 4
  0001c	03 c8		 add	 ecx, eax

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00024	72 14		 jb	 SHORT $LN20@Change_arr

; 147  :     _Bytes += _Non_user_size;

  00026	57		 push	 edi

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00027	8b 7a fc	 mov	 edi, DWORD PTR [edx-4]
  0002a	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002d	2b d7		 sub	 edx, edi

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002f	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00032	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00035	77 33		 ja	 SHORT $LN17@Change_arr

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00037	8b d7		 mov	 edx, edi
  00039	5f		 pop	 edi
$LN20@Change_arr:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0003a	51		 push	 ecx
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00041	83 c4 08	 add	 esp, 8
$LN8@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2093 :         _Mylast  = _Newvec + _Newsize;

  00044	8b 4d 0c	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00047	8b 55 08	 mov	 edx, DWORD PTR __Newvec$[ebp]
  0004a	c1 e1 04	 shl	 ecx, 4
  0004d	03 ca		 add	 ecx, edx
  0004f	89 16		 mov	 DWORD PTR [esi], edx
  00051	03 4d 0c	 add	 ecx, DWORD PTR __Newsize$[ebp]
  00054	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2094 :         _Myend   = _Newvec + _Newcapacity;

  00057	8b 4d 10	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  0005a	c1 e1 04	 shl	 ecx, 4
  0005d	03 ca		 add	 ecx, edx
  0005f	03 4d 10	 add	 ecx, DWORD PTR __Newcapacity$[ebp]
  00062	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00065	5e		 pop	 esi

; 2096 :     }

  00066	5d		 pop	 ebp
  00067	c2 0c 00	 ret	 12			; 0000000cH
$LN17@Change_arr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN24@Change_arr:
  0006f	cc		 int	 3
?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAIABV?$allocator@USShopItemTable@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAIABV?$allocator@USShopItemTable@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 694  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 0f 0f 0f 0f	 mov	 eax, 252645135		; 0f0f0f0fH

; 695  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAIABV?$allocator@USShopItemTable@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?allocate@?$allocator@USShopItemTable@@@std@@QAEPAUSShopItemTable@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@USShopItemTable@@@std@@QAEPAUSShopItemTable@@I@Z PROC ; std::allocator<SShopItemTable>::allocate, COMDAT
; _this$dead$ = ecx

; 833  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   :         if (_Count > _Max_possible) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	81 f9 0f 0f 0f
	0f		 cmp	 ecx, 252645135		; 0f0f0f0fH
  0000c	77 32		 ja	 SHORT $LN16@allocate

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e0 04	 shl	 eax, 4
  00013	03 c1		 add	 eax, ecx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00015	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0001a	72 0d		 jb	 SHORT $LN9@allocate

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00022	83 c4 04	 add	 esp, 4

; 834  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 835  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 836  :     }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN9@allocate:

; 234  :     if (_Bytes != 0) {

  00029	85 c0		 test	 eax, eax
  0002b	74 0d		 je	 SHORT $LN10@allocate

; 77   :         return ::operator new(_Bytes);

  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4

; 834  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 835  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 836  :     }

  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN10@allocate:

; 238  :     return nullptr;

  0003a	33 c0		 xor	 eax, eax

; 834  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 835  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 836  :     }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN16@allocate:

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00040	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN14@allocate:
  00045	cc		 int	 3
?allocate@?$allocator@USShopItemTable@@@std@@QAEPAUSShopItemTable@@I@Z ENDP ; std::allocator<SShopItemTable>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?deallocate@?$allocator@USShopItemTable@@@std@@QAEXQAUSShopItemTable@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USShopItemTable@@@std@@QAEXQAUSShopItemTable@@I@Z PROC ; std::allocator<SShopItemTable>::deallocate, COMDAT
; _this$dead$ = ecx

; 827  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 828  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 829  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	c1 e1 04	 shl	 ecx, 4
  0000c	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN17@deallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 10		 ja	 SHORT $LN14@deallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN17@deallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8

; 831  :     }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
$LN14@deallocate:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00037	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN20@deallocate:
  0003c	cc		 int	 3
?deallocate@?$allocator@USShopItemTable@@@std@@QAEXQAUSShopItemTable@@I@Z ENDP ; std::allocator<SShopItemTable>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*, COMDAT
; _this$ = ecx

; 180  : #if _ITERATOR_DEBUG_LEVEL == 2
; 181  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 182  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 183  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 184  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 185  : 
; 186  :         return this->_Ptr->_Myval;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0e	 add	 eax, 14			; 0000000eH

; 187  :     }

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 50   :     _Tree_unchecked_const_iterator& operator++() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00004	8b 16		 mov	 edx, DWORD PTR [esi]
  00006	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00009	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  0000d	74 22		 je	 SHORT $LN4@operator

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0000f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00012	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00016	75 12		 jne	 SHORT $LN19@operator
$LL2@operator:
  00018	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0001b	75 0d		 jne	 SHORT $LN19@operator

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b d0		 mov	 edx, eax
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00028	74 ee		 je	 SHORT $LL2@operator
$LN19@operator:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {
; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 60   :         }
; 61   : 
; 62   :         return *this;

  0002a	89 06		 mov	 DWORD PTR [esi], eax

; 63   :     }

  0002c	8b c6		 mov	 eax, esi
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
$LN4@operator:

; 453  :         while (!_Pnode->_Left->_Isnil) {

  00031	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00033	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00037	75 13		 jne	 SHORT $LN9@operator
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@operator:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]

; 454  :             _Pnode = _Pnode->_Left;

  00042	8b f9		 mov	 edi, ecx
  00044	8b c8		 mov	 ecx, eax
  00046	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004a	74 f4		 je	 SHORT $LL8@operator
$LN9@operator:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())
; 58   :         } else {
; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree
; 60   :         }
; 61   : 
; 62   :         return *this;

  0004c	89 3e		 mov	 DWORD PTR [esi], edi

; 63   :     }

  0004e	8b c6		 mov	 eax, esi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1384 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1385 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1937 :     void _Alloc_sentinel_and_proxy() {

  00000	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00001	6a 24		 push	 36			; 00000024H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1937 :     void _Alloc_sentinel_and_proxy() {

  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00005	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000a	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000d	89 00		 mov	 DWORD PTR [eax], eax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000f	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00012	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 350  :         _Pnode->_Color = _Black;

  00015	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1938 :         const auto _Scary = _Get_scary();
; 1939 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1940 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 1941 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0001b	89 06		 mov	 DWORD PTR [esi], eax
  0001d	5e		 pop	 esi

; 1942 :         _Proxy._Release();
; 1943 :     }

  0001e	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked, COMDAT
; _this$ = ecx

; 1293 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _First, _Unchecked_const_iterator _Last) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1294 :         const auto _Begin = _Unchecked_begin();
; 1295 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi

; 97   :         return _Ptr == _Right._Ptr;

  0000a	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 1293 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _First, _Unchecked_const_iterator _Last) noexcept {

  0000d	57		 push	 edi

; 1145 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  0000e	8b 3b		 mov	 edi, DWORD PTR [ebx]

; 97   :         return _Ptr == _Right._Ptr;

  00010	3b 37		 cmp	 esi, DWORD PTR [edi]

; 1294 :         const auto _Begin = _Unchecked_begin();
; 1295 :         if (_First == _Begin && _Last._Ptr->_Isnil) {

  00012	75 28		 jne	 SHORT $LN70@Erase_unch
  00014	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00018	74 22		 je	 SHORT $LN70@Erase_unch

; 1357 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  0001a	ff 77 04	 push	 DWORD PTR [edi+4]
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >

; 1358 :         _Head->_Parent  = _Head;

  00023	89 7f 04	 mov	 DWORD PTR [edi+4], edi

; 1359 :         _Head->_Left    = _Head;

  00026	89 3f		 mov	 DWORD PTR [edi], edi

; 1360 :         _Head->_Right   = _Head;

  00028	89 7f 08	 mov	 DWORD PTR [edi+8], edi

; 1296 :             // erase all
; 1297 :             clear();
; 1298 :             return _Last._Ptr;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	5f		 pop	 edi

; 1303 :             _Erase_unchecked(_First++);
; 1304 :         }
; 1305 : 
; 1306 :         return _Last._Ptr;
; 1307 :     }

  0002f	5e		 pop	 esi

; 1361 :         _Scary->_Mysize = 0;

  00030	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1303 :             _Erase_unchecked(_First++);
; 1304 :         }
; 1305 : 
; 1306 :         return _Last._Ptr;
; 1307 :     }

  00037	5b		 pop	 ebx
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN70@Erase_unch:

; 97   :         return _Ptr == _Right._Ptr;

  0003c	3b f0		 cmp	 esi, eax

; 1299 :         }
; 1300 : 
; 1301 :         // partial erase, one at a time
; 1302 :         while (_First != _Last) {

  0003e	74 25		 je	 SHORT $LN1@Erase_unch
$LL2@Erase_unch:

; 67   :         ++*this;

  00040	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 1287 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  00048	56		 push	 esi
  00049	8b cb		 mov	 ecx, ebx
  0004b	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00050	6a 24		 push	 36			; 00000024H
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  00058	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0005b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  0005e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00061	3b f0		 cmp	 esi, eax

; 1299 :         }
; 1300 : 
; 1301 :         // partial erase, one at a time
; 1302 :         while (_First != _Last) {

  00063	75 db		 jne	 SHORT $LL2@Erase_unch
$LN1@Erase_unch:
  00065	5f		 pop	 edi

; 1303 :             _Erase_unchecked(_First++);
; 1304 :         }
; 1305 : 
; 1306 :         return _Last._Ptr;
; 1307 :     }

  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QBEABV?$allocator@USShopItemTable@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QBEABV?$allocator@USShopItemTable@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1388 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1389 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QBEABV?$allocator@USShopItemTable@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAEAAV?$allocator@USShopItemTable@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAEAAV?$allocator@USShopItemTable@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1384 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1385 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAEAAV?$allocator@USShopItemTable@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator==, COMDAT
; _this$ = ecx

; 96   :     _NODISCARD bool operator==(const _Tree_unchecked_const_iterator& _Right) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 97   :         return _Ptr == _Right._Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000a	0f 94 c0	 sete	 al

; 98   :     }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
??8?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE?AV01@H@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 65   :     _Tree_unchecked_const_iterator operator++(int) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   :         _Tree_unchecked_const_iterator _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 16		 mov	 DWORD PTR [esi], edx

; 67   :         ++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 68   :         return _Tmp;

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 69   :     }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Min, COMDAT
; __Pnode$ = ecx

; 453  :         while (!_Pnode->_Left->_Isnil) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00006	75 0d		 jne	 SHORT $LN9@Min
$LL2@Min:
  00008	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 454  :             _Pnode = _Pnode->_Left;

  0000a	8b c2		 mov	 eax, edx
  0000c	8b d1		 mov	 edx, ecx
  0000e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00012	74 f4		 je	 SHORT $LL2@Min

; 458  :     }

  00014	c3		 ret	 0
$LN9@Min:

; 455  :         }
; 456  : 
; 457  :         return _Pnode;

  00015	8b c1		 mov	 eax, ecx

; 458  :     }

  00017	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Successor$ = -4					; size = 4
__Where$ = 8						; size = 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked, COMDAT
; _this$ = ecx

; 1283 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1284 :         const auto _Scary                    = _Get_scary();
; 1285 :         _Unchecked_const_iterator _Successor = _Where;

  00005	8b 75 08	 mov	 esi, DWORD PTR __Where$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	89 75 fc	 mov	 DWORD PTR __Successor$[ebp], esi

; 1286 :         ++_Successor; // save successor iterator for return

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR __Successor$[ebp]
  00011	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 1287 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  00016	56		 push	 esi
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  0001e	6a 24		 push	 36			; 00000024H
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1290 :         return _Successor._Ptr; // return successor nodeptr

  00026	8b 45 fc	 mov	 eax, DWORD PTR __Successor$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00029	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1290 :         return _Successor._Ptr; // return successor nodeptr

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 1291 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1144 :     _Unchecked_iterator _Unchecked_begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1145 :         return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx

; 1146 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?_Unchecked_begin@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___param0$ = 8						; size = 4
___param1$dead$ = 12					; size = 4
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR ___param0$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
tv1038 = -16						; size = 4
$T1 = -12						; size = 4
tv1091 = -12						; size = 4
tv1075 = -12						; size = 4
tv1042 = -12						; size = 4
__Erasednode$1$ = -8					; size = 4
_this$1$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract, COMDAT
; _this$ = ecx

; 504  :     _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 505  :         _Nodeptr _Erasednode = _Where._Ptr; // node to erase

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	56		 push	 esi
  0000b	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 506  :         ++_Where; // save successor iterator for return

  0000e	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00011	57		 push	 edi
  00012	89 5d f8	 mov	 DWORD PTR __Erasednode$1$[ebp], ebx
  00015	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>::operator++

; 507  : 
; 508  :         _Nodeptr _Fixnode; // the node to recolor as needed
; 509  :         _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
; 510  :         _Nodeptr _Pnode = _Erasednode;
; 511  : 
; 512  :         if (_Pnode->_Left->_Isnil) {

  0001a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0001c	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  0001f	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00023	75 18		 jne	 SHORT $LN86@Extract

; 513  :             _Fixnode = _Pnode->_Right; // stitch up right subtree
; 514  :         } else if (_Pnode->_Right->_Isnil) {

  00025	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00029	74 04		 je	 SHORT $LN7@Extract

; 515  :             _Fixnode = _Pnode->_Left; // stitch up left subtree

  0002b	8b f8		 mov	 edi, eax

; 516  :         } else { // two subtrees, must lift successor node to replace erased

  0002d	eb 0e		 jmp	 SHORT $LN86@Extract
$LN7@Extract:

; 517  :             _Pnode   = _Where._Ptr; // _Pnode is successor node

  0002f	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]

; 518  :             _Fixnode = _Pnode->_Right; // _Fixnode is only subtree

  00032	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00035	3b d3		 cmp	 edx, ebx

; 519  :         }
; 520  : 
; 521  :         if (_Pnode == _Erasednode) { // at most one subtree, relink it

  00037	0f 85 95 00 00
	00		 jne	 $LN9@Extract
$LN86@Extract:

; 522  :             _Fixnodeparent = _Erasednode->_Parent;
; 523  :             if (!_Fixnode->_Isnil) {

  0003d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00041	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00044	75 03		 jne	 SHORT $LN11@Extract

; 524  :                 _Fixnode->_Parent = _Fixnodeparent; // link up

  00046	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN11@Extract:

; 525  :             }
; 526  : 
; 527  :             if (_Myhead->_Parent == _Erasednode) {

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  0004c	8b 02		 mov	 eax, DWORD PTR [edx]
  0004e	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00051	75 05		 jne	 SHORT $LN12@Extract

; 528  :                 _Myhead->_Parent = _Fixnode; // link down from root

  00053	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00056	eb 0b		 jmp	 SHORT $LN15@Extract
$LN12@Extract:

; 529  :             } else if (_Fixnodeparent->_Left == _Erasednode) {

  00058	39 1e		 cmp	 DWORD PTR [esi], ebx
  0005a	75 04		 jne	 SHORT $LN14@Extract

; 530  :                 _Fixnodeparent->_Left = _Fixnode; // link down to left

  0005c	89 3e		 mov	 DWORD PTR [esi], edi

; 531  :             } else {

  0005e	eb 03		 jmp	 SHORT $LN15@Extract
$LN14@Extract:

; 532  :                 _Fixnodeparent->_Right = _Fixnode; // link down to right

  00060	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN15@Extract:

; 533  :             }
; 534  : 
; 535  :             if (_Myhead->_Left == _Erasednode) {

  00063	8b 02		 mov	 eax, DWORD PTR [edx]
  00065	89 45 f4	 mov	 DWORD PTR tv1075[ebp], eax
  00068	39 18		 cmp	 DWORD PTR [eax], ebx
  0006a	75 28		 jne	 SHORT $LN16@Extract

; 536  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  0006c	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00070	74 04		 je	 SHORT $LN42@Extract
  00072	8b d6		 mov	 edx, esi
  00074	eb 19		 jmp	 SHORT $LN64@Extract
$LN42@Extract:

; 453  :         while (!_Pnode->_Left->_Isnil) {

  00076	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 536  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  00078	8b d7		 mov	 edx, edi

; 453  :         while (!_Pnode->_Left->_Isnil) {

  0007a	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0007e	75 0f		 jne	 SHORT $LN64@Extract
$LL63@Extract:
  00080	8b 01		 mov	 eax, DWORD PTR [ecx]

; 454  :             _Pnode = _Pnode->_Left;

  00082	8b d1		 mov	 edx, ecx
  00084	8b c8		 mov	 ecx, eax
  00086	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0008a	74 f4		 je	 SHORT $LL63@Extract
  0008c	8b 45 f4	 mov	 eax, DWORD PTR tv1075[ebp]
$LN64@Extract:

; 536  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  0008f	89 10		 mov	 DWORD PTR [eax], edx
  00091	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
$LN16@Extract:

; 537  :                                                   : _Min(_Fixnode); // smallest in relinked subtree
; 538  :             }
; 539  : 
; 540  :             if (_Myhead->_Right == _Erasednode) {

  00094	8b 02		 mov	 eax, DWORD PTR [edx]
  00096	39 58 08	 cmp	 DWORD PTR [eax+8], ebx
  00099	0f 85 a0 00 00
	00		 jne	 $LN47@Extract

; 541  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  0009f	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000a3	74 0a		 je	 SHORT $LN44@Extract
  000a5	8b ce		 mov	 ecx, esi
  000a7	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 542  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 543  :             }
; 544  :         } else { // erased has two subtrees, _Pnode is successor to erased

  000aa	e9 90 00 00 00	 jmp	 $LN47@Extract
$LN44@Extract:

; 445  :         while (!_Pnode->_Right->_Isnil) {

  000af	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 541  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  000b2	8b cf		 mov	 ecx, edi

; 445  :         while (!_Pnode->_Right->_Isnil) {

  000b4	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000b8	75 11		 jne	 SHORT $LN68@Extract
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL67@Extract:

; 446  :             _Pnode = _Pnode->_Right;

  000c0	8b c8		 mov	 ecx, eax
  000c2	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000c5	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000c9	74 f5		 je	 SHORT $LL67@Extract
$LN68@Extract:
  000cb	8b 02		 mov	 eax, DWORD PTR [edx]

; 541  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  000cd	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 542  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 543  :             }
; 544  :         } else { // erased has two subtrees, _Pnode is successor to erased

  000d0	eb 6d		 jmp	 SHORT $LN47@Extract
$LN9@Extract:

; 545  :             _Erasednode->_Left->_Parent = _Pnode; // link left up

  000d2	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 546  :             _Pnode->_Left               = _Erasednode->_Left; // link successor down
; 547  : 
; 548  :             if (_Pnode == _Erasednode->_Right) {

  000d5	8d 4a 04	 lea	 ecx, DWORD PTR [edx+4]
  000d8	8b 03		 mov	 eax, DWORD PTR [ebx]
  000da	89 02		 mov	 DWORD PTR [edx], eax
  000dc	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
  000df	3b 53 08	 cmp	 edx, DWORD PTR [ebx+8]
  000e2	75 04		 jne	 SHORT $LN18@Extract

; 549  :                 _Fixnodeparent = _Pnode; // successor is next to erased

  000e4	8b f2		 mov	 esi, edx

; 550  :             } else { // successor further down, link in place of erased

  000e6	eb 1c		 jmp	 SHORT $LN19@Extract
$LN18@Extract:

; 551  :                 _Fixnodeparent = _Pnode->_Parent; // parent is successor's
; 552  :                 if (!_Fixnode->_Isnil) {

  000e8	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  000ec	8b 31		 mov	 esi, DWORD PTR [ecx]
  000ee	75 03		 jne	 SHORT $LN20@Extract

; 553  :                     _Fixnode->_Parent = _Fixnodeparent; // link fix up

  000f0	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN20@Extract:

; 554  :                 }
; 555  : 
; 556  :                 _Fixnodeparent->_Left        = _Fixnode; // link fix down

  000f3	89 3e		 mov	 DWORD PTR [esi], edi

; 557  :                 _Pnode->_Right               = _Erasednode->_Right; // link next down

  000f5	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000f8	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 558  :                 _Erasednode->_Right->_Parent = _Pnode; // right up

  000fb	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000fe	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
  00101	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN19@Extract:

; 559  :             }
; 560  : 
; 561  :             if (_Myhead->_Parent == _Erasednode) {

  00104	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00107	8b 00		 mov	 eax, DWORD PTR [eax]
  00109	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  0010c	75 05		 jne	 SHORT $LN21@Extract

; 562  :                 _Myhead->_Parent = _Pnode; // link down from root

  0010e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00111	eb 0e		 jmp	 SHORT $LN94@Extract
$LN21@Extract:

; 563  :             } else if (_Erasednode->_Parent->_Left == _Erasednode) {

  00113	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00116	39 18		 cmp	 DWORD PTR [eax], ebx
  00118	75 04		 jne	 SHORT $LN23@Extract

; 564  :                 _Erasednode->_Parent->_Left = _Pnode; // link down to left

  0011a	89 10		 mov	 DWORD PTR [eax], edx

; 565  :             } else {

  0011c	eb 03		 jmp	 SHORT $LN94@Extract
$LN23@Extract:

; 566  :                 _Erasednode->_Parent->_Right = _Pnode; // link down to right

  0011e	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN94@Extract:

; 567  :             }
; 568  : 
; 569  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

  00121	b9 04 00 00 00	 mov	 ecx, 4
  00126	8b c3		 mov	 eax, ebx
  00128	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  0012b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0012e	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

  00130	8a 4a 0c	 mov	 cl, BYTE PTR [edx+12]

; 101  :     _Left    = _STD move(_Right);

  00133	8a 43 0c	 mov	 al, BYTE PTR [ebx+12]
  00136	88 42 0c	 mov	 BYTE PTR [edx+12], al
  00139	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]

; 102  :     _Right   = _STD move(_Tmp);

  0013c	88 4b 0c	 mov	 BYTE PTR [ebx+12], cl
$LN47@Extract:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 573  :         if (_Erasednode->_Color == _Black) { // erasing black link, must recolor/rebalance tree

  0013f	80 7b 0c 01	 cmp	 BYTE PTR [ebx+12], 1
  00143	0f 85 88 01 00
	00		 jne	 $LN25@Extract

; 574  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

  00149	8b 02		 mov	 eax, DWORD PTR [edx]
  0014b	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  0014e	0f 84 79 01 00
	00		 je	 $LN3@Extract
  00154	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@Extract:
  00160	80 7f 0c 01	 cmp	 BYTE PTR [edi+12], 1
  00164	89 75 f4	 mov	 DWORD PTR tv1091[ebp], esi
  00167	0f 85 5d 01 00
	00		 jne	 $LN93@Extract

; 575  :                 if (_Fixnode == _Fixnodeparent->_Left) { // fixup left subtree

  0016d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0016f	3b f9		 cmp	 edi, ecx
  00171	0f 85 c2 00 00
	00		 jne	 $LN26@Extract

; 576  :                     _Pnode = _Fixnodeparent->_Right;

  00177	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 577  :                     if (_Pnode->_Color == _Red) { // rotate red up from right subtree

  0017a	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0017e	75 57		 jne	 SHORT $LN87@Extract

; 578  :                         _Pnode->_Color         = _Black;

  00180	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00184	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 579  :                         _Fixnodeparent->_Color = _Red;

  00187	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0

; 462  :         _Wherenode->_Right = _Pnode->_Left;

  0018b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

  00190	8b 01		 mov	 eax, DWORD PTR [ecx]
  00192	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00196	75 03		 jne	 SHORT $LN49@Extract

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

  00198	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN49@Extract:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

  0019b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0019e	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  001a1	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

  001a4	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  001a7	8b 00		 mov	 eax, DWORD PTR [eax]
  001a9	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  001ac	75 0c		 jne	 SHORT $LN50@Extract

; 471  :             _Myhead->_Parent = _Pnode;

  001ae	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

  001b1	89 31		 mov	 DWORD PTR [ecx], esi

; 479  :         _Wherenode->_Parent = _Pnode;

  001b3	89 0a		 mov	 DWORD PTR [edx], ecx

; 580  :                         _Lrotate(_Fixnodeparent);
; 581  :                         _Pnode = _Fixnodeparent->_Right;

  001b5	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001b8	eb 20		 jmp	 SHORT $LN80@Extract
$LN50@Extract:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001ba	8b 02		 mov	 eax, DWORD PTR [edx]
  001bc	3b 30		 cmp	 esi, DWORD PTR [eax]
  001be	75 0b		 jne	 SHORT $LN52@Extract

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

  001c0	89 08		 mov	 DWORD PTR [eax], ecx

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

  001c2	89 31		 mov	 DWORD PTR [ecx], esi

; 479  :         _Wherenode->_Parent = _Pnode;

  001c4	89 0a		 mov	 DWORD PTR [edx], ecx

; 580  :                         _Lrotate(_Fixnodeparent);
; 581  :                         _Pnode = _Fixnodeparent->_Right;

  001c6	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001c9	eb 0f		 jmp	 SHORT $LN80@Extract
$LN52@Extract:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

  001cb	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

  001ce	89 31		 mov	 DWORD PTR [ecx], esi

; 479  :         _Wherenode->_Parent = _Pnode;

  001d0	89 0a		 mov	 DWORD PTR [edx], ecx

; 580  :                         _Lrotate(_Fixnodeparent);
; 581  :                         _Pnode = _Fixnodeparent->_Right;

  001d2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  001d5	eb 03		 jmp	 SHORT $LN80@Extract
$LN87@Extract:
  001d7	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
$LN80@Extract:

; 582  :                     }
; 583  : 
; 584  :                     if (_Pnode->_Isnil) {

  001da	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001de	0f 85 d1 00 00
	00		 jne	 $LN2@Extract

; 585  :                         _Fixnode = _Fixnodeparent; // shouldn't happen
; 586  :                     } else if (_Pnode->_Left->_Color == _Black
; 587  :                                && _Pnode->_Right->_Color == _Black) { // redden right subtree with black children

  001e4	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e6	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001ea	75 0d		 jne	 SHORT $LN89@Extract
  001ec	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001ef	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  001f3	0f 84 b8 00 00
	00		 je	 $LN95@Extract
$LN89@Extract:

; 588  :                         _Pnode->_Color = _Red;
; 589  :                         _Fixnode       = _Fixnodeparent;
; 590  :                     } else { // must rearrange right subtree
; 591  :                         if (_Pnode->_Right->_Color == _Black) { // rotate red up from left sub-subtree

  001f9	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001fc	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  00200	75 16		 jne	 SHORT $LN33@Extract

; 592  :                             _Pnode->_Left->_Color = _Black;

  00202	8b 01		 mov	 eax, DWORD PTR [ecx]

; 593  :                             _Pnode->_Color        = _Red;
; 594  :                             _Rrotate(_Pnode);

  00204	51		 push	 ecx
  00205	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00209	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  0020d	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00210	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate

; 595  :                             _Pnode = _Fixnodeparent->_Right;

  00215	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
$LN33@Extract:

; 596  :                         }
; 597  : 
; 598  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  00218	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  0021b	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 599  :                         _Fixnodeparent->_Color = _Black;

  0021e	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 600  :                         _Pnode->_Right->_Color = _Black;

  00222	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 601  :                         _Lrotate(_Fixnodeparent);

  00225	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00228	56		 push	 esi
  00229	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  0022d	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate

; 602  :                         break; // tree now recolored/rebalanced

  00232	8b d1		 mov	 edx, ecx
  00234	e9 91 00 00 00	 jmp	 $LN93@Extract
$LN26@Extract:

; 603  :                     }
; 604  :                 } else { // fixup right subtree
; 605  :                     _Pnode = _Fixnodeparent->_Left;
; 606  :                     if (_Pnode->_Color == _Red) { // rotate red up from left subtree

  00239	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0023d	75 58		 jne	 SHORT $LN88@Extract

; 607  :                         _Pnode->_Color         = _Black;

  0023f	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00243	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 608  :                         _Fixnodeparent->_Color = _Red;

  00245	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0

; 484  :         _Wherenode->_Left = _Pnode->_Right;

  00249	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0024c	89 06		 mov	 DWORD PTR [esi], eax

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

  0024e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00251	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00255	75 03		 jne	 SHORT $LN56@Extract

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

  00257	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN56@Extract:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

  0025a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0025d	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  00260	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

  00263	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  00266	8b 00		 mov	 eax, DWORD PTR [eax]
  00268	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  0026b	75 0c		 jne	 SHORT $LN57@Extract

; 493  :             _Myhead->_Parent = _Pnode;

  0026d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  00270	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 501  :         _Wherenode->_Parent = _Pnode;

  00273	89 0a		 mov	 DWORD PTR [edx], ecx

; 609  :                         _Rrotate(_Fixnodeparent);
; 610  :                         _Pnode = _Fixnodeparent->_Left;

  00275	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00277	eb 21		 jmp	 SHORT $LN79@Extract
$LN57@Extract:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00279	8b 02		 mov	 eax, DWORD PTR [edx]
  0027b	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  0027e	75 0c		 jne	 SHORT $LN59@Extract

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

  00280	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  00283	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 501  :         _Wherenode->_Parent = _Pnode;

  00286	89 0a		 mov	 DWORD PTR [edx], ecx

; 609  :                         _Rrotate(_Fixnodeparent);
; 610  :                         _Pnode = _Fixnodeparent->_Left;

  00288	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0028a	eb 0e		 jmp	 SHORT $LN79@Extract
$LN59@Extract:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

  0028c	89 08		 mov	 DWORD PTR [eax], ecx

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  0028e	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 501  :         _Wherenode->_Parent = _Pnode;

  00291	89 0a		 mov	 DWORD PTR [edx], ecx

; 609  :                         _Rrotate(_Fixnodeparent);
; 610  :                         _Pnode = _Fixnodeparent->_Left;

  00293	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00295	eb 03		 jmp	 SHORT $LN79@Extract
$LN88@Extract:
  00297	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
$LN79@Extract:

; 611  :                     }
; 612  : 
; 613  :                     if (_Pnode->_Isnil) {

  0029a	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0029e	75 15		 jne	 SHORT $LN2@Extract

; 614  :                         _Fixnode = _Fixnodeparent; // shouldn't happen
; 615  :                     } else if (_Pnode->_Right->_Color == _Black
; 616  :                                && _Pnode->_Left->_Color == _Black) { // redden left subtree with black children

  002a0	8b 59 08	 mov	 ebx, DWORD PTR [ecx+8]
  002a3	80 7b 0c 01	 cmp	 BYTE PTR [ebx+12], 1
  002a7	75 3e		 jne	 SHORT $LN90@Extract
  002a9	8b 01		 mov	 eax, DWORD PTR [ecx]
  002ab	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  002af	75 36		 jne	 SHORT $LN90@Extract
$LN95@Extract:

; 574  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

  002b1	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
$LN2@Extract:
  002b5	8b 32		 mov	 esi, DWORD PTR [edx]
  002b7	8b 55 fc	 mov	 edx, DWORD PTR _this$1$[ebp]
  002ba	8b 4d f4	 mov	 ecx, DWORD PTR tv1091[ebp]
  002bd	8b f9		 mov	 edi, ecx
  002bf	8b 02		 mov	 eax, DWORD PTR [edx]
  002c1	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  002c4	0f 85 96 fe ff
	ff		 jne	 $LL4@Extract
$LN93@Extract:

; 631  :                         break; // tree now recolored/rebalanced
; 632  :                     }
; 633  :                 }
; 634  :             }
; 635  : 
; 636  :             _Fixnode->_Color = _Black; // stopping node is black

  002ca	8b 5d f8	 mov	 ebx, DWORD PTR __Erasednode$1$[ebp]
$LN3@Extract:
  002cd	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
$LN25@Extract:

; 637  :         }
; 638  : 
; 639  :         if (0 < _Mysize) {

  002d1	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  002d4	8b c3		 mov	 eax, ebx
  002d6	85 c9		 test	 ecx, ecx
  002d8	74 04		 je	 SHORT $LN40@Extract

; 640  :             --_Mysize;

  002da	49		 dec	 ecx
  002db	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN40@Extract:

; 641  :         }
; 642  : 
; 643  :         return _Erasednode;
; 644  :     }

  002de	5f		 pop	 edi
  002df	5e		 pop	 esi
  002e0	5b		 pop	 ebx
  002e1	8b e5		 mov	 esp, ebp
  002e3	5d		 pop	 ebp
  002e4	c2 04 00	 ret	 4
$LN90@Extract:

; 617  :                         _Pnode->_Color = _Red;
; 618  :                         _Fixnode       = _Fixnodeparent;
; 619  :                     } else { // must rearrange left subtree
; 620  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

  002e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  002e9	80 78 0c 01	 cmp	 BYTE PTR [eax+12], 1
  002ed	75 13		 jne	 SHORT $LN39@Extract

; 621  :                             _Pnode->_Right->_Color = _Black;

  002ef	c6 43 0c 01	 mov	 BYTE PTR [ebx+12], 1

; 622  :                             _Pnode->_Color         = _Red;

  002f3	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 623  :                             _Lrotate(_Pnode);

  002f7	51		 push	 ecx
  002f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  002fb	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate

; 624  :                             _Pnode = _Fixnodeparent->_Left;

  00300	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN39@Extract:

; 625  :                         }
; 626  : 
; 627  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  00302	8a 46 0c	 mov	 al, BYTE PTR [esi+12]
  00305	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 628  :                         _Fixnodeparent->_Color = _Black;

  00308	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1

; 629  :                         _Pnode->_Left->_Color  = _Black;

  0030c	8b 01		 mov	 eax, DWORD PTR [ecx]

; 630  :                         _Rrotate(_Fixnodeparent);

  0030e	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00311	56		 push	 esi
  00312	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
  00316	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate
  0031b	8b d1		 mov	 edx, ecx
  0031d	eb ab		 jmp	 SHORT $LN93@Extract
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate, COMDAT
; _this$ = ecx

; 482  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 32		 mov	 esi, DWORD PTR [edx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	89 02		 mov	 DWORD PTR [edx], eax

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

  0000e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Rrotate

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0e		 jne	 SHORT $LN3@Rrotate

; 493  :             _Myhead->_Parent = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

  0002a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0002d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00030	5e		 pop	 esi
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN3@Rrotate:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00035	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00038	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003b	75 0e		 jne	 SHORT $LN5@Rrotate

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

  0003d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

  00040	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00043	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00046	5e		 pop	 esi
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN5@Rrotate:

; 496  :         } else {
; 497  :             _Wherenode->_Parent->_Left = _Pnode;

  0004b	89 30		 mov	 DWORD PTR [eax], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;
; 501  :         _Wherenode->_Parent = _Pnode;
; 502  :     }

  0004d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00050	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate, COMDAT
; _this$ = ecx

; 460  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	56		 push	 esi
  00007	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

  0000f	8b 06		 mov	 eax, DWORD PTR [esi]
  00011	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  00015	75 03		 jne	 SHORT $LN2@Lrotate

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

  0001a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  00025	75 0d		 jne	 SHORT $LN3@Lrotate

; 471  :             _Myhead->_Parent = _Pnode;

  00027	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

  0002a	89 16		 mov	 DWORD PTR [esi], edx
  0002c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN3@Lrotate:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  00034	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00037	3b 10		 cmp	 edx, DWORD PTR [eax]
  00039	75 0c		 jne	 SHORT $LN5@Lrotate

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

  0003b	89 30		 mov	 DWORD PTR [eax], esi

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

  0003d	89 16		 mov	 DWORD PTR [esi], edx
  0003f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN5@Lrotate:

; 474  :         } else {
; 475  :             _Wherenode->_Parent->_Right = _Pnode;

  00047	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;
; 479  :         _Wherenode->_Parent = _Pnode;
; 480  :     }

  0004a	89 16		 mov	 DWORD PTR [esi], edx
  0004c	89 72 04	 mov	 DWORD PTR [edx+4], esi
  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Max, COMDAT
; __Pnode$ = ecx

; 445  :         while (!_Pnode->_Right->_Isnil) {

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00007	75 13		 jne	 SHORT $LN9@Max
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Max:

; 446  :             _Pnode = _Pnode->_Right;

  00010	8b c2		 mov	 eax, edx
  00012	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00015	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00019	74 f5		 je	 SHORT $LL2@Max

; 450  :     }

  0001b	c3		 ret	 0
$LN9@Max:

; 447  :         }
; 448  : 
; 449  :         return _Pnode;

  0001c	8b c1		 mov	 eax, ecx

; 450  :     }

  0001e	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$make_pair@AAUSItemPos@@AAUSShopItemTable@@@std@@YA?AU?$pair@USItemPos@@USShopItemTable@@@0@AAUSItemPos@@AAUSShopItemTable@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@AAUSItemPos@@AAUSShopItemTable@@@std@@YA?AU?$pair@USItemPos@@USShopItemTable@@@0@AAUSItemPos@@AAUSShopItemTable@@@Z PROC ; std::make_pair<SItemPos &,SShopItemTable &>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val1$ = edx

; 443  :         is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00003	66 8b 02	 mov	 ax, WORD PTR [edx]
  00006	66 89 01	 mov	 WORD PTR [ecx], ax
  00009	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0000d	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00010	8b 45 08	 mov	 eax, DWORD PTR __Val2$[ebp]
  00013	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00016	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0001a	0f 11 41 03	 movups	 XMMWORD PTR [ecx+3], xmm0
  0001e	88 41 13	 mov	 BYTE PTR [ecx+19], al

; 444  :     // return pair composed from arguments
; 445  :     using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 446  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

  00021	8b c1		 mov	 eax, ecx

; 447  : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$make_pair@AAUSItemPos@@AAUSShopItemTable@@@std@@YA?AU?$pair@USItemPos@@USShopItemTable@@@0@AAUSItemPos@@AAUSShopItemTable@@@Z ENDP ; std::make_pair<SItemPos &,SShopItemTable &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map
;	COMDAT ??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Loc$3 = -44						; size = 12
$T4 = -32						; size = 12
$T5 = -28						; size = 8
_this$1$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::insert<std::pair<SItemPos,SShopItemTable>,0>, COMDAT
; _this$ = ecx

; 184  :     pair<iterator, bool> insert(_Valty&& _Val) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 ec 20	 sub	 esp, 32			; 00000020H
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b f1		 mov	 esi, ecx
  0003d	89 75 ec	 mov	 DWORD PTR _this$1$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  00040	8b 7b 0c	 mov	 edi, DWORD PTR __Val$[ebx]
  00043	8d 45 e0	 lea	 eax, DWORD PTR $T4[ebp]
  00046	57		 push	 edi
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
  0004d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00050	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00054	66 0f d6 45 d4	 movq	 QWORD PTR __Loc$3[ebp], xmm0

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00059	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0005d	75 17		 jne	 SHORT $LN6@insert
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0005f	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  00062	38 17		 cmp	 BYTE PTR [edi], dl
  00064	72 10		 jb	 SHORT $LN6@insert
  00066	75 0a		 jne	 SHORT $LN111@insert
  00068	66 8b 47 01	 mov	 ax, WORD PTR [edi+1]
  0006c	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  00070	72 04		 jb	 SHORT $LN6@insert
$LN111@insert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00072	32 d2		 xor	 dl, dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1003 :                 return {_Loc._Bound, false};

  00074	eb 67		 jmp	 SHORT $LN99@insert
$LN6@insert:

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

  00076	81 7e 04 c7 71
	1c 07		 cmp	 DWORD PTR [esi+4], 119304647 ; 071c71c7H
  0007d	74 7c		 je	 SHORT $LN116@insert
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1007 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00082	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00084	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  0008e	6a 24		 push	 36			; 00000024H

; 1012 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+4], 0

; 77   :         return ::operator new(_Bytes);

  00097	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0009c	66 8b 0f	 mov	 cx, WORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 235  :         return _Traits::_Allocate(_Bytes);

  0009f	8b d0		 mov	 edx, eax

; 77   :         return ::operator new(_Bytes);

  000a1	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000a4	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  000a8	8a 4f 02	 mov	 cl, BYTE PTR [edi+2]
  000ab	88 4a 10	 mov	 BYTE PTR [edx+16], cl
  000ae	0f 10 47 03	 movups	 xmm0, XMMWORD PTR [edi+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000b5	52		 push	 edx
  000b6	ff 75 d8	 push	 DWORD PTR __Loc$3[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000b9	0f 11 42 11	 movups	 XMMWORD PTR [edx+17], xmm0
  000bd	8a 47 13	 mov	 al, BYTE PTR [edi+19]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000c0	ff 75 d4	 push	 DWORD PTR __Loc$3[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000c3	88 42 21	 mov	 BYTE PTR [edx+33], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000c6	89 32		 mov	 DWORD PTR [edx], esi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000c8	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000cb	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 811  :         this->_Ptr->_Color = _Red;

  000ce	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000d4	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  000d9	8b c8		 mov	 ecx, eax
  000db	b2 01		 mov	 dl, 1
$LN99@insert:
  000dd	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]
  000e0	89 08		 mov	 DWORD PTR [eax], ecx
  000e2	88 50 04	 mov	 BYTE PTR [eax+4], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map

; 186  :     }

  000e5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ef	59		 pop	 ecx
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	8b e3		 mov	 esp, ebx
  000f7	5b		 pop	 ebx
  000f8	c2 08 00	 ret	 8
$LN116@insert:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1630 :             _Throw_tree_length_error();

  000fb	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN114@insert:
  00100	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$insert@U?$pair@USItemPos@@USShopItemTable@@@std@@$0A@@?$map@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::map<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> > >::insert<std::pair<SItemPos,SShopItemTable>,0>
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Eqrange@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@1@ABUSItemPos@@@Z
_TEXT	SEGMENT
__Lonode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Eqrange@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@1@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Eqrange<SItemPos>, COMDAT
; _this$ = ecx

; 1690 :         noexcept(_Nothrow_compare<key_compare, key_type, _Other>&& _Nothrow_compare<key_compare, _Other, key_type>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1691 :         // find range of nodes equivalent to _Keyval
; 1692 :         const auto _Scary = _Get_scary();
; 1693 :         const auto& _Comp = _Getcomp();
; 1694 :         _Nodeptr _Pnode   = _Scary->_Myhead->_Parent;

  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR __Lonode$1$[ebp], ecx

; 1695 :         _Nodeptr _Lonode  = _Scary->_Myhead; // end() if search fails
; 1696 :         _Nodeptr _Hinode  = _Scary->_Myhead; // end() if search fails

  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00010	8b d0		 mov	 edx, eax

; 1697 : 
; 1698 :         while (!_Pnode->_Isnil) {

  00012	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00015	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00019	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0001c	75 40		 jne	 SHORT $LN51@Eqrange
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0001e	53		 push	 ebx
  0001f	8a 39		 mov	 bh, BYTE PTR [ecx]
$LL2@Eqrange:
  00021	8a 5a 0e	 mov	 bl, BYTE PTR [edx+14]
  00024	3a df		 cmp	 bl, bh
  00026	72 29		 jb	 SHORT $LN55@Eqrange
  00028	75 09		 jne	 SHORT $LN6@Eqrange
  0002a	66 8b 4a 0f	 mov	 cx, WORD PTR [edx+15]
  0002e	66 3b 0f	 cmp	 cx, WORD PTR [edi]
  00031	72 1e		 jb	 SHORT $LN55@Eqrange
$LN6@Eqrange:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1703 :                 if (_Hinode->_Isnil && _DEBUG_LT_PRED(_Comp, _Keyval, _Nodekey)) {

  00033	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00037	74 11		 je	 SHORT $LN8@Eqrange
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00039	3a fb		 cmp	 bh, bl
  0003b	72 0b		 jb	 SHORT $LN54@Eqrange
  0003d	75 0b		 jne	 SHORT $LN8@Eqrange
  0003f	66 8b 0f	 mov	 cx, WORD PTR [edi]
  00042	66 3b 4a 0f	 cmp	 cx, WORD PTR [edx+15]
  00046	73 02		 jae	 SHORT $LN8@Eqrange
$LN54@Eqrange:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1704 :                     _Hinode = _Pnode; // _Pnode greater, remember it

  00048	8b f2		 mov	 esi, edx
$LN8@Eqrange:

; 1705 :                 }
; 1706 : 
; 1707 :                 _Lonode = _Pnode;

  0004a	89 55 fc	 mov	 DWORD PTR __Lonode$1$[ebp], edx

; 1708 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  0004d	8b 12		 mov	 edx, DWORD PTR [edx]
  0004f	eb 03		 jmp	 SHORT $LN7@Eqrange
$LN55@Eqrange:

; 1699 :             const auto& _Nodekey = _Traits::_Kfn(_Pnode->_Myval);
; 1700 :             if (_DEBUG_LT_PRED(_Comp, _Nodekey, _Keyval)) {
; 1701 :                 _Pnode = _Pnode->_Right; // descend right subtree

  00051	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
$LN7@Eqrange:

; 1697 : 
; 1698 :         while (!_Pnode->_Isnil) {

  00054	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00058	74 c7		 je	 SHORT $LL2@Eqrange
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  0005d	5b		 pop	 ebx
$LN51@Eqrange:

; 1709 :             }
; 1710 :         }
; 1711 : 
; 1712 :         _Pnode = _Hinode->_Isnil ? _Scary->_Myhead->_Parent : _Hinode->_Left; // continue scan for upper bound

  0005e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00062	75 02		 jne	 SHORT $LN13@Eqrange
  00064	8b 06		 mov	 eax, DWORD PTR [esi]
$LN13@Eqrange:

; 1713 :         while (!_Pnode->_Isnil) {

  00066	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0006a	75 23		 jne	 SHORT $LN5@Eqrange
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0006c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0006e	66 90		 npad	 2
$LL4@Eqrange:
  00070	3a 50 0e	 cmp	 dl, BYTE PTR [eax+14]
  00073	72 10		 jb	 SHORT $LN53@Eqrange
  00075	75 09		 jne	 SHORT $LN9@Eqrange
  00077	66 8b 0f	 mov	 cx, WORD PTR [edi]
  0007a	66 3b 48 0f	 cmp	 cx, WORD PTR [eax+15]
  0007e	72 05		 jb	 SHORT $LN53@Eqrange
$LN9@Eqrange:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1719 :                 _Pnode = _Pnode->_Right; // descend right subtree

  00080	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00083	eb 04		 jmp	 SHORT $LN10@Eqrange
$LN53@Eqrange:

; 1714 :             if (_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Pnode->_Myval))) {
; 1715 :                 // _Pnode greater than _Keyval, remember it
; 1716 :                 _Hinode = _Pnode;

  00085	8b f0		 mov	 esi, eax

; 1717 :                 _Pnode  = _Pnode->_Left; // descend left subtree

  00087	8b 00		 mov	 eax, DWORD PTR [eax]
$LN10@Eqrange:

; 1713 :         while (!_Pnode->_Isnil) {

  00089	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0008d	74 e1		 je	 SHORT $LL4@Eqrange
$LN5@Eqrange:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0008f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00092	8b 4d fc	 mov	 ecx, DWORD PTR __Lonode$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1723 :         return {_Lonode, _Hinode};

  00095	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00096	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00099	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1723 :         return {_Lonode, _Hinode};

  0009b	5e		 pop	 esi

; 1724 :     }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8
??$_Eqrange@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@1@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Eqrange<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@UItemStockSortFunc@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@UItemStockSortFunc@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0UItemStockSortFunc@@@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,ItemStockSortFunc>, COMDAT

; 7665 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { // order [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7666 :     _Adl_verify_range(_First, _Last);
; 7667 :     const auto _UFirst = _Get_unwrapped(_First);
; 7668 :     const auto _ULast  = _Get_unwrapped(_Last);
; 7669 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00006	8b c2		 mov	 eax, edx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	2b c1		 sub	 eax, ecx
  0000d	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00010	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>
  0001c	83 c4 08	 add	 esp, 8

; 7670 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@UItemStockSortFunc@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0UItemStockSortFunc@@@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > const &>, COMDAT
; __It$ = ecx

; 912  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 913  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 914  :         return _It + 0;
; 915  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 916  :         return static_cast<_Iter&&>(_It)._Unwrapped();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 917  :     } else {
; 918  :         return static_cast<_Iter&&>(_It);
; 919  :     }
; 920  : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@@std@@YA?A_TABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEPAUSShopItemTable@@XZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEPAUSShopItemTable@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 334  :         return _Unfancy(this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 335  :     }

  00002	c3		 ret	 0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@QBEPAUSShopItemTable@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<SShopItemTable> > >, COMDAT
; __Val$ = ecx

; 281  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 282  : }

  00002	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??$_Emplace_one_at_back@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_one_at_back@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_one_at_back<SShopItemTable const &>, COMDAT
; _this$ = ecx

; 839  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 840  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 841  :         auto& _My_data   = _Mypair._Myval2;
; 842  :         pointer& _Mylast = _My_data._Mylast;
; 843  : 
; 844  :         if (_Mylast != _My_data._Myend) {

  00005	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00008	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0000b	74 1c		 je	 SHORT $LN2@Emplace_on
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00010	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00013	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00016	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00019	88 41 10	 mov	 BYTE PTR [ecx+16], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 868  :         _Ty& _Result = *_Mylast;

  0001c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 869  :         ++_Mylast;

  0001f	8d 48 11	 lea	 ecx, DWORD PTR [eax+17]
  00022	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 849  :     }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN2@Emplace_on:

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00029	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  0002c	51		 push	 ecx
  0002d	8b ca		 mov	 ecx, edx
  0002f	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>

; 849  :     }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??$_Emplace_one_at_back@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_one_at_back<SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1376 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1376 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@USShopItemTable@@@std@@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1>::_Compressed_pair<std::allocator<SShopItemTable>,std::_Vector_val<std::_Simple_types<SShopItemTable> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Find@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z
_TEXT	SEGMENT
__Loc$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??$_Find@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find<SItemPos>, COMDAT
; _this$ = ecx

; 1366 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1367 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00007	8b 75 08	 mov	 esi, DWORD PTR __Keyval$[ebp]
  0000a	8d 45 f4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000d	57		 push	 edi
  0000e	56		 push	 esi
  0000f	50		 push	 eax
  00010	8b f9		 mov	 edi, ecx
  00012	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00017	8b 45 fc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001a	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001e	75 13		 jne	 SHORT $LN2@Find
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00020	8a 0e		 mov	 cl, BYTE PTR [esi]
  00022	3a 48 0e	 cmp	 cl, BYTE PTR [eax+14]
  00025	72 0c		 jb	 SHORT $LN2@Find
  00027	75 0c		 jne	 SHORT $LN1@Find
  00029	66 8b 4e 01	 mov	 cx, WORD PTR [esi+1]
  0002d	66 3b 48 0f	 cmp	 cx, WORD PTR [eax+15]
  00031	73 02		 jae	 SHORT $LN1@Find
$LN2@Find:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1372 :         return _Get_scary()->_Myhead;

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
$LN1@Find:
  00035	5f		 pop	 edi

; 1373 :     }

  00036	5e		 pop	 esi
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??$_Find@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 744  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0000e	75 25		 jne	 SHORT $LN3@Erase_tree
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR __Al$[ebp]
$LL2@Erase_tree:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	ff 76 08	 push	 DWORD PTR [esi+8]
  00017	8b cb		 mov	 ecx, ebx
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 653  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0001f	8b c6		 mov	 eax, esi

; 654  :     _Val         = static_cast<_Other&&>(_New_val);

  00021	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00023	6a 24		 push	 36			; 00000024H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0002e	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00032	74 e0		 je	 SHORT $LL2@Erase_tree
  00034	5f		 pop	 edi
$LN3@Erase_tree:
  00035	5e		 pop	 esi

; 747  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 748  :         }
; 749  :     }

  00036	5b		 pop	 ebx
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 752  :     void _Erase_head(_Alnode& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 753  :         this->_Orphan_all();
; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	ff 70 04	 push	 DWORD PTR [eax+4]
  0000b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00013	6a 24		 push	 36			; 00000024H
  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
  0001f	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 756  :     }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@AAU10@@Z PROC ; std::addressof<std::pair<SItemPos const ,SShopItemTable> >, COMDAT
; __Val$ = ecx

; 281  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 282  : }

  00002	c3		 ret	 0
??$addressof@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<SItemPos const ,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USShopItemTable@@@std@@@std@@YAXPAUSShopItemTable@@QAU1@AAV?$allocator@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@USShopItemTable@@@std@@@std@@YAXPAUSShopItemTable@@QAU1@AAV?$allocator@USShopItemTable@@@0@@Z PROC ; std::_Destroy_range<std::allocator<SShopItemTable> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 944  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 945  :     using _Ty = typename _Alloc::value_type;
; 946  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 947  :         for (; _First != _Last; ++_First) {
; 948  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 949  :         }
; 950  :     }
; 951  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@USShopItemTable@@@std@@@std@@YAXPAUSShopItemTable@@QAU1@AAV?$allocator@USShopItemTable@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUSShopItemTable@@@std@@YA?A_TABQAUSShopItemTable@@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@ABQAUSShopItemTable@@@std@@YA?A_TABQAUSShopItemTable@@@Z PROC ; std::_Get_unwrapped<SShopItemTable * const &>, COMDAT
; __It$ = ecx

; 912  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 913  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 914  :         return _It + 0;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 915  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 916  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 917  :     } else {
; 918  :         return static_cast<_Iter&&>(_It);
; 919  :     }
; 920  : }

  00002	c3		 ret	 0
??$_Get_unwrapped@ABQAUSShopItemTable@@@std@@YA?A_TABQAUSShopItemTable@@@Z ENDP ; std::_Get_unwrapped<SShopItemTable * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@QAU1@0PAU1@AAV?$allocator@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAUSShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@QAU1@0PAU1@AAV?$allocator@USShopItemTable@@@0@@Z PROC ; std::_Uninitialized_move<SShopItemTable *,std::allocator<SShopItemTable> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1788 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1789 :     // move [_First, _Last) to raw _Dest, using _Al
; 1790 :     // note: only called internally from elsewhere in the STL
; 1791 :     using _Ptrval     = typename _Alloc::value_type*;
; 1792 :     auto _UFirst      = _Get_unwrapped(_First);
; 1793 :     const auto _ULast = _Get_unwrapped(_Last);
; 1794 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1795 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1796 : #if _HAS_CXX20
; 1797 :         if (!_STD is_constant_evaluated())
; 1798 : #endif // _HAS_CXX20
; 1799 :         {
; 1800 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00005	ff 75 08	 push	 DWORD PTR __Dest$[ebp]
  00008	8b fa		 mov	 edi, edx
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>

; 1801 :             return _Dest + (_ULast - _UFirst);

  00011	2b fe		 sub	 edi, esi
  00013	b8 79 78 78 78	 mov	 eax, 2021161081		; 78787879H
  00018	f7 ef		 imul	 edi
  0001a	83 c4 04	 add	 esp, 4
  0001d	c1 fa 03	 sar	 edx, 3
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00025	03 ca		 add	 ecx, edx
  00027	8b c1		 mov	 eax, ecx
  00029	c1 e0 04	 shl	 eax, 4
  0002c	03 45 08	 add	 eax, DWORD PTR __Dest$[ebp]
  0002f	5f		 pop	 edi
  00030	03 c1		 add	 eax, ecx
  00032	5e		 pop	 esi

; 1802 :         }
; 1803 :     }
; 1804 : 
; 1805 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1806 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1807 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1808 :     }
; 1809 : 
; 1810 :     return _Backout._Release();
; 1811 : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Uninitialized_move@PAUSShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@YAPAUSShopItemTable@@QAU1@0PAU1@AAV?$allocator@USShopItemTable@@@0@@Z ENDP ; std::_Uninitialized_move<SShopItemTable *,std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > const >, COMDAT
; __Val$ = ecx

; 281  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 282  : }

  00002	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >, COMDAT
; __Val$ = ecx

; 281  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 282  : }

  00002	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >, COMDAT

; 1160 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1161 :     if constexpr (_Is_ranges_random_iter_v<_InIt>) {
; 1162 :         return _Last - _First; // assume the iterator will do debug checking
; 1163 :     } else {
; 1164 :         _Adl_verify_range(_First, _Last);
; 1165 :         auto _UFirst             = _Get_unwrapped(_First);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1160 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00009	57		 push	 edi

; 1166 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1167 :         _Iter_diff_t<_InIt> _Off = 0;

  0000a	33 ff		 xor	 edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 97   :         return _Ptr == _Right._Ptr;

  0000c	3b c1		 cmp	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1168 :         for (; _UFirst != _ULast; ++_UFirst) {

  0000e	74 43		 je	 SHORT $LN30@distance
  00010	56		 push	 esi
$LL12@distance:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00011	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1169 :             ++_Off;

  00014	47		 inc	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 51   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00015	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00019	74 1d		 je	 SHORT $LN11@distance

; 52   :             _Nodeptr _Pnode;
; 53   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0001b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001e	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00022	75 10		 jne	 SHORT $LN31@distance
$LL9@distance:
  00024	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00027	75 0b		 jne	 SHORT $LN31@distance

; 54   :                 _Ptr = _Pnode; // ==> parent while right subtree

  00029	8b c2		 mov	 eax, edx
  0002b	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0002e	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  00032	74 f0		 je	 SHORT $LL9@distance
$LN31@distance:

; 55   :             }
; 56   : 
; 57   :             _Ptr = _Pnode; // ==> parent (head if end())

  00034	8b c2		 mov	 eax, edx

; 58   :         } else {

  00036	eb 16		 jmp	 SHORT $LN16@distance
$LN11@distance:

; 59   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00038	8b c2		 mov	 eax, edx

; 453  :         while (!_Pnode->_Left->_Isnil) {

  0003a	8b 30		 mov	 esi, DWORD PTR [eax]
  0003c	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00040	75 0c		 jne	 SHORT $LN16@distance
$LL15@distance:
  00042	8b 16		 mov	 edx, DWORD PTR [esi]

; 454  :             _Pnode = _Pnode->_Left;

  00044	8b c6		 mov	 eax, esi
  00046	8b f2		 mov	 esi, edx
  00048	80 7a 0d 00	 cmp	 BYTE PTR [edx+13], 0
  0004c	74 f4		 je	 SHORT $LL15@distance
$LN16@distance:

; 97   :         return _Ptr == _Right._Ptr;

  0004e	3b c1		 cmp	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 1168 :         for (; _UFirst != _ULast; ++_UFirst) {

  00050	75 bf		 jne	 SHORT $LL12@distance

; 1170 :         }
; 1171 : 
; 1172 :         return _Off;

  00052	5e		 pop	 esi
$LN30@distance:

; 1173 :     }
; 1174 : }

  00053	8b c7		 mov	 eax, edi
  00055	5f		 pop	 edi
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$distance@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAHV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::distance<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@AAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z PROC ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> &>, COMDAT
; __It$ = ecx

; 912  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 913  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 914  :         return _It + 0;
; 915  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 916  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 917  :     } else {
; 918  :         return static_cast<_Iter&&>(_It);

  00000	8b c1		 mov	 eax, ecx

; 919  :     }
; 920  : }

  00002	c3		 ret	 0
??$_Get_unwrapped@AAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA?A_TAAV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@@Z ENDP ; std::_Get_unwrapped<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$?0ABU?$less@USItemPos@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@USItemPos@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
_<_Val2_0>$dead$ = 16					; size = 4
??$?0ABU?$less@USItemPos@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@USItemPos@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1><std::less<SItemPos> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1381 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1381 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABU?$less@USItemPos@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@USItemPos@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1><std::less<SItemPos> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BB@@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$0BB@@std@@YAII@Z PROC		; std::_Get_size_of_n<17>, COMDAT
; __Count$ = ecx

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {

  00000	81 f9 0f 0f 0f
	0f		 cmp	 ecx, 252645135		; 0f0f0f0fH
  00006	0f 87 00 00 00
	00		 ja	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0000c	8b c1		 mov	 eax, ecx
  0000e	c1 e0 04	 shl	 eax, 4
  00011	03 c1		 add	 eax, ecx

; 66   : }

  00013	c3		 ret	 0
??$_Get_size_of_n@$0BB@@std@@YAII@Z ENDP		; std::_Get_size_of_n<17>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; __Al$dead$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00000	6a 24		 push	 36			; 00000024H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0000a	89 00		 mov	 DWORD PTR [eax], eax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  0000c	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0000f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 350  :         _Pnode->_Color = _Black;

  00012	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 351  :         _Pnode->_Isnil = true;
; 352  :         return _Pnode;
; 353  :     }

  00018	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00000	6a 24		 push	 36			; 00000024H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 384  :     }

  0000b	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEPAUSShopItemTable@@XZ
_TEXT	SEGMENT
?_Release@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEPAUSShopItemTable@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Release, COMDAT
; _this$ = ecx

; 1668 :         _First = _Last;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	89 01		 mov	 DWORD PTR [ecx], eax

; 1669 :         return _Last;
; 1670 :     }

  00005	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEPAUSShopItemTable@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::~_Uninitialized_backout_al<std::allocator<SShopItemTable> >, COMDAT
; _this$ = ecx

; 1658 :         _Destroy_range(_First, _Last, _Al);
; 1659 :     }

  00000	c2 00 00	 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::~_Uninitialized_backout_al<std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@PAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@PAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Uninitialized_backout_al<std::allocator<SShopItemTable> >, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Al_$[ebp]
  0000e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00011	8b c1		 mov	 eax, ecx
  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAE@PAUSShopItemTable@@AAV?$allocator@USShopItemTable@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Uninitialized_backout_al<std::allocator<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<SShopItemTable> >::_Vector_val<std::_Simple_types<SShopItemTable> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<SShopItemTable> >::_Vector_val<std::_Simple_types<SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??0?$allocator@USShopItemTable@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@USShopItemTable@@@std@@QAE@XZ PROC	; std::allocator<SShopItemTable>::allocator<SShopItemTable>, COMDAT
; _this$ = ecx

; 819  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@USShopItemTable@@@std@@QAE@XZ ENDP	; std::allocator<SShopItemTable>::allocator<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
;	COMDAT ??R?$less@USItemPos@@@std@@QBE_NABUSItemPos@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@USItemPos@@@std@@QBE_NABUSItemPos@@0@Z PROC	; std::less<SItemPos>::operator(), COMDAT
; _this$dead$ = ecx

; 142  :         noexcept(noexcept(_Fake_copy_init<bool>(_Left < _Right))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef

; 142  :         noexcept(noexcept(_Fake_copy_init<bool>(_Left < _Right))) /* strengthened */ {

  00009	53		 push	 ebx
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0000a	8a 10		 mov	 dl, BYTE PTR [eax]
  0000c	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0000e	72 13		 jb	 SHORT $LN6@operator
  00010	75 0a		 jne	 SHORT $LN5@operator
  00012	66 8b 40 01	 mov	 ax, WORD PTR [eax+1]
  00016	66 3b 41 01	 cmp	 ax, WORD PTR [ecx+1]
  0001a	72 07		 jb	 SHORT $LN6@operator
$LN5@operator:
  0001c	32 c0		 xor	 al, al
  0001e	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef

; 144  :     }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
$LN6@operator:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00023	b0 01		 mov	 al, 1
  00025	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef

; 144  :     }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??R?$less@USItemPos@@@std@@QBE_NABUSItemPos@@0@Z ENDP	; std::less<SItemPos>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABU?$less@USItemPos@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABU?$less@USItemPos@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 1955 :         return _Mypair._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1956 :     }

  00002	c3		 ret	 0
?_Getcomp@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABU?$less@USItemPos@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocate, COMDAT
; _this$dead$ = ecx

; 77   :         return ::operator new(_Bytes);

  00000	6a 24		 push	 36			; 00000024H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 834  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 835  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 836  :     }

  0000a	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@USItemPos@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@USItemPos@@@2@XZ PROC ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1388 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1389 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@USItemPos@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@USItemPos@@@2@XZ ENDP ; std::_Compressed_pair<std::less<SItemPos>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1><>, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1376 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00006	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1376 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@AAUSItemPos@@@std@@YAAAUSItemPos@@AAU1@@Z
_TEXT	SEGMENT
??$forward@AAUSItemPos@@@std@@YAAAUSItemPos@@AAU1@@Z PROC ; std::forward<SItemPos &>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@AAUSItemPos@@@std@@YAAAUSItemPos@@AAU1@@Z ENDP ; std::forward<SItemPos &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@AAUSShopItemTable@@@std@@YAAAUSShopItemTable@@AAU1@@Z
_TEXT	SEGMENT
??$forward@AAUSShopItemTable@@@std@@YAAAUSShopItemTable@@AAU1@@Z PROC ; std::forward<SShopItemTable &>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@AAUSShopItemTable@@@std@@YAAAUSShopItemTable@@AAU1@@Z ENDP ; std::forward<SShopItemTable &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$?0AAUSItemPos@@AAUSShopItemTable@@$0A@@?$pair@USItemPos@@USShopItemTable@@@std@@QAE@AAUSItemPos@@AAUSShopItemTable@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAUSItemPos@@AAUSShopItemTable@@$0A@@?$pair@USItemPos@@USShopItemTable@@@std@@QAE@AAUSItemPos@@AAUSShopItemTable@@@Z PROC ; std::pair<SItemPos,SShopItemTable>::pair<SItemPos,SShopItemTable><SItemPos &,SShopItemTable &,0>, COMDAT
; _this$ = ecx

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Val1$[ebp]
  00006	66 8b 02	 mov	 ax, WORD PTR [edx]
  00009	66 89 01	 mov	 WORD PTR [ecx], ax
  0000c	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00010	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00013	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00016	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00019	0f 11 41 03	 movups	 XMMWORD PTR [ecx+3], xmm0
  0001d	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00021	88 41 13	 mov	 BYTE PTR [ecx+19], al

; 173  :     }

  00024	8b c1		 mov	 eax, ecx
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$?0AAUSItemPos@@AAUSShopItemTable@@$0A@@?$pair@USItemPos@@USShopItemTable@@@std@@QAE@AAUSItemPos@@AAUSShopItemTable@@@Z ENDP ; std::pair<SItemPos,SShopItemTable>::pair<SItemPos,SShopItemTable><SItemPos &,SShopItemTable &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@YA$$QAU?$pair@USItemPos@@USShopItemTable@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@YA$$QAU?$pair@USItemPos@@USShopItemTable@@@0@AAU10@@Z PROC ; std::forward<std::pair<SItemPos,SShopItemTable> >, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@YA$$QAU?$pair@USItemPos@@USShopItemTable@@@0@AAU10@@Z ENDP ; std::forward<std::pair<SItemPos,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Loc$2 = -44						; size = 12
$T3 = -32						; size = 12
$T4 = -28						; size = 8
_this$1$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::emplace<std::pair<SItemPos,SShopItemTable> >, COMDAT
; _this$ = ecx

; 1031 :     pair<iterator, bool> emplace(_Valtys&&... _Vals) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 ec 20	 sub	 esp, 32			; 00000020H
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b f1		 mov	 esi, ecx
  0003d	89 75 ec	 mov	 DWORD PTR _this$1$[ebp], esi

; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  00040	8b 7b 0c	 mov	 edi, DWORD PTR _<_Vals_0>$[ebx]
  00043	8d 45 e0	 lea	 eax, DWORD PTR $T3[ebp]
  00046	57		 push	 edi
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
  0004d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00050	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00054	66 0f d6 45 d4	 movq	 QWORD PTR __Loc$2[ebp], xmm0

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00059	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0005d	75 17		 jne	 SHORT $LN4@emplace
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0005f	8a 51 0e	 mov	 dl, BYTE PTR [ecx+14]
  00062	38 17		 cmp	 BYTE PTR [edi], dl
  00064	72 10		 jb	 SHORT $LN4@emplace
  00066	75 0a		 jne	 SHORT $LN108@emplace
  00068	66 8b 47 01	 mov	 ax, WORD PTR [edi+1]
  0006c	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  00070	72 04		 jb	 SHORT $LN4@emplace
$LN108@emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00072	32 d2		 xor	 dl, dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1003 :                 return {_Loc._Bound, false};

  00074	eb 67		 jmp	 SHORT $LN97@emplace
$LN4@emplace:

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

  00076	81 7e 04 c7 71
	1c 07		 cmp	 DWORD PTR [esi+4], 119304647 ; 071c71c7H
  0007d	74 7c		 je	 SHORT $LN113@emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1007 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00082	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00084	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00087	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  0008e	6a 24		 push	 36			; 00000024H

; 1012 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+4], 0

; 77   :         return ::operator new(_Bytes);

  00097	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0009c	66 8b 0f	 mov	 cx, WORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 235  :         return _Traits::_Allocate(_Bytes);

  0009f	8b d0		 mov	 edx, eax

; 77   :         return ::operator new(_Bytes);

  000a1	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000a4	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  000a8	8a 4f 02	 mov	 cl, BYTE PTR [edi+2]
  000ab	88 4a 10	 mov	 BYTE PTR [edx+16], cl
  000ae	0f 10 47 03	 movups	 xmm0, XMMWORD PTR [edi+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000b2	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000b5	52		 push	 edx
  000b6	ff 75 d8	 push	 DWORD PTR __Loc$2[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000b9	0f 11 42 11	 movups	 XMMWORD PTR [edx+17], xmm0
  000bd	8a 47 13	 mov	 al, BYTE PTR [edi+19]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000c0	ff 75 d4	 push	 DWORD PTR __Loc$2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000c3	88 42 21	 mov	 BYTE PTR [edx+33], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000c6	89 32		 mov	 DWORD PTR [edx], esi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000c8	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000cb	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 811  :         this->_Ptr->_Color = _Red;

  000ce	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000d4	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  000d9	8b c8		 mov	 ecx, eax
  000db	b2 01		 mov	 dl, 1
$LN97@emplace:
  000dd	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]
  000e0	89 08		 mov	 DWORD PTR [eax], ecx
  000e2	88 50 04	 mov	 BYTE PTR [eax+4], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1034 :     }

  000e5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ef	59		 pop	 ecx
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	8b e5		 mov	 esp, ebp
  000f4	5d		 pop	 ebp
  000f5	8b e3		 mov	 esp, ebx
  000f7	5b		 pop	 ebx
  000f8	c2 08 00	 ret	 8
$LN113@emplace:

; 1630 :             _Throw_tree_length_error();

  000fb	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN111@emplace:
  00100	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::emplace<std::pair<SItemPos,SShopItemTable> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\map
;	COMDAT ??$_Kfn@$$CBUSItemPos@@USShopItemTable@@@?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@SAABUSItemPos@@ABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBUSItemPos@@USShopItemTable@@@?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@SAABUSItemPos@@ABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0>::_Kfn<SItemPos const ,SShopItemTable>, COMDAT
; __Val$ = ecx

; 68   :         return _Val.first;

  00000	8b c1		 mov	 eax, ecx

; 69   :     }

  00002	c3		 ret	 0
??$_Kfn@$$CBUSItemPos@@USShopItemTable@@@?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@SAABUSItemPos@@ABU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0>::_Kfn<SItemPos const ,SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU01@$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU01@$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@0@Z PROC ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>, COMDAT
; _this$ = ecx

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 173  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU01@$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@PAU12@@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@0@Z ENDP ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 889  :     // check that [_First, _Last) forms an iterator range
; 890  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 891  :         _Verify_range(_First, _Last);
; 892  :     }
; 893  : }

  00000	c2 00 00	 ret	 0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USShopItemTable@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<SShopItemTable> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Pass_fn@UItemStockSortFunc@@$0A@@std@@YA?AUItemStockSortFunc@@U1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??$_Pass_fn@UItemStockSortFunc@@$0A@@std@@YA?AUItemStockSortFunc@@U1@@Z PROC ; std::_Pass_fn<ItemStockSortFunc,0>, COMDAT

; 334  : constexpr _Fn _Pass_fn(_Fn _Val) { // pass functor by value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  :     return _Val;

  00003	8a 45 08	 mov	 al, BYTE PTR __Val$[ebp]

; 336  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Pass_fn@UItemStockSortFunc@@$0A@@std@@YA?AUItemStockSortFunc@@U1@@Z ENDP ; std::_Pass_fn<ItemStockSortFunc,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Val$1$ = -64						; size = 1
tv388 = -36						; size = 4
__Last$1$ = -36						; size = 4
__Val$2$ = -32						; size = 16
__Val$1 = -32						; size = 17
__Mid$2 = -32						; size = 8
__Ideal$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z PROC ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7635 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	83 ec 48	 sub	 esp, 72			; 00000048H
  00009	56		 push	 esi
  0000a	8b f2		 mov	 esi, edx
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	89 74 24 2c	 mov	 DWORD PTR __Last$1$[esp+80], esi

; 7636 :     // order [_First, _Last)
; 7637 :     for (;;) {
; 7638 :         if (_Last - _First <= _ISORT_MAX) { // small

  00013	8b c6		 mov	 eax, esi
  00015	2b c7		 sub	 eax, edi
  00017	3d 31 02 00 00	 cmp	 eax, 561		; 00000231H
  0001c	0f 8c 82 00 00
	00		 jl	 $LN46@Sort_unche
  00022	8b 45 0c	 mov	 eax, DWORD PTR __Pred$[ebp]
$LL2@Sort_unche:

; 7639 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7640 :             return;
; 7641 :         }
; 7642 : 
; 7643 :         if (_Ideal <= 0) { // heap sort if too many divisions

  00025	83 7d 08 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  00029	50		 push	 eax
  0002a	0f 8e c5 00 00
	00		 jle	 $LN47@Sort_unche

; 7645 :             _Sort_heap_unchecked(_First, _Last, _Pred);
; 7646 :             return;
; 7647 :         }
; 7648 : 
; 7649 :         // divide and conquer by quicksort
; 7650 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  00030	56		 push	 esi
  00031	8b d7		 mov	 edx, edi
  00033	8d 4c 24 38	 lea	 ecx, DWORD PTR __Mid$2[esp+88]
  00037	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Partition_by_median_guess_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7651 : 
; 7652 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

  0003c	8b 55 08	 mov	 edx, DWORD PTR __Ideal$[ebp]
  0003f	83 c4 08	 add	 esp, 8
  00042	8b c2		 mov	 eax, edx
  00044	d1 fa		 sar	 edx, 1
  00046	c1 f8 02	 sar	 eax, 2
  00049	03 d0		 add	 edx, eax

; 7653 : 
; 7654 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  0004b	8b c6		 mov	 eax, esi
  0004d	2b 44 24 34	 sub	 eax, DWORD PTR __Mid$2[esp+84]
  00051	69 c8 f1 f0 f0
	f0		 imul	 ecx, eax, -252645135
  00057	8b 44 24 30	 mov	 eax, DWORD PTR __Mid$2[esp+80]
  0005b	2b c7		 sub	 eax, edi
  0005d	89 55 08	 mov	 DWORD PTR __Ideal$[ebp], edx
  00060	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
  00066	3b c1		 cmp	 eax, ecx
  00068	8b 45 0c	 mov	 eax, DWORD PTR __Pred$[ebp]
  0006b	50		 push	 eax
  0006c	52		 push	 edx
  0006d	7d 11		 jge	 SHORT $LN7@Sort_unche

; 7655 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  0006f	8b 54 24 38	 mov	 edx, DWORD PTR __Mid$2[esp+88]
  00073	8b cf		 mov	 ecx, edi
  00075	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7656 :             _First = _Mid.second;

  0007a	8b 7c 24 3c	 mov	 edi, DWORD PTR __Mid$2[esp+92]

; 7657 :         } else { // loop on first half

  0007e	eb 13		 jmp	 SHORT $LN64@Sort_unche
$LN7@Sort_unche:

; 7658 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  00080	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Mid$2[esp+92]
  00084	8b d6		 mov	 edx, esi
  00086	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7659 :             _Last = _Mid.first;

  0008b	8b 74 24 38	 mov	 esi, DWORD PTR __Mid$2[esp+88]
  0008f	89 74 24 34	 mov	 DWORD PTR __Last$1$[esp+88], esi
$LN64@Sort_unche:

; 7636 :     // order [_First, _Last)
; 7637 :     for (;;) {
; 7638 :         if (_Last - _First <= _ISORT_MAX) { // small

  00093	8b c6		 mov	 eax, esi
  00095	83 c4 08	 add	 esp, 8
  00098	2b c7		 sub	 eax, edi
  0009a	3d 31 02 00 00	 cmp	 eax, 561		; 00000231H
  0009f	8b 45 0c	 mov	 eax, DWORD PTR __Pred$[ebp]
  000a2	7d 81		 jge	 SHORT $LL2@Sort_unche
$LN46@Sort_unche:

; 7510 :     if (_First != _Last) {

  000a4	3b fe		 cmp	 edi, esi
  000a6	0f 84 fd 00 00
	00		 je	 $LN32@Sort_unche

; 7511 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  000ac	8d 57 11	 lea	 edx, DWORD PTR [edi+17]
  000af	3b d6		 cmp	 edx, esi
  000b1	0f 84 f2 00 00
	00		 je	 $LN32@Sort_unche
$LL11@Sort_unche:

; 7512 :             _BidIt _Hole               = _Mid;
; 7513 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  000b7	0f 10 0a	 movups	 xmm1, XMMWORD PTR [edx]
  000ba	8a 6a 10	 mov	 ch, BYTE PTR [edx+16]
  000bd	8b f2		 mov	 esi, edx
  000bf	88 6c 24 10	 mov	 BYTE PTR __Val$1$[esp+80], ch
  000c3	0f 29 4c 24 30	 movaps	 XMMWORD PTR __Val$2$[esp+80], xmm1
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000c8	3a 6f 10	 cmp	 ch, BYTE PTR [edi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7515 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  000cb	0f 83 a7 00 00
	00		 jae	 $LN18@Sort_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 4249 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  000d1	8d 72 11	 lea	 esi, DWORD PTR [edx+17]
  000d4	8b cf		 mov	 ecx, edi
  000d6	56		 push	 esi
  000d7	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7517 :                 *_First = _STD move(_Val);

  000dc	0f 28 44 24 34	 movaps	 xmm0, XMMWORD PTR __Val$2$[esp+84]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 4249 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  000e1	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7517 :                 *_First = _STD move(_Val);

  000e4	8a 44 24 10	 mov	 al, BYTE PTR __Val$1$[esp+80]
  000e8	8b d6		 mov	 edx, esi
  000ea	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  000ed	88 47 10	 mov	 BYTE PTR [edi+16], al

; 7518 :             } else { // look for insertion point after first

  000f0	e9 aa 00 00 00	 jmp	 $LN19@Sort_unche
$LN47@Sort_unche:

; 7644 :             _Make_heap_unchecked(_First, _Last, _Pred);

  000f5	8b d6		 mov	 edx, esi
  000f7	8b cf		 mov	 ecx, edi
  000f9	e8 00 00 00 00	 call	 ??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ; std::_Make_heap_unchecked<SShopItemTable *,ItemStockSortFunc>

; 6416 :     for (; _Last - _First >= 2; --_Last) {

  000fe	2b f7		 sub	 esi, edi

; 7644 :             _Make_heap_unchecked(_First, _Last, _Pred);

  00100	83 c4 04	 add	 esp, 4

; 6416 :     for (; _Last - _First >= 2; --_Last) {

  00103	83 fe 22	 cmp	 esi, 34			; 00000022H
  00106	0f 8c 9d 00 00
	00		 jl	 $LN32@Sort_unche

; 7644 :             _Make_heap_unchecked(_First, _Last, _Pred);

  0010c	8b 4c 24 2c	 mov	 ecx, DWORD PTR __Last$1$[esp+80]
  00110	83 c1 ef	 add	 ecx, -17		; ffffffefH
  00113	89 4c 24 2c	 mov	 DWORD PTR tv388[esp+80], ecx
$LL33@Sort_unche:

; 6069 :     if (2 <= _Last - _First) {

  00117	b8 f1 f0 f0 f0	 mov	 eax, -252645135		; f0f0f0f1H
  0011c	f7 e6		 mul	 esi
  0011e	8b f1		 mov	 esi, ecx
  00120	c1 ea 04	 shr	 edx, 4
  00123	2b f7		 sub	 esi, edi
  00125	83 fa 02	 cmp	 edx, 2
  00128	7c 3c		 jl	 SHORT $LN31@Sort_unche

; 6070 :         --_Last;
; 6071 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  0012a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0012d	0f b6 41 10	 movzx	 eax, BYTE PTR [ecx+16]

; 6062 :     _Pop_heap_hole_by_index(

  00131	33 d2		 xor	 edx, edx
  00133	ff 75 0c	 push	 DWORD PTR __Pred$[ebp]

; 6071 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00136	0f 11 44 24 34	 movups	 XMMWORD PTR __Val$1[esp+84], xmm0
  0013b	88 44 24 44	 mov	 BYTE PTR __Val$1[esp+100], al

; 6060 :     *_Dest      = _STD move(*_First);

  0013f	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00142	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00145	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  00149	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 6061 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6062 :     _Pop_heap_hole_by_index(

  0014c	8d 44 24 34	 lea	 eax, DWORD PTR __Val$1[esp+84]
  00150	50		 push	 eax
  00151	69 c6 f1 f0 f0
	f0		 imul	 eax, esi, -252645135
  00157	8b cf		 mov	 ecx, edi
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
  0015f	8b 4c 24 38	 mov	 ecx, DWORD PTR tv388[esp+92]
  00163	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@Sort_unche:

; 6416 :     for (; _Last - _First >= 2; --_Last) {

  00166	83 e9 11	 sub	 ecx, 17			; 00000011H
  00169	89 4c 24 2c	 mov	 DWORD PTR tv388[esp+80], ecx
  0016d	83 fe 22	 cmp	 esi, 34			; 00000022H
  00170	7d a5		 jge	 SHORT $LL33@Sort_unche

; 7660 :         }
; 7661 :     }
; 7662 : }

  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
$LN18@Sort_unche:

; 7519 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00178	8d 42 ef	 lea	 eax, DWORD PTR [edx-17]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0017b	3a 6a ff	 cmp	 ch, BYTE PTR [edx-1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7519 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  0017e	73 16		 jae	 SHORT $LN15@Sort_unche
$LL16@Sort_unche:

; 7520 :                     *_Hole = _STD move(*_Prev); // move hole down

  00180	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00183	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00186	8a 48 10	 mov	 cl, BYTE PTR [eax+16]
  00189	88 4e 10	 mov	 BYTE PTR [esi+16], cl
  0018c	8b f0		 mov	 esi, eax
  0018e	83 e8 11	 sub	 eax, 17			; 00000011H
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00191	3a 68 10	 cmp	 ch, BYTE PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7519 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00194	72 ea		 jb	 SHORT $LL16@Sort_unche
$LN15@Sort_unche:

; 7521 :                 }
; 7522 : 
; 7523 :                 *_Hole = _STD move(_Val); // insert element in hole

  00196	0f 11 0e	 movups	 XMMWORD PTR [esi], xmm1
  00199	88 6e 10	 mov	 BYTE PTR [esi+16], ch
  0019c	83 c2 11	 add	 edx, 17			; 00000011H
$LN19@Sort_unche:

; 7511 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  0019f	3b 54 24 2c	 cmp	 edx, DWORD PTR __Last$1$[esp+80]
  001a3	0f 85 0e ff ff
	ff		 jne	 $LL11@Sort_unche
$LN32@Sort_unche:

; 7660 :         }
; 7661 :     }
; 7662 : }

  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c3		 ret	 0
??$_Sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0HUItemStockSortFunc@@@Z ENDP ; std::_Sort_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@ABUSShopItemTable@@@std@@YAABUSShopItemTable@@ABU1@@Z
_TEXT	SEGMENT
??$forward@ABUSShopItemTable@@@std@@YAABUSShopItemTable@@ABU1@@Z PROC ; std::forward<SShopItemTable const &>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@ABUSShopItemTable@@@std@@YAABUSShopItemTable@@ABU1@@Z ENDP ; std::forward<SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_back_with_unused_capacity<SShopItemTable const &>, COMDAT
; _this$ = ecx

; 852  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 852  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00009	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 860  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  0000c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0000f	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00012	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00015	88 42 10	 mov	 BYTE PTR [edx+16], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 868  :         _Ty& _Result = *_Mylast;

  00018	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 869  :         ++_Mylast;

  0001b	8d 48 11	 lea	 ecx, DWORD PTR [eax+17]
  0001e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 870  : 
; 871  :         return _Result;

  00021	5e		 pop	 esi

; 872  :     }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEAAUSShopItemTable@@ABU2@@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_back_with_unused_capacity<SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -8					; size = 4
__Whereoff$1$ = -4					; size = 4
tv617 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>, COMDAT
; _this$ = ecx

; 875  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 876  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 877  :         _Alty& _Al        = _Getal();
; 878  :         auto& _My_data    = _Mypair._Myval2;
; 879  :         pointer& _Myfirst = _My_data._Myfirst;
; 880  :         pointer& _Mylast  = _My_data._Mylast;
; 881  : 
; 882  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 883  : 
; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00009	b8 79 78 78 78	 mov	 eax, 2021161081		; 78787879H
  0000e	53		 push	 ebx
  0000f	8b d9		 mov	 ebx, ecx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00015	2b d1		 sub	 edx, ecx
  00017	f7 ea		 imul	 edx
  00019	c1 fa 03	 sar	 edx, 3
  0001c	8b c2		 mov	 eax, edx
  0001e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00021	03 c2		 add	 eax, edx
  00023	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax

; 885  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00026	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00029	2b c1		 sub	 eax, ecx
  0002b	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
  00031	89 45 f8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 886  : 
; 887  :         if (_Oldsize == max_size()) {

  00034	3d 0f 0f 0f 0f	 cmp	 eax, 252645135		; 0f0f0f0fH
  00039	0f 84 de 00 00
	00		 je	 $LN107@Emplace_re

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize     = _Oldsize + 1;

  0003f	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1942 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00042	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00045	2b c1		 sub	 eax, ecx
  00047	69 d0 f1 f0 f0
	f0		 imul	 edx, eax, -252645135

; 2029 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004d	b8 0f 0f 0f 0f	 mov	 eax, 252645135		; 0f0f0f0fH
  00052	8b ca		 mov	 ecx, edx
  00054	d1 e9		 shr	 ecx, 1
  00056	2b c1		 sub	 eax, ecx
  00058	3b d0		 cmp	 edx, eax
  0005a	76 15		 jbe	 SHORT $LN12@Emplace_re

; 2030 :             return _Max; // geometric growth would overflow

  0005c	83 c8 ff	 or	 eax, -1
  0005f	be 0f 0f 0f 0f	 mov	 esi, 252645135		; 0f0f0f0fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006a	83 c4 04	 add	 esp, 4
  0006d	8b f8		 mov	 edi, eax
  0006f	eb 44		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 2033 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00071	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00074	8b f7		 mov	 esi, edi
  00076	3b c7		 cmp	 eax, edi
  00078	0f 43 f0	 cmovae	 esi, eax
  0007b	81 fe 0f 0f 0f
	0f		 cmp	 esi, 252645135		; 0f0f0f0fH
  00081	0f 87 9b 00 00
	00		 ja	 $LN108@Emplace_re

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00087	8b c6		 mov	 eax, esi
  00089	c1 e0 04	 shl	 eax, 4
  0008c	03 c6		 add	 eax, esi

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0008e	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00093	72 0d		 jb	 SHORT $LN100@Emplace_re

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009b	83 c4 04	 add	 esp, 4
  0009e	8b f8		 mov	 edi, eax
  000a0	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN100@Emplace_re:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  000a2	85 c0		 test	 eax, eax
  000a4	74 0d		 je	 SHORT $LN26@Emplace_re

; 77   :         return ::operator new(_Bytes);

  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ac	83 c4 04	 add	 esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

  000af	8b f8		 mov	 edi, eax
  000b1	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN26@Emplace_re:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  000b3	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 899  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __Whereoff$1$[ebp]
  000b8	8b c1		 mov	 eax, ecx
  000ba	c1 e0 04	 shl	 eax, 4
  000bd	03 c7		 add	 eax, edi
  000bf	03 c8		 add	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000c1	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 899  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000c4	89 4d fc	 mov	 DWORD PTR tv617[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  000c7	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000ca	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  000cd	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  000d0	88 41 10	 mov	 BYTE PTR [ecx+16], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 902  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000d3	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000d6	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000d9	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000db	3b c2		 cmp	 eax, edx
  000dd	75 04		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1800 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000df	8b c7		 mov	 eax, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 908  :         } else { // provide basic guarantee

  000e1	eb 17		 jmp	 SHORT $LN75@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1800 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000e3	57		 push	 edi
  000e4	8b d0		 mov	 edx, eax
  000e6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 911  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000eb	8b 45 fc	 mov	 eax, DWORD PTR tv617[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1800 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000ee	83 c4 04	 add	 esp, 4

; 1793 :     const auto _ULast = _Get_unwrapped(_Last);

  000f1	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 911  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000f4	83 c0 11	 add	 eax, 17			; 00000011H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1800 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000f7	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
$LN75@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector

; 911  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>

; 912  :         }
; 913  :         _CATCH_ALL
; 914  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 915  :         _Al.deallocate(_Newvec, _Newcapacity);
; 916  :         _RERAISE;
; 917  :         _CATCH_END
; 918  : 
; 919  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00100	8b 45 f8	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  00103	83 c4 04	 add	 esp, 4
  00106	40		 inc	 eax
  00107	8b cb		 mov	 ecx, ebx
  00109	56		 push	 esi
  0010a	50		 push	 eax
  0010b	57		 push	 edi
  0010c	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEXQAUSShopItemTable@@II@Z ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Change_array

; 920  :         return _Newvec + _Whereoff;

  00111	8b 45 fc	 mov	 eax, DWORD PTR tv617[ebp]
  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	5b		 pop	 ebx

; 921  :     }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 08 00	 ret	 8
$LN107@Emplace_re:

; 888  :             _Xlength();

  0011d	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@CAXXZ ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Xlength
$LN108@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00122	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN105@Emplace_re:
  00127	cc		 int	 3
??$_Emplace_reallocate@ABUSShopItemTable@@@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@AAEPAUSShopItemTable@@QAU2@ABU2@@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Emplace_reallocate<SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>, COMDAT
; _this$ = ecx

; 1609 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1610 :         const auto _Scary = _Get_scary();
; 1611 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00008	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000b	89 02		 mov	 DWORD PTR [edx], eax
  0000d	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
  00014	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

  00017	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0001b	75 36		 jne	 SHORT $LN18@Find_lower
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0001d	53		 push	 ebx
  0001e	56		 push	 esi
  0001f	8b 75 0c	 mov	 esi, DWORD PTR __Keyval$[ebp]
  00022	8a 1e		 mov	 bl, BYTE PTR [esi]
$LL2@Find_lower:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1614 :             _Result._Location._Parent = _Trynode;

  00024	89 02		 mov	 DWORD PTR [edx], eax
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00026	38 58 0e	 cmp	 BYTE PTR [eax+14], bl
  00029	72 18		 jb	 SHORT $LN17@Find_lower
  0002b	75 0a		 jne	 SHORT $LN4@Find_lower
  0002d	66 8b 48 0f	 mov	 cx, WORD PTR [eax+15]
  00031	66 3b 4e 01	 cmp	 cx, WORD PTR [esi+1]
  00035	72 0c		 jb	 SHORT $LN17@Find_lower
$LN4@Find_lower:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1620 :                 _Result._Bound           = _Trynode;

  00037	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1621 :                 _Trynode                 = _Trynode->_Left;

  0003a	b9 01 00 00 00	 mov	 ecx, 1
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 05		 jmp	 SHORT $LN5@Find_lower
$LN17@Find_lower:

; 1615 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {
; 1616 :                 _Result._Location._Child = _Tree_child::_Right;
; 1617 :                 _Trynode                 = _Trynode->_Right;

  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00046	33 c9		 xor	 ecx, ecx
$LN5@Find_lower:

; 1612 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1613 :         while (!_Trynode->_Isnil) {

  00048	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0004b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0004f	74 d3		 je	 SHORT $LL2@Find_lower

; 1622 :             }
; 1623 :         }
; 1624 : 
; 1625 :         return _Result;

  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
$LN18@Find_lower:

; 1626 :     }

  00053	8b c2		 mov	 eax, edx
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z
_TEXT	SEGMENT
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Lower_bound_duplicate<SItemPos>, COMDAT
; _this$dead$ = ecx

; 1604 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Bound$[ebp]
  00006	53		 push	 ebx
  00007	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0000b	75 1d		 jne	 SHORT $LN3@Lower_boun
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00010	8a 10		 mov	 dl, BYTE PTR [eax]
  00012	3a 51 0e	 cmp	 dl, BYTE PTR [ecx+14]
  00015	72 13		 jb	 SHORT $LN3@Lower_boun
  00017	75 0a		 jne	 SHORT $LN12@Lower_boun
  00019	66 8b 40 01	 mov	 ax, WORD PTR [eax+1]
  0001d	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  00021	72 07		 jb	 SHORT $LN3@Lower_boun
$LN12@Lower_boun:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00023	b0 01		 mov	 al, 1
  00025	5b		 pop	 ebx

; 1606 :     }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
$LN3@Lower_boun:

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0002a	32 c0		 xor	 al, al
  0002c	5b		 pop	 ebx

; 1606 :     }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??$_Lower_bound_duplicate@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@ABUSItemPos@@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Lower_bound_duplicate<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 652  :     // assign _New_val to _Val, return previous _Val
; 653  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 654  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 655  :     return _Old_val;
; 656  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 255  :         ::operator delete(_Ptr, _Bytes);

  00000	6a 24		 push	 36			; 00000024H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 377  :     }

  0000b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$move@AAUSShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z
_TEXT	SEGMENT
??$move@AAUSShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z PROC ; std::move<SShopItemTable &>, COMDAT
; __Arg$ = ecx

; 1437 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1438 : }

  00002	c3		 ret	 0
??$move@AAUSShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z ENDP ; std::move<SShopItemTable &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z PROC ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 3833 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3834 :     auto _FirstPtr              = _To_address(_First);
; 3835 :     auto _LastPtr               = _To_address(_Last);
; 3836 :     auto _DestPtr               = _To_address(_Dest);
; 3837 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 3838 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 3839 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 3840 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 3841 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3842 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 3843 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 3844 :     } else {
; 3845 :         return _Dest + (_LastPtr - _FirstPtr);
; 3846 :     }
; 3847 : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ENDP ; std::_Copy_memmove<SShopItemTable *,SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_To_address@PAUSShopItemTable@@@std@@YA?A_PABQAUSShopItemTable@@@Z
_TEXT	SEGMENT
??$_To_address@PAUSShopItemTable@@@std@@YA?A_PABQAUSShopItemTable@@@Z PROC ; std::_To_address<SShopItemTable *>, COMDAT
; __Val$ = ecx

; 3703 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 3704 :     return _STD to_address(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3705 : }

  00002	c3		 ret	 0
??$_To_address@PAUSShopItemTable@@@std@@YA?A_PABQAUSShopItemTable@@@Z ENDP ; std::_To_address<SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Emplace_back@USShopItemTable@@@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEX$$QAUSShopItemTable@@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USShopItemTable@@@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEX$$QAUSShopItemTable@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Emplace_back<SShopItemTable>, COMDAT
; _this$ = ecx

; 1662 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]

; 1663 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00009	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0000c	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0000f	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00012	88 42 10	 mov	 BYTE PTR [edx+16], al

; 1664 :         ++_Last;

  00015	83 41 04 11	 add	 DWORD PTR [ecx+4], 17	; 00000011H

; 1665 :     }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??$_Emplace_back@USShopItemTable@@@?$_Uninitialized_backout_al@V?$allocator@USShopItemTable@@@std@@@std@@QAEX$$QAUSShopItemTable@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<SShopItemTable> >::_Emplace_back<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 889  :     // check that [_First, _Last) forms an iterator range
; 890  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 891  :         _Verify_range(_First, _Last);
; 892  :     }
; 893  : }

  00000	c2 00 00	 ret	 0
??$_Adl_verify_range@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXABV?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0>,std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@ABU?$less@USItemPos@@@std@@@std@@YAABU?$less@USItemPos@@@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$less@USItemPos@@@std@@@std@@YAABU?$less@USItemPos@@@0@ABU10@@Z PROC ; std::forward<std::less<SItemPos> const &>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@ABU?$less@USItemPos@@@std@@@std@@YAABU?$less@USItemPos@@@0@ABU10@@Z ENDP ; std::forward<std::less<SItemPos> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 225  : #if _HAS_CXX20
; 226  :     if (_STD is_constant_evaluated()) {
; 227  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 228  :     } else
; 229  : #endif // _HAS_CXX20
; 230  :     {
; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 232  :     }
; 233  : }

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax
  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
??$destroy@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::destroy<std::pair<SItemPos const ,SShopItemTable> >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$dead$ = edx

; 686  : #if _HAS_CXX20
; 687  :         _STD destroy_at(_Ptr);
; 688  : #else // _HAS_CXX20
; 689  :         _Ptr->~_Uty();
; 690  : #endif // _HAS_CXX20
; 691  :     }

  00000	c2 00 00	 ret	 0
??$destroy@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::destroy<std::pair<SItemPos const ,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Orphan_range@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEXPAUSShopItemTable@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEXPAUSShopItemTable@@0@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 2240 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEXPAUSShopItemTable@@0@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEII@Z PROC ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 2024 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1942 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	2b 01		 sub	 eax, DWORD PTR [ecx]

; 2025 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2026 :         const size_type _Oldcapacity = capacity();
; 2027 :         const auto _Max              = max_size();
; 2028 : 
; 2029 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00008	b9 0f 0f 0f 0f	 mov	 ecx, 252645135		; 0f0f0f0fH
  0000d	56		 push	 esi

; 1942 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000e	69 f0 f1 f0 f0
	f0		 imul	 esi, eax, -252645135

; 2025 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2026 :         const size_type _Oldcapacity = capacity();
; 2027 :         const auto _Max              = max_size();
; 2028 : 
; 2029 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00014	8b d6		 mov	 edx, esi
  00016	d1 ea		 shr	 edx, 1
  00018	2b ca		 sub	 ecx, edx
  0001a	3b f1		 cmp	 esi, ecx
  0001c	76 0a		 jbe	 SHORT $LN2@Calculate_

; 2030 :             return _Max; // geometric growth would overflow

  0001e	b8 0f 0f 0f 0f	 mov	 eax, 252645135		; 0f0f0f0fH
  00023	5e		 pop	 esi

; 2036 :             return _Newsize; // geometric growth would be insufficient
; 2037 :         }
; 2038 : 
; 2039 :         return _Geometric; // geometric growth is sufficient
; 2040 :     }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN2@Calculate_:

; 2031 :         }
; 2032 : 
; 2033 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00028	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 2034 : 
; 2035 :         if (_Geometric < _Newsize) {

  0002b	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0002e	5e		 pop	 esi
  0002f	0f 42 45 08	 cmovb	 eax, DWORD PTR __Newsize$[ebp]

; 2036 :             return _Newsize; // geometric growth would be insufficient
; 2037 :         }
; 2038 : 
; 2039 :         return _Geometric; // geometric growth is sufficient
; 2040 :     }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USShopItemTable@@V?$allocator@USShopItemTable@@@std@@@std@@ABEII@Z ENDP ; std::vector<SShopItemTable,std::allocator<SShopItemTable> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >, COMDAT
; _this$ = ecx

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::deallocate, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 255  :         ::operator delete(_Ptr, _Bytes);

  00000	6a 24		 push	 36			; 00000024H
  00002	52		 push	 edx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00008	83 c4 08	 add	 esp, 8

; 660  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 661  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 662  :         if (_STD is_constant_evaluated()) {
; 663  :             _Al.deallocate(_Ptr, _Count);
; 664  :         } else
; 665  : #endif // _HAS_CXX20
; 666  :         {
; 667  :             (void) _Al;
; 668  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
; 669  :         }
; 670  :     }

  0000b	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >, COMDAT
; _this$ = ecx

; 819  :     constexpr allocator() noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 827  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 255  :         ::operator delete(_Ptr, _Bytes);

  00003	6a 24		 push	 36			; 00000024H
  00005	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	83 c4 08	 add	 esp, 8

; 828  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 829  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 831  :     }

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T2 = -32						; size = 12
$T3 = -28						; size = 8
_this$1$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Emplace<std::pair<SItemPos,SShopItemTable> >, COMDAT
; _this$ = ecx

; 994  :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 ec 20	 sub	 esp, 32			; 00000020H
  00028	56		 push	 esi
  00029	57		 push	 edi
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b f1		 mov	 esi, ecx
  0003d	89 75 ec	 mov	 DWORD PTR _this$1$[ebp], esi

; 995  :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 996  :         const auto _Scary             = _Get_scary();
; 997  :         _Tree_find_result<_Nodeptr> _Loc;
; 998  :         _Nodeptr _Inserted;
; 999  :         if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
; 1000 :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
; 1001 :             _Loc                = _Find_lower_bound(_Keyval);

  00040	8b 7b 0c	 mov	 edi, DWORD PTR _<_Vals_0>$[ebx]
  00043	8d 45 e0	 lea	 eax, DWORD PTR $T2[ebp]
  00046	57		 push	 edi
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$_Find_lower_bound@USItemPos@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@ABUSItemPos@@@Z ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Find_lower_bound<SItemPos>
  0004d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00050	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00054	66 0f d6 45 d4	 movq	 QWORD PTR __Loc$[ebp], xmm0

; 1605 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00059	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  0005d	75 1e		 jne	 SHORT $LN2@Emplace
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  0005f	8a 07		 mov	 al, BYTE PTR [edi]
  00061	3a 41 0e	 cmp	 al, BYTE PTR [ecx+14]
  00064	72 17		 jb	 SHORT $LN2@Emplace
  00066	75 0a		 jne	 SHORT $LN97@Emplace
  00068	66 8b 47 01	 mov	 ax, WORD PTR [edi+1]
  0006c	66 3b 41 0f	 cmp	 ax, WORD PTR [ecx+15]
  00070	72 0b		 jb	 SHORT $LN2@Emplace
$LN97@Emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00072	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]
  00075	89 08		 mov	 DWORD PTR [eax], ecx
  00077	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1003 :                 return {_Loc._Bound, false};

  0007b	eb 6e		 jmp	 SHORT $LN1@Emplace
$LN2@Emplace:

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

  0007d	81 7e 04 c7 71
	1c 07		 cmp	 DWORD PTR [esi+4], 119304647 ; 071c71c7H
  00084	74 7b		 je	 SHORT $LN102@Emplace
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00086	8b 45 ec	 mov	 eax, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1007 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00089	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0008b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0008e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00095	6a 24		 push	 36			; 00000024H

; 1012 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00097	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0

; 77   :         return ::operator new(_Bytes);

  0009e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000a3	66 8b 0f	 mov	 cx, WORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 235  :         return _Traits::_Allocate(_Bytes);

  000a6	8b d0		 mov	 edx, eax

; 77   :         return ::operator new(_Bytes);

  000a8	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000ab	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx
  000af	8a 4f 02	 mov	 cl, BYTE PTR [edi+2]
  000b2	88 4a 10	 mov	 BYTE PTR [edx+16], cl
  000b5	0f 10 47 03	 movups	 xmm0, XMMWORD PTR [edi+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000b9	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000bc	52		 push	 edx
  000bd	ff 75 d8	 push	 DWORD PTR __Loc$[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000c0	0f 11 42 11	 movups	 XMMWORD PTR [edx+17], xmm0
  000c4	8a 47 13	 mov	 al, BYTE PTR [edi+19]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000c7	ff 75 d4	 push	 DWORD PTR __Loc$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  000ca	88 42 21	 mov	 BYTE PTR [edx+33], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000cd	89 32		 mov	 DWORD PTR [edx], esi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000cf	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000d2	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 811  :         this->_Ptr->_Color = _Red;

  000d5	66 c7 42 0c 00
	00		 mov	 WORD PTR [edx+12], 0

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000db	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  000e0	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  000e3	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1026 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000e5	8b c1		 mov	 eax, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  000e7	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1
$LN1@Emplace:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 1027 :     }

  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	8b e3		 mov	 esp, ebx
  000fd	5b		 pop	 ebx
  000fe	c2 08 00	 ret	 8
$LN102@Emplace:

; 1630 :             _Throw_tree_length_error();

  00101	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN100@Emplace:
  00106	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$2:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace@U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Emplace<std::pair<SItemPos,SShopItemTable> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool const &,0>, COMDAT
; _this$ = ecx

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 173  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > >,bool const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAPAUSShopItemTable@@QAU1@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Val$2$ = -20						; size = 16
__First$1$ = -4						; size = 4
__Pred$ = 8						; size = 1
??$_Insertion_sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAPAUSShopItemTable@@QAU1@0UItemStockSortFunc@@@Z PROC ; std::_Insertion_sort_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 7508 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	57		 push	 edi
  00007	8b c1		 mov	 eax, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	89 45 fc	 mov	 DWORD PTR __First$1$[ebp], eax

; 7509 :     // insertion sort [_First, _Last)
; 7510 :     if (_First != _Last) {

  0000e	3b c7		 cmp	 eax, edi
  00010	74 76		 je	 SHORT $LN33@Insertion_

; 7511 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00012	8d 50 11	 lea	 edx, DWORD PTR [eax+17]
  00015	3b d7		 cmp	 edx, edi
  00017	74 6f		 je	 SHORT $LN33@Insertion_
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	0f 1f 44 00 00	 npad	 5
$LL2@Insertion_:

; 7512 :             _BidIt _Hole               = _Mid;
; 7513 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  00020	0f 10 0a	 movups	 xmm1, XMMWORD PTR [edx]
  00023	8a 5a 10	 mov	 bl, BYTE PTR [edx+16]
  00026	8b f2		 mov	 esi, edx
  00028	0f 11 4d ec	 movups	 XMMWORD PTR __Val$2$[ebp], xmm1
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0002c	3a 58 10	 cmp	 bl, BYTE PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7515 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  0002f	73 1f		 jae	 SHORT $LN9@Insertion_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 4249 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  00031	8d 72 11	 lea	 esi, DWORD PTR [edx+17]
  00034	8b c8		 mov	 ecx, eax
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7517 :                 *_First = _STD move(_Val);

  0003c	8b 45 fc	 mov	 eax, DWORD PTR __First$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 4249 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  0003f	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7517 :                 *_First = _STD move(_Val);

  00042	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR __Val$2$[ebp]
  00046	8b d6		 mov	 edx, esi
  00048	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0004b	88 58 10	 mov	 BYTE PTR [eax+16], bl

; 7518 :             } else { // look for insertion point after first

  0004e	eb 32		 jmp	 SHORT $LN10@Insertion_
$LN9@Insertion_:

; 7519 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00050	8d 42 ef	 lea	 eax, DWORD PTR [edx-17]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00053	3a 5a ff	 cmp	 bl, BYTE PTR [edx-1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7519 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00056	73 1e		 jae	 SHORT $LN6@Insertion_
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@Insertion_:

; 7520 :                     *_Hole = _STD move(*_Prev); // move hole down

  00060	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00063	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00066	8a 48 10	 mov	 cl, BYTE PTR [eax+16]
  00069	88 4e 10	 mov	 BYTE PTR [esi+16], cl
  0006c	8b f0		 mov	 esi, eax
  0006e	83 e8 11	 sub	 eax, 17			; 00000011H
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00071	3a 58 10	 cmp	 bl, BYTE PTR [eax+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7519 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00074	72 ea		 jb	 SHORT $LL7@Insertion_
$LN6@Insertion_:
  00076	8b 45 fc	 mov	 eax, DWORD PTR __First$1$[ebp]

; 7521 :                 }
; 7522 : 
; 7523 :                 *_Hole = _STD move(_Val); // insert element in hole

  00079	83 c2 11	 add	 edx, 17			; 00000011H
  0007c	0f 11 0e	 movups	 XMMWORD PTR [esi], xmm1
  0007f	88 5e 10	 mov	 BYTE PTR [esi+16], bl
$LN10@Insertion_:

; 7511 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00082	3b d7		 cmp	 edx, edi
  00084	75 9a		 jne	 SHORT $LL2@Insertion_

; 7524 :             }
; 7525 :         }
; 7526 :     }
; 7527 : 
; 7528 :     return _Last;

  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
$LN33@Insertion_:

; 7529 : }

  00088	8b c7		 mov	 eax, edi
  0008a	5f		 pop	 edi
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
??$_Insertion_sort_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAPAUSShopItemTable@@QAU1@0UItemStockSortFunc@@@Z ENDP ; std::_Insertion_sort_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
tv377 = -20						; size = 4
__Bottom$1$ = -16					; size = 4
__Hole$1$ = -12						; size = 4
__Max_sequence_non_leaf$1$ = -8				; size = 4
__Val$1$ = -1						; size = 1
__Pred$ = 8						; size = 1
??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z PROC ; std::_Make_heap_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6192 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 6193 :     // make [_First, _Last) into a heap
; 6194 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6195 :     _Diff _Bottom = _Last - _First;

  0000a	2b d7		 sub	 edx, edi
  0000c	69 c2 f1 f0 f0
	f0		 imul	 eax, edx, -252645135

; 6196 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00012	8b d8		 mov	 ebx, eax
  00014	89 45 f0	 mov	 DWORD PTR __Bottom$1$[ebp], eax
  00017	d1 fb		 sar	 ebx, 1
  00019	85 db		 test	 ebx, ebx
  0001b	0f 8e 00 01 00
	00		 jle	 $LN3@Make_heap_

; 6193 :     // make [_First, _Last) into a heap
; 6194 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6195 :     _Diff _Bottom = _Last - _First;

  00021	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00024	8b c3		 mov	 eax, ebx
  00026	c1 e0 04	 shl	 eax, 4
  00029	d1 f9		 sar	 ecx, 1
  0002b	03 c7		 add	 eax, edi
  0002d	89 4d f8	 mov	 DWORD PTR __Max_sequence_non_leaf$1$[ebp], ecx
  00030	03 c3		 add	 eax, ebx
  00032	56		 push	 esi
$LL2@Make_heap_:

; 6197 :         // reheap top half, bottom to top
; 6198 :         --_Hole;
; 6199 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00033	0f 10 48 ef	 movups	 xmm1, XMMWORD PTR [eax-17]
  00037	83 e8 11	 sub	 eax, 17			; 00000011H
  0003a	4b		 dec	 ebx
  0003b	89 45 ec	 mov	 DWORD PTR tv377[ebp], eax

; 6200 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  0003e	8b f3		 mov	 esi, ebx
  00040	89 5d f4	 mov	 DWORD PTR __Hole$1$[ebp], ebx

; 6033 :     _Diff _Idx       = _Hole;

  00043	8b d3		 mov	 edx, ebx

; 6197 :         // reheap top half, bottom to top
; 6198 :         --_Hole;
; 6199 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00045	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00048	88 45 ff	 mov	 BYTE PTR __Val$1$[ebp], al

; 6038 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0004b	3b d9		 cmp	 ebx, ecx
  0004d	7d 47		 jge	 SHORT $LN8@Make_heap_
  0004f	8b 5d f8	 mov	 ebx, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
$LL7@Make_heap_:

; 6039 :         _Idx = 2 * _Idx + 2;

  00052	03 d2		 add	 edx, edx

; 6040 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00054	8b ca		 mov	 ecx, edx
  00056	c1 e1 04	 shl	 ecx, 4
  00059	03 cf		 add	 ecx, edi

; 6041 :             --_Idx;
; 6042 :         }
; 6043 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0005b	0f b6 44 0a 32	 movzx	 eax, BYTE PTR [edx+ecx+50]
  00060	3a 44 0a 21	 cmp	 al, BYTE PTR [edx+ecx+33]
  00064	8b ce		 mov	 ecx, esi
  00066	1b c0		 sbb	 eax, eax
  00068	c1 e1 04	 shl	 ecx, 4
  0006b	83 c0 02	 add	 eax, 2
  0006e	03 cf		 add	 ecx, edi
  00070	03 d0		 add	 edx, eax
  00072	8b c2		 mov	 eax, edx
  00074	c1 e0 04	 shl	 eax, 4
  00077	03 c7		 add	 eax, edi
  00079	0f 10 04 10	 movups	 xmm0, XMMWORD PTR [eax+edx]
  0007d	0f 11 04 31	 movups	 XMMWORD PTR [ecx+esi], xmm0
  00081	0f b6 44 10 10	 movzx	 eax, BYTE PTR [eax+edx+16]
  00086	88 44 31 10	 mov	 BYTE PTR [ecx+esi+16], al

; 6044 :         _Hole             = _Idx;

  0008a	8b f2		 mov	 esi, edx
  0008c	3b d3		 cmp	 edx, ebx
  0008e	7c c2		 jl	 SHORT $LL7@Make_heap_
  00090	8b 5d f4	 mov	 ebx, DWORD PTR __Hole$1$[ebp]
  00093	8b 4d f8	 mov	 ecx, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
$LN8@Make_heap_:

; 6045 :     }
; 6046 : 
; 6047 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00096	3b f1		 cmp	 esi, ecx
  00098	75 2a		 jne	 SHORT $LN10@Make_heap_
  0009a	8b 55 f0	 mov	 edx, DWORD PTR __Bottom$1$[ebp]
  0009d	f6 c2 01	 test	 dl, 1
  000a0	75 22		 jne	 SHORT $LN10@Make_heap_

; 6048 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000a2	8b c2		 mov	 eax, edx
  000a4	8b ce		 mov	 ecx, esi
  000a6	c1 e0 04	 shl	 eax, 4
  000a9	03 c7		 add	 eax, edi
  000ab	c1 e1 04	 shl	 ecx, 4
  000ae	03 cf		 add	 ecx, edi
  000b0	0f 10 44 02 ef	 movups	 xmm0, XMMWORD PTR [edx+eax-17]
  000b5	0f 11 04 31	 movups	 XMMWORD PTR [ecx+esi], xmm0
  000b9	8a 44 02 ff	 mov	 al, BYTE PTR [edx+eax-1]
  000bd	88 44 31 10	 mov	 BYTE PTR [ecx+esi+16], al

; 6049 :         _Hole             = _Bottom - 1;

  000c1	8d 72 ff	 lea	 esi, DWORD PTR [edx-1]
$LN10@Make_heap_:

; 5920 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  000c4	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  000c7	d1 f8		 sar	 eax, 1

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000c9	3b de		 cmp	 ebx, esi
  000cb	7d 33		 jge	 SHORT $LN33@Make_heap_
  000cd	0f 1f 00	 npad	 3
$LL17@Make_heap_:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000d0	8a 55 ff	 mov	 dl, BYTE PTR __Val$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000d3	8b c8		 mov	 ecx, eax
  000d5	c1 e1 04	 shl	 ecx, 4
  000d8	03 cf		 add	 ecx, edi
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000da	38 54 08 10	 cmp	 BYTE PTR [eax+ecx+16], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000de	73 20		 jae	 SHORT $LN33@Make_heap_

; 5922 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5923 :         // move _Hole up to parent
; 5924 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  000e0	0f 10 04 08	 movups	 xmm0, XMMWORD PTR [eax+ecx]
  000e4	8b d6		 mov	 edx, esi
  000e6	c1 e2 04	 shl	 edx, 4
  000e9	03 d7		 add	 edx, edi
  000eb	0f 11 04 32	 movups	 XMMWORD PTR [edx+esi], xmm0
  000ef	8a 4c 08 10	 mov	 cl, BYTE PTR [eax+ecx+16]
  000f3	88 4c 32 10	 mov	 BYTE PTR [edx+esi+16], cl

; 5925 :         _Hole             = _Idx;

  000f7	8b f0		 mov	 esi, eax
  000f9	48		 dec	 eax
  000fa	d1 f8		 sar	 eax, 1
  000fc	3b de		 cmp	 ebx, esi
  000fe	7c d0		 jl	 SHORT $LL17@Make_heap_
$LN33@Make_heap_:

; 5926 :     }
; 5927 : 
; 5928 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00100	8a 4d ff	 mov	 cl, BYTE PTR __Val$1$[ebp]
  00103	8b c6		 mov	 eax, esi
  00105	c1 e0 04	 shl	 eax, 4
  00108	03 c7		 add	 eax, edi
  0010a	0f 11 0c 30	 movups	 XMMWORD PTR [eax+esi], xmm1
  0010e	88 4c 30 10	 mov	 BYTE PTR [eax+esi+16], cl

; 6196 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00112	8b 45 ec	 mov	 eax, DWORD PTR tv377[ebp]
  00115	8b 4d f8	 mov	 ecx, DWORD PTR __Max_sequence_non_leaf$1$[ebp]
  00118	85 db		 test	 ebx, ebx
  0011a	0f 8f 13 ff ff
	ff		 jg	 $LL2@Make_heap_
  00120	5e		 pop	 esi
$LN3@Make_heap_:
  00121	5f		 pop	 edi

; 6201 :     }
; 6202 : }

  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
??$_Make_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ENDP ; std::_Make_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Sort_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Val$1 = -20						; size = 17
__Pred$ = 8						; size = 1
??$_Sort_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z PROC ; std::_Sort_heap_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6414 : _CONSTEXPR20 void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx

; 6415 :     // order heap by repeatedly popping
; 6416 :     for (; _Last - _First >= 2; --_Last) {

  0000a	8b f2		 mov	 esi, edx
  0000c	2b f3		 sub	 esi, ebx
  0000e	83 fe 22	 cmp	 esi, 34			; 00000022H
  00011	7c 55		 jl	 SHORT $LN3@Sort_heap_
  00013	57		 push	 edi
  00014	8d 7a ef	 lea	 edi, DWORD PTR [edx-17]
$LL4@Sort_heap_:

; 6069 :     if (2 <= _Last - _First) {

  00017	b8 f1 f0 f0 f0	 mov	 eax, -252645135		; f0f0f0f1H
  0001c	f7 e6		 mul	 esi
  0001e	8b f7		 mov	 esi, edi
  00020	c1 ea 04	 shr	 edx, 4
  00023	2b f3		 sub	 esi, ebx
  00025	83 fa 02	 cmp	 edx, 2
  00028	7c 35		 jl	 SHORT $LN2@Sort_heap_

; 6070 :         --_Last;
; 6071 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  0002a	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  0002d	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]

; 6062 :     _Pop_heap_hole_by_index(

  00031	33 d2		 xor	 edx, edx
  00033	ff 75 08	 push	 DWORD PTR __Pred$[ebp]

; 6071 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00036	0f 11 45 ec	 movups	 XMMWORD PTR __Val$1[ebp], xmm0
  0003a	88 45 fc	 mov	 BYTE PTR __Val$1[ebp+16], al

; 6062 :     _Pop_heap_hole_by_index(

  0003d	8b cb		 mov	 ecx, ebx
  0003f	0f 10 03	 movups	 xmm0, XMMWORD PTR [ebx]
  00042	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  00045	0f b6 43 10	 movzx	 eax, BYTE PTR [ebx+16]
  00049	88 47 10	 mov	 BYTE PTR [edi+16], al
  0004c	8d 45 ec	 lea	 eax, DWORD PTR __Val$1[ebp]
  0004f	50		 push	 eax
  00050	69 c6 f1 f0 f0
	f0		 imul	 eax, esi, -252645135
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Sort_heap_:

; 6415 :     // order heap by repeatedly popping
; 6416 :     for (; _Last - _First >= 2; --_Last) {

  0005f	83 ef 11	 sub	 edi, 17			; 00000011H
  00062	83 fe 22	 cmp	 esi, 34			; 00000022H
  00065	7d b0		 jge	 SHORT $LL4@Sort_heap_
  00067	5f		 pop	 edi
$LN3@Sort_heap_:
  00068	5e		 pop	 esi

; 6417 :         _Pop_heap_unchecked(_First, _Last, _Pred);
; 6418 :     }
; 6419 : }

  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
??$_Sort_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ENDP ; std::_Sort_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -16					; size = 4
tv616 = -12						; size = 4
__Gfirst$1$ = -8					; size = 4
tv556 = -8						; size = 4
__First$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Glast$1$ = 12						; size = 4
__Pred$ = 12						; size = 1
??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z PROC ; std::_Partition_by_median_guess_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; ___$ReturnUdt$ = ecx
; __First$ = edx

; 7565 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b da		 mov	 ebx, edx
  00009	89 4d f0	 mov	 DWORD PTR ___$ReturnUdt$1$[ebp], ecx

; 7566 :     // partition [_First, _Last)
; 7567 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000f	8b c1		 mov	 eax, ecx
  00011	2b c3		 sub	 eax, ebx
  00013	89 5d fc	 mov	 DWORD PTR __First$1$[ebp], ebx
  00016	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135

; 7568 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0001c	83 c1 ef	 add	 ecx, -17		; ffffffefH
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	89 4d f8	 mov	 DWORD PTR tv556[ebp], ecx
  00024	d1 f8		 sar	 eax, 1
  00026	8b f0		 mov	 esi, eax
  00028	c1 e6 04	 shl	 esi, 4
  0002b	03 f3		 add	 esi, ebx
  0002d	03 f0		 add	 esi, eax

; 7551 :     const _Diff _Count = _Last - _First;

  0002f	8b c1		 mov	 eax, ecx
  00031	2b c3		 sub	 eax, ebx
  00033	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135

; 7552 :     if (40 < _Count) { // Tukey's ninther

  00039	83 f8 28	 cmp	 eax, 40			; 00000028H
  0003c	7e 65		 jle	 SHORT $LN81@Partition_

; 7553 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0003e	40		 inc	 eax
  0003f	c1 f8 03	 sar	 eax, 3

; 7554 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 7555 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00042	8b f8		 mov	 edi, eax
  00044	8b d0		 mov	 edx, eax
  00046	c1 e7 04	 shl	 edi, 4
  00049	03 f8		 add	 edi, eax
  0004b	c1 e2 04	 shl	 edx, 4
  0004e	03 d0		 add	 edx, eax
  00050	8b 45 fc	 mov	 eax, DWORD PTR __First$1$[ebp]
  00053	03 d2		 add	 edx, edx
  00055	03 c2		 add	 eax, edx
  00057	89 55 f4	 mov	 DWORD PTR tv616[ebp], edx
  0005a	8d 0c 1f	 lea	 ecx, DWORD PTR [edi+ebx]
  0005d	8b 5d 0c	 mov	 ebx, DWORD PTR __Pred$[ebp]
  00060	53		 push	 ebx
  00061	8b d1		 mov	 edx, ecx
  00063	8b 4d fc	 mov	 ecx, DWORD PTR __First$1$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7556 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  0006c	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0006f	8b ce		 mov	 ecx, esi
  00071	53		 push	 ebx
  00072	50		 push	 eax
  00073	2b cf		 sub	 ecx, edi
  00075	8b d6		 mov	 edx, esi
  00077	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7557 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  0007c	8b 45 f8	 mov	 eax, DWORD PTR tv556[ebp]
  0007f	8b d0		 mov	 edx, eax
  00081	53		 push	 ebx
  00082	50		 push	 eax
  00083	2b 45 f4	 sub	 eax, DWORD PTR tv616[ebp]
  00086	2b d7		 sub	 edx, edi
  00088	8b c8		 mov	 ecx, eax
  0008a	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7558 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  0008f	53		 push	 ebx
  00090	8b 5d fc	 mov	 ebx, DWORD PTR __First$1$[ebp]
  00093	52		 push	 edx
  00094	8b d6		 mov	 edx, esi
  00096	8d 0c 1f	 lea	 ecx, DWORD PTR [edi+ebx]
  00099	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
  0009e	83 c4 20	 add	 esp, 32			; 00000020H

; 7559 :     } else {

  000a1	eb 10		 jmp	 SHORT $LN82@Partition_
$LN81@Partition_:

; 7560 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

  000a3	ff 75 0c	 push	 DWORD PTR __Pred$[ebp]
  000a6	8b d6		 mov	 edx, esi
  000a8	51		 push	 ecx
  000a9	8b cb		 mov	 ecx, ebx
  000ab	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
  000b0	83 c4 08	 add	 esp, 8
$LN82@Partition_:

; 7569 :     _RanIt _Pfirst = _Mid;
; 7570 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  000b3	8d 7e 11	 lea	 edi, DWORD PTR [esi+17]

; 7573 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000b6	3b de		 cmp	 ebx, esi
  000b8	73 17		 jae	 SHORT $LN110@Partition_
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL2@Partition_:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000c0	8a 46 ff	 mov	 al, BYTE PTR [esi-1]
  000c3	3a 46 10	 cmp	 al, BYTE PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7573 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000c6	72 09		 jb	 SHORT $LN110@Partition_
  000c8	77 07		 ja	 SHORT $LN110@Partition_

; 7574 :         --_Pfirst;

  000ca	83 ee 11	 sub	 esi, 17			; 00000011H
  000cd	3b de		 cmp	 ebx, esi
  000cf	72 ef		 jb	 SHORT $LL2@Partition_
$LN110@Partition_:

; 7577 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000d1	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  000d4	3b f9		 cmp	 edi, ecx
  000d6	73 16		 jae	 SHORT $LN111@Partition_
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  000d8	8a 56 10	 mov	 dl, BYTE PTR [esi+16]
  000db	0f 1f 44 00 00	 npad	 5
$LL4@Partition_:
  000e0	38 57 10	 cmp	 BYTE PTR [edi+16], dl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7577 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000e3	72 09		 jb	 SHORT $LN111@Partition_
  000e5	77 07		 ja	 SHORT $LN111@Partition_

; 7578 :         ++_Plast;

  000e7	83 c7 11	 add	 edi, 17			; 00000011H
  000ea	3b f9		 cmp	 edi, ecx
  000ec	72 f2		 jb	 SHORT $LL4@Partition_
$LN111@Partition_:

; 7579 :     }
; 7580 : 
; 7581 :     _RanIt _Gfirst = _Plast;
; 7582 :     _RanIt _Glast  = _Pfirst;

  000ee	8b c6		 mov	 eax, esi
  000f0	8b d7		 mov	 edx, edi
  000f2	89 45 0c	 mov	 DWORD PTR __Glast$1$[ebp], eax
$LN115@Partition_:

; 7585 :         for (; _Gfirst < _Last; ++_Gfirst) {

  000f5	89 55 f8	 mov	 DWORD PTR __Gfirst$1$[ebp], edx
$LL6@Partition_:
  000f8	3b d1		 cmp	 edx, ecx
  000fa	73 44		 jae	 SHORT $LN90@Partition_
  000fc	0f 1f 40 00	 npad	 4
$LL11@Partition_:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00100	8a 46 10	 mov	 al, BYTE PTR [esi+16]
  00103	8a 4a 10	 mov	 cl, BYTE PTR [edx+16]
  00106	3a c1		 cmp	 al, cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7586 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  00108	72 23		 jb	 SHORT $LN9@Partition_
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0010a	3a c8		 cmp	 cl, al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7588 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  0010c	72 29		 jb	 SHORT $LN112@Partition_

; 7589 :                 break;
; 7590 :             } else if (_Plast != _Gfirst) {

  0010e	3b fa		 cmp	 edi, edx
  00110	74 18		 je	 SHORT $LN19@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  00112	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00115	8a 4f 10	 mov	 cl, BYTE PTR [edi+16]
  00118	0f 10 0f	 movups	 xmm1, XMMWORD PTR [edi]
  0011b	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0011e	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  00121	88 47 10	 mov	 BYTE PTR [edi+16], al

; 102  :     _Right   = _STD move(_Tmp);

  00124	0f 11 0a	 movups	 XMMWORD PTR [edx], xmm1
  00127	88 4a 10	 mov	 BYTE PTR [edx+16], cl
$LN19@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7585 :         for (; _Gfirst < _Last; ++_Gfirst) {

  0012a	83 c7 11	 add	 edi, 17			; 00000011H
$LN9@Partition_:
  0012d	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  00130	83 c2 11	 add	 edx, 17			; 00000011H
  00133	3b d1		 cmp	 edx, ecx
  00135	72 c9		 jb	 SHORT $LL11@Partition_
$LN112@Partition_:
  00137	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
  0013a	8b 5d fc	 mov	 ebx, DWORD PTR __First$1$[ebp]
  0013d	89 55 f8	 mov	 DWORD PTR __Gfirst$1$[ebp], edx
$LN90@Partition_:

; 7598 :         for (; _First < _Glast; --_Glast) {

  00140	3b c3		 cmp	 eax, ebx
  00142	76 51		 jbe	 SHORT $LN114@Partition_
  00144	8b 55 fc	 mov	 edx, DWORD PTR __First$1$[ebp]
  00147	8d 58 ef	 lea	 ebx, DWORD PTR [eax-17]
  0014a	66 0f 1f 44 00
	00		 npad	 6
$LL14@Partition_:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00150	8a 4b 10	 mov	 cl, BYTE PTR [ebx+16]
  00153	8a 6e 10	 mov	 ch, BYTE PTR [esi+16]
  00156	3a cd		 cmp	 cl, ch
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7599 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  00158	72 26		 jb	 SHORT $LN12@Partition_
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0015a	3a e9		 cmp	 ch, cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7601 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  0015c	72 2f		 jb	 SHORT $LN113@Partition_

; 7602 :                 break;
; 7603 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  0015e	83 ee 11	 sub	 esi, 17			; 00000011H
  00161	3b f3		 cmp	 esi, ebx
  00163	74 1b		 je	 SHORT $LN12@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  00165	0f 10 03	 movups	 xmm0, XMMWORD PTR [ebx]
  00168	8a 4e 10	 mov	 cl, BYTE PTR [esi+16]
  0016b	0f 10 0e	 movups	 xmm1, XMMWORD PTR [esi]
  0016e	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00171	8a 43 10	 mov	 al, BYTE PTR [ebx+16]
  00174	88 46 10	 mov	 BYTE PTR [esi+16], al
  00177	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]

; 102  :     _Right   = _STD move(_Tmp);

  0017a	0f 11 0b	 movups	 XMMWORD PTR [ebx], xmm1
  0017d	88 4b 10	 mov	 BYTE PTR [ebx+16], cl
$LN12@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7598 :         for (; _First < _Glast; --_Glast) {

  00180	83 e8 11	 sub	 eax, 17			; 00000011H
  00183	83 eb 11	 sub	 ebx, 17			; 00000011H
  00186	89 45 0c	 mov	 DWORD PTR __Glast$1$[ebp], eax
  00189	3b d0		 cmp	 edx, eax
  0018b	72 c3		 jb	 SHORT $LL14@Partition_
$LN113@Partition_:
  0018d	8b 5d fc	 mov	 ebx, DWORD PTR __First$1$[ebp]

; 7604 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7605 :             }
; 7606 :         }
; 7607 : 
; 7608 :         if (_Glast == _First && _Gfirst == _Last) {

  00190	3b c3		 cmp	 eax, ebx
  00192	8b 55 f8	 mov	 edx, DWORD PTR __Gfirst$1$[ebp]
$LN114@Partition_:
  00195	75 51		 jne	 SHORT $LN27@Partition_
  00197	3b 55 08	 cmp	 edx, DWORD PTR __Last$[ebp]
  0019a	0f 84 c8 00 00
	00		 je	 $LN92@Partition_

; 7610 :         }
; 7611 : 
; 7612 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7613 :             if (_Plast != _Gfirst) {

  001a0	3b fa		 cmp	 edi, edx
  001a2	74 18		 je	 SHORT $LN47@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  001a4	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  001a7	8a 4e 10	 mov	 cl, BYTE PTR [esi+16]
  001aa	0f 10 0e	 movups	 xmm1, XMMWORD PTR [esi]
  001ad	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  001b0	8a 47 10	 mov	 al, BYTE PTR [edi+16]
  001b3	88 46 10	 mov	 BYTE PTR [esi+16], al

; 102  :     _Right   = _STD move(_Tmp);

  001b6	0f 11 0f	 movups	 XMMWORD PTR [edi], xmm1
  001b9	88 4f 10	 mov	 BYTE PTR [edi+16], cl
$LN47@Partition_:

; 101  :     _Left    = _STD move(_Right);

  001bc	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  001bf	8a 4e 10	 mov	 cl, BYTE PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7617 :             ++_Plast;

  001c2	83 c7 11	 add	 edi, 17			; 00000011H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

  001c5	0f 10 0e	 movups	 xmm1, XMMWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

  001c8	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  001cb	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  001ce	88 46 10	 mov	 BYTE PTR [esi+16], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7619 :             ++_Pfirst;

  001d1	83 c6 11	 add	 esi, 17			; 00000011H

; 7620 :             ++_Gfirst;

  001d4	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 102  :     _Right   = _STD move(_Tmp);

  001d7	0f 11 0a	 movups	 XMMWORD PTR [edx], xmm1
  001da	88 4a 10	 mov	 BYTE PTR [edx+16], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7620 :             ++_Gfirst;

  001dd	83 c2 11	 add	 edx, 17			; 00000011H
  001e0	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  001e3	e9 0d ff ff ff	 jmp	 $LN115@Partition_
$LN27@Partition_:

; 7621 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  001e8	83 c0 ef	 add	 eax, -17		; ffffffefH
  001eb	89 45 0c	 mov	 DWORD PTR __Glast$1$[ebp], eax
  001ee	3b 55 08	 cmp	 edx, DWORD PTR __Last$[ebp]
  001f1	75 4c		 jne	 SHORT $LN30@Partition_

; 7622 :             if (--_Glast != --_Pfirst) {

  001f3	83 ee 11	 sub	 esi, 17			; 00000011H
  001f6	3b c6		 cmp	 eax, esi
  001f8	74 1e		 je	 SHORT $LN65@Partition_
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  001fa	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  001fd	8a 48 10	 mov	 cl, BYTE PTR [eax+16]
  00200	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  00203	8b 5d 0c	 mov	 ebx, DWORD PTR __Glast$1$[ebp]
  00206	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00209	8a 46 10	 mov	 al, BYTE PTR [esi+16]
  0020c	88 43 10	 mov	 BYTE PTR [ebx+16], al
  0020f	8b 5d fc	 mov	 ebx, DWORD PTR __First$1$[ebp]

; 102  :     _Right   = _STD move(_Tmp);

  00212	0f 11 0e	 movups	 XMMWORD PTR [esi], xmm1
  00215	88 4e 10	 mov	 BYTE PTR [esi+16], cl
$LN65@Partition_:

; 101  :     _Left    = _STD move(_Right);

  00218	0f 10 47 ef	 movups	 xmm0, XMMWORD PTR [edi-17]
  0021c	8a 4e 10	 mov	 cl, BYTE PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7626 :             _STD iter_swap(_Pfirst, --_Plast);

  0021f	83 ef 11	 sub	 edi, 17			; 00000011H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 100  :     _Ty _Tmp = _STD move(_Left);

  00222	0f 10 0e	 movups	 xmm1, XMMWORD PTR [esi]

; 101  :     _Left    = _STD move(_Right);

  00225	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00228	8a 47 10	 mov	 al, BYTE PTR [edi+16]
  0022b	88 46 10	 mov	 BYTE PTR [esi+16], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7627 :         } else {

  0022e	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 102  :     _Right   = _STD move(_Tmp);

  00231	0f 11 0f	 movups	 XMMWORD PTR [edi], xmm1
  00234	88 4f 10	 mov	 BYTE PTR [edi+16], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7627 :         } else {

  00237	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  0023a	e9 b9 fe ff ff	 jmp	 $LL6@Partition_
$LN30@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  0023f	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00242	8a 4a 10	 mov	 cl, BYTE PTR [edx+16]
  00245	0f 10 0a	 movups	 xmm1, XMMWORD PTR [edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7628 :             _STD iter_swap(_Gfirst, --_Glast);

  00248	89 45 0c	 mov	 DWORD PTR __Glast$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  0024b	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0024e	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  00251	88 42 10	 mov	 BYTE PTR [edx+16], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7629 :             ++_Gfirst;

  00254	83 c2 11	 add	 edx, 17			; 00000011H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 102  :     _Right   = _STD move(_Tmp);

  00257	8b 45 0c	 mov	 eax, DWORD PTR __Glast$1$[ebp]
  0025a	0f 11 08	 movups	 XMMWORD PTR [eax], xmm1
  0025d	88 48 10	 mov	 BYTE PTR [eax+16], cl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7631 :     }

  00260	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  00263	e9 8d fe ff ff	 jmp	 $LN115@Partition_
$LN92@Partition_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00268	8b 45 f0	 mov	 eax, DWORD PTR ___$ReturnUdt$1$[ebp]
  0026b	89 78 04	 mov	 DWORD PTR [eax+4], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7609 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  0026e	5f		 pop	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  0026f	89 30		 mov	 DWORD PTR [eax], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7609 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  00271	5e		 pop	 esi
  00272	5b		 pop	 ebx

; 7632 : }

  00273	8b e5		 mov	 esp, ebp
  00275	5d		 pop	 ebp
  00276	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YA?AU?$pair@PAUSShopItemTable@@PAU1@@0@PAUSShopItemTable@@0UItemStockSortFunc@@@Z ENDP ; std::_Partition_by_median_guess_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Construct_in_place@USShopItemTable@@ABU1@@std@@YAXAAUSShopItemTable@@ABU1@@Z
_TEXT	SEGMENT
??$_Construct_in_place@USShopItemTable@@ABU1@@std@@YAXAAUSShopItemTable@@ABU1@@Z PROC ; std::_Construct_in_place<SShopItemTable,SShopItemTable const &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 225  : #if _HAS_CXX20
; 226  :     if (_STD is_constant_evaluated()) {
; 227  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 228  :     } else
; 229  : #endif // _HAS_CXX20
; 230  :     {
; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00003	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00006	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  00009	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 232  :     }
; 233  : }

  0000c	c3		 ret	 0
??$_Construct_in_place@USShopItemTable@@ABU1@@std@@YAXAAUSShopItemTable@@ABU1@@Z ENDP ; std::_Construct_in_place<SShopItemTable,SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$construct@USShopItemTable@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@ABU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USShopItemTable@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable const &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 673  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 674  : #if _HAS_CXX20
; 675  :         if (_STD is_constant_evaluated()) {
; 676  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 677  :         } else
; 678  : #endif // _HAS_CXX20
; 679  :         {
; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00009	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0000c	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  0000f	88 42 10	 mov	 BYTE PTR [edx+16], al

; 681  :         }
; 682  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$construct@USShopItemTable@@ABU1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z
_TEXT	SEGMENT
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>, COMDAT
; __Obj$dead$ = ecx

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$to_address@USShopItemTable@@@std@@YAPAUSShopItemTable@@QAU1@@Z
_TEXT	SEGMENT
??$to_address@USShopItemTable@@@std@@YAPAUSShopItemTable@@QAU1@@Z PROC ; std::to_address<SShopItemTable>, COMDAT
; __Val$ = ecx

; 290  :     static_assert(!is_function_v<_Ty>,
; 291  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 292  :     return _Val;

  00000	8b c1		 mov	 eax, ecx

; 293  : }

  00002	c3		 ret	 0
??$to_address@USShopItemTable@@@std@@YAPAUSShopItemTable@@QAU1@@Z ENDP ; std::to_address<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@USShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z
_TEXT	SEGMENT
??$forward@USShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z PROC ; std::forward<SShopItemTable>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@USShopItemTable@@@std@@YA$$QAUSShopItemTable@@AAU1@@Z ENDP ; std::forward<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$construct@USShopItemTable@@U1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@$$QAU3@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@USShopItemTable@@U1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@$$QAU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 673  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 674  : #if _HAS_CXX20
; 675  :         if (_STD is_constant_evaluated()) {
; 676  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 677  :         } else
; 678  : #endif // _HAS_CXX20
; 679  :         {
; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00009	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  0000c	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  0000f	88 42 10	 mov	 BYTE PTR [edx+16], al

; 681  :         }
; 682  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$construct@USShopItemTable@@U1@@?$_Default_allocator_traits@V?$allocator@USShopItemTable@@@std@@@std@@SAXAAV?$allocator@USShopItemTable@@@1@QAUSShopItemTable@@$$QAU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<SShopItemTable> >::construct<SShopItemTable,SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$addressof@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>, COMDAT
; __Val$ = ecx

; 281  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 282  : }

  00002	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@ABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
??$forward@ABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@ABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@$0A@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@ABQAU10@@Z
_TEXT	SEGMENT
??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@$0A@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@ABQAU10@@Z PROC ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &,0>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 218  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax
  00004	8b c1		 mov	 eax, ecx

; 219  : }

  00006	c3		 ret	 0
??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@ABQAU12@$0A@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@ABQAU10@@Z ENDP ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z PROC ; std::_Voidify_iter<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * *>, COMDAT
; __It$ = ecx

; 201  :     if constexpr (is_pointer_v<_Iter>) {
; 202  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00000	8b c1		 mov	 eax, ecx

; 203  :     } else {
; 204  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 205  :     }
; 206  : }

  00002	c3		 ret	 0
??$_Voidify_iter@PAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YAPAXPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@@Z ENDP ; std::_Voidify_iter<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$destroy_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAXQAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
??$destroy_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAXQAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z PROC ; std::destroy_at<std::pair<SItemPos const ,SShopItemTable> >, COMDAT
; __Location$dead$ = ecx

; 305  : #if _HAS_CXX20
; 306  :     if constexpr (is_array_v<_Ty>) {
; 307  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 308  :     } else
; 309  : #endif // _HAS_CXX20
; 310  :     {
; 311  :         _Location->~_Ty();
; 312  :     }
; 313  : }

  00000	c2 00 00	 ret	 0
??$destroy_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAXQAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z ENDP ; std::destroy_at<std::pair<SItemPos const ,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@USItemPos@@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@SAABUSItemPos@@ABU?$pair@USItemPos@@USShopItemTable@@@2@@Z
_TEXT	SEGMENT
?_Extract@?$_In_place_key_extract_map@USItemPos@@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@SAABUSItemPos@@ABU?$pair@USItemPos@@USShopItemTable@@@2@@Z PROC ; std::_In_place_key_extract_map<SItemPos,std::pair<SItemPos,SShopItemTable> >::_Extract, COMDAT
; __Val$ = ecx

; 1974 :         return _Val.first;

  00000	8b c1		 mov	 eax, ecx

; 1975 :     }

  00002	c3		 ret	 0
?_Extract@?$_In_place_key_extract_map@USItemPos@@U?$pair@USItemPos@@USShopItemTable@@@std@@@std@@SAABUSItemPos@@ABU?$pair@USItemPos@@USShopItemTable@@@2@@Z ENDP ; std::_In_place_key_extract_map<SItemPos,std::pair<SItemPos,SShopItemTable> >::_Extract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1017 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN14@Tree_temp_

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 24		 push	 36			; 00000024H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN14@Tree_temp_:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 825  :     }

  00012	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Release, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 653  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 654  :     _Val         = static_cast<_Other&&>(_New_val);

  00003	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1009 :     }

  0000a	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node, COMDAT
; _this$ = ecx

; 646  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 647  :         ++_Mysize;
; 648  :         const auto _Head  = _Myhead;
; 649  :         _Newnode->_Parent = _Loc._Parent;

  00004	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0000e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00010	ff 43 04	 inc	 DWORD PTR [ebx+4]
  00013	89 45 fc	 mov	 DWORD PTR __Head$1$[ebp], eax
  00016	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 650  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00019	3b d0		 cmp	 edx, eax
  0001b	75 16		 jne	 SHORT $LN5@Insert_nod

; 651  :             _Head->_Left     = _Newnode;

  0001d	89 38		 mov	 DWORD PTR [eax], edi

; 652  :             _Head->_Parent   = _Newnode;

  0001f	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 653  :             _Head->_Right    = _Newnode;

  00022	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 712  :         return _Newnode;
; 713  :     }

  00025	8b c7		 mov	 eax, edi
  00027	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  0002b	5f		 pop	 edi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 654  :             _Newnode->_Color = _Black; // the root is black
; 655  :             return _Newnode;
; 656  :         }
; 657  : 
; 658  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 659  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00033	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00037	75 0d		 jne	 SHORT $LN6@Insert_nod

; 660  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 661  :             _Loc._Parent->_Right = _Newnode;

  00039	89 7a 08	 mov	 DWORD PTR [edx+8], edi

; 662  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003c	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003f	75 0d		 jne	 SHORT $LN9@Insert_nod

; 663  :                 _Head->_Right = _Newnode;

  00041	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 664  :             }
; 665  :         } else { // add to left of _Loc._Parent

  00044	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 666  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 667  :             _Loc._Parent->_Left = _Newnode;

  00046	89 3a		 mov	 DWORD PTR [edx], edi

; 668  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00048	3b 10		 cmp	 edx, DWORD PTR [eax]
  0004a	75 02		 jne	 SHORT $LN9@Insert_nod

; 669  :                 _Head->_Left = _Newnode;

  0004c	89 38		 mov	 DWORD PTR [eax], edi
$LN9@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00051	8b c7		 mov	 eax, edi
  00053	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00057	0f 85 7d 01 00
	00		 jne	 $LN3@Insert_nod
  0005d	56		 push	 esi
  0005e	66 90		 npad	 2
$LL2@Insert_nod:

; 674  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00063	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	3b d1		 cmp	 edx, ecx
  0006a	0f 85 aa 00 00
	00		 jne	 $LN10@Insert_nod

; 675  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 676  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00073	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00077	0f 84 a3 00 00
	00		 je	 $LN54@Insert_nod

; 677  :                     _Pnode->_Parent->_Color          = _Black;
; 678  :                     _Parent_sibling->_Color          = _Black;
; 679  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 680  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 681  :                 } else { // parent's sibling has red and black children
; 682  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0007d	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00080	3b c6		 cmp	 eax, esi
  00082	75 37		 jne	 SHORT $LN51@Insert_nod

; 462  :         _Wherenode->_Right = _Pnode->_Left;

  00084	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 683  :                         _Pnode = _Pnode->_Parent;

  00086	8b c2		 mov	 eax, edx

; 462  :         _Wherenode->_Right = _Pnode->_Left;

  00088	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

  0008b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00091	75 03		 jne	 SHORT $LN34@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

  00093	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN34@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

  00096	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00099	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

  0009c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0009e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000a1	75 05		 jne	 SHORT $LN35@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

  000a3	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000a6	eb 0e		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000a8	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000ab	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000ad	75 04		 jne	 SHORT $LN37@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

  000af	89 31		 mov	 DWORD PTR [ecx], esi

; 474  :         } else {

  000b1	eb 03		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

  000b3	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN38@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

  000b6	89 06		 mov	 DWORD PTR [esi], eax

; 479  :         _Wherenode->_Parent = _Pnode;

  000b8	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN51@Insert_nod:

; 684  :                         _Lrotate(_Pnode);
; 685  :                     }
; 686  : 
; 687  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 688  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c8	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 689  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000d2	8b 32		 mov	 esi, DWORD PTR [edx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

  000d4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d7	89 0a		 mov	 DWORD PTR [edx], ecx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

  000d9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000dc	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000e0	75 03		 jne	 SHORT $LN20@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

  000e2	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN20@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

  000e5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e8	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

  000eb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ed	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000f0	75 0b		 jne	 SHORT $LN21@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

  000f2	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  000f5	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

  000f8	e9 cc 00 00 00	 jmp	 $LN53@Insert_nod
$LN21@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  000fd	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00100	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00103	75 0b		 jne	 SHORT $LN23@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

  00105	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  00108	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

  0010b	e9 b9 00 00 00	 jmp	 $LN53@Insert_nod
$LN23@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

  00110	89 31		 mov	 DWORD PTR [ecx], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  00112	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

  00115	e9 af 00 00 00	 jmp	 $LN53@Insert_nod
$LN10@Insert_nod:

; 692  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 693  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  0011a	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0011e	75 1d		 jne	 SHORT $LN15@Insert_nod
$LN54@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00120	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1
  00124	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0012e	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00132	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00135	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00138	e9 8f 00 00 00	 jmp	 $LN32@Insert_nod
$LN15@Insert_nod:

; 694  :                     _Pnode->_Parent->_Color          = _Black;
; 695  :                     _Parent_sibling->_Color          = _Black;
; 696  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 697  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 698  :                 } else { // parent's sibling has red and black children
; 699  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  0013d	8b 32		 mov	 esi, DWORD PTR [edx]
  0013f	3b c6		 cmp	 eax, esi
  00141	75 3a		 jne	 SHORT $LN46@Insert_nod

; 484  :         _Wherenode->_Left = _Pnode->_Right;

  00143	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 700  :                         _Pnode = _Pnode->_Parent;

  00146	8b c2		 mov	 eax, edx

; 484  :         _Wherenode->_Left = _Pnode->_Right;

  00148	89 08		 mov	 DWORD PTR [eax], ecx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

  0014a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00151	75 03		 jne	 SHORT $LN41@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

  00153	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN41@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

  00156	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00159	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

  0015c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0015e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00161	75 05		 jne	 SHORT $LN42@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

  00163	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00166	eb 0f		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00168	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0016b	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0016e	75 05		 jne	 SHORT $LN44@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

  00170	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 496  :         } else {

  00173	eb 02		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

  00175	89 31		 mov	 DWORD PTR [ecx], esi
$LN45@Insert_nod:

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  00177	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 501  :         _Wherenode->_Parent = _Pnode;

  0017a	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN46@Insert_nod:

; 701  :                         _Rrotate(_Pnode);
; 702  :                     }
; 703  : 
; 704  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0017d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00180	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 705  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00184	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00187	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0018a	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 706  :                     _Lrotate(_Pnode->_Parent->_Parent);

  0018e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00191	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00194	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

  00197	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00199	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

  0019c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0019e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001a2	75 03		 jne	 SHORT $LN27@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

  001a4	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN27@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

  001a7	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001aa	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

  001ad	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001af	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001b2	75 05		 jne	 SHORT $LN28@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

  001b4	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  001b7	eb 0e		 jmp	 SHORT $LN31@Insert_nod
$LN28@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001b9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001bc	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001be	75 04		 jne	 SHORT $LN30@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

  001c0	89 31		 mov	 DWORD PTR [ecx], esi

; 474  :         } else {

  001c2	eb 03		 jmp	 SHORT $LN31@Insert_nod
$LN30@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

  001c4	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN31@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

  001c7	89 16		 mov	 DWORD PTR [esi], edx
$LN53@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001c9	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN32@Insert_nod:
  001cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001cf	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001d3	0f 84 87 fe ff
	ff		 je	 $LL2@Insert_nod
  001d9	5e		 pop	 esi
$LN3@Insert_nod:

; 707  :                 }
; 708  :             }
; 709  :         }
; 710  : 
; 711  :         _Head->_Parent->_Color = _Black; // root is always black

  001da	8b 45 fc	 mov	 eax, DWORD PTR __Head$1$[ebp]
  001dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e0	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 712  :         return _Newnode;
; 713  :     }

  001e4	8b c7		 mov	 eax, edi
  001e6	5f		 pop	 edi
  001e7	5b		 pop	 ebx
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1629 :         if (max_size() == _Get_scary()->_Mysize) {

  00000	81 79 04 c7 71
	1c 07		 cmp	 DWORD PTR [ecx+4], 119304647 ; 071c71c7H
  00007	0f 84 00 00 00
	00		 je	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error

; 1630 :             _Throw_tree_length_error();
; 1631 :         }
; 1632 :     }

  0000d	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 1017 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN10@Tree_temp_

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 24		 push	 36			; 00000024H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN10@Tree_temp_:
  00012	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 1017 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 255  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 24		 push	 36			; 00000024H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1018 :             _Al.deallocate(_Ptr, 1);
; 1019 :         }
; 1020 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::max_size, COMDAT
; _this$dead$ = ecx

; 1197 :         return (_STD min)(

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 1198 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1199 :     }

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 1963 :         return _Mypair._Myval2._Get_first();

  00000	8b c1		 mov	 eax, ecx

; 1964 :     }

  00002	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@USItemPos@@USShopItemTable@@U?$less@USItemPos@@@std@@V?$allocator@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@4@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<SItemPos,SShopItemTable,std::less<SItemPos>,std::allocator<std::pair<SItemPos const ,SShopItemTable> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::max_size, COMDAT
; ___formal$dead$ = ecx

; 694  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	b8 c7 71 1c 07	 mov	 eax, 119304647		; 071c71c7H

; 695  :     }

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1388 :         return *this;

  00000	8b c1		 mov	 eax, ecx

; 1389 :     }

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > ><std::pair<SItemPos,SShopItemTable> >, COMDAT
; _this$ = ecx

; 806  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
  0002f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  0003d	6a 24		 push	 36			; 00000024H

; 1012 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0003f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 77   :         return ::operator new(_Bytes);

  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0004b	8b 55 10	 mov	 edx, DWORD PTR _<_Vals_0>$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 235  :         return _Traits::_Allocate(_Bytes);

  0004e	8b f0		 mov	 esi, eax

; 1013 :         _Ptr = _Al.allocate(1);

  00050	89 77 04	 mov	 DWORD PTR [edi+4], esi

; 77   :         return ::operator new(_Bytes);

  00053	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00056	66 8b 0a	 mov	 cx, WORD PTR [edx]
  00059	66 89 4e 0e	 mov	 WORD PTR [esi+14], cx
  0005d	8a 4a 02	 mov	 cl, BYTE PTR [edx+2]
  00060	88 4e 10	 mov	 BYTE PTR [esi+16], cl
  00063	0f 10 42 03	 movups	 xmm0, XMMWORD PTR [edx+3]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00067	8b 4d 0c	 mov	 ecx, DWORD PTR __Myhead$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0006a	0f 11 46 11	 movups	 XMMWORD PTR [esi+17], xmm0
  0006e	8a 42 13	 mov	 al, BYTE PTR [edx+19]
  00071	88 46 21	 mov	 BYTE PTR [esi+33], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00074	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00077	89 08		 mov	 DWORD PTR [eax], ecx

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00079	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0007c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  0007f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00082	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 811  :         this->_Ptr->_Color = _Red;

  00085	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00088	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 812  :         this->_Ptr->_Isnil = false;

  0008c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0008f	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 813  :     }

  00093	8b c7		 mov	 eax, edi
  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@USItemPos@@USShopItemTable@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > ><std::pair<SItemPos,SShopItemTable> >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,bool,0>, COMDAT
; _this$ = ecx

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 173  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$?0PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool,0>, COMDAT
; _this$ = ecx

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]
  0000f	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 173  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool>::pair<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool><std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > > >, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<SItemPos const ,SShopItemTable> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move_backward_unchecked@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z PROC ; std::_Move_backward_unchecked<SShopItemTable *,SShopItemTable *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4241 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4250 :         }
; 4251 :     }
; 4252 : 
; 4253 :     while (_First != _Last) {
; 4254 :         *--_Dest = _STD move(*--_Last);
; 4255 :     }
; 4256 : 
; 4257 :     return _Dest;
; 4258 : }

  00003	5d		 pop	 ebp

; 4242 :     // move [_First, _Last) backwards to [..., _Dest)
; 4243 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4244 :     if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
; 4245 : #if _HAS_CXX20
; 4246 :         if (!_STD is_constant_evaluated())
; 4247 : #endif // _HAS_CXX20
; 4248 :         {
; 4249 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  00004	e9 00 00 00 00	 jmp	 ??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
??$_Move_backward_unchecked@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ENDP ; std::_Move_backward_unchecked<SShopItemTable *,SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Top$1$ = -4						; size = 4
__Bottom$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z PROC ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 6027 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 6028 :     // percolate _Hole to _Bottom, then push _Val
; 6029 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6030 : 
; 6031 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6032 :     const _Diff _Top = _Hole;
; 6033 :     _Diff _Idx       = _Hole;
; 6034 : 
; 6035 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6036 :     // calculating the child's index can trigger integer overflows
; 6037 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Bottom$[ebp]
  0000a	8b f2		 mov	 esi, edx
  0000c	4f		 dec	 edi
  0000d	89 75 fc	 mov	 DWORD PTR __Top$1$[ebp], esi
  00010	d1 ff		 sar	 edi, 1
  00012	8b d9		 mov	 ebx, ecx

; 6038 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  00014	3b f7		 cmp	 esi, edi
  00016	7d 3e		 jge	 SHORT $LN3@Pop_heap_h
$LL2@Pop_heap_h:

; 6039 :         _Idx = 2 * _Idx + 2;

  00018	03 d2		 add	 edx, edx

; 6040 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  0001a	8b ca		 mov	 ecx, edx
  0001c	c1 e1 04	 shl	 ecx, 4
  0001f	03 cb		 add	 ecx, ebx

; 6041 :             --_Idx;
; 6042 :         }
; 6043 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00021	0f b6 44 0a 32	 movzx	 eax, BYTE PTR [edx+ecx+50]
  00026	3a 44 0a 21	 cmp	 al, BYTE PTR [edx+ecx+33]
  0002a	8b ce		 mov	 ecx, esi
  0002c	1b c0		 sbb	 eax, eax
  0002e	c1 e1 04	 shl	 ecx, 4
  00031	83 c0 02	 add	 eax, 2
  00034	03 cb		 add	 ecx, ebx
  00036	03 d0		 add	 edx, eax
  00038	8b c2		 mov	 eax, edx
  0003a	c1 e0 04	 shl	 eax, 4
  0003d	03 c3		 add	 eax, ebx
  0003f	0f 10 04 10	 movups	 xmm0, XMMWORD PTR [eax+edx]
  00043	0f 11 04 31	 movups	 XMMWORD PTR [ecx+esi], xmm0
  00047	0f b6 44 10 10	 movzx	 eax, BYTE PTR [eax+edx+16]
  0004c	88 44 31 10	 mov	 BYTE PTR [ecx+esi+16], al

; 6044 :         _Hole             = _Idx;

  00050	8b f2		 mov	 esi, edx
  00052	3b d7		 cmp	 edx, edi
  00054	7c c2		 jl	 SHORT $LL2@Pop_heap_h
$LN3@Pop_heap_h:

; 6045 :     }
; 6046 : 
; 6047 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00056	3b d7		 cmp	 edx, edi
  00058	75 2a		 jne	 SHORT $LN5@Pop_heap_h
  0005a	8b 55 08	 mov	 edx, DWORD PTR __Bottom$[ebp]
  0005d	f6 c2 01	 test	 dl, 1
  00060	75 22		 jne	 SHORT $LN5@Pop_heap_h

; 6048 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  00062	8b c2		 mov	 eax, edx
  00064	8b ce		 mov	 ecx, esi
  00066	c1 e0 04	 shl	 eax, 4
  00069	03 c3		 add	 eax, ebx
  0006b	c1 e1 04	 shl	 ecx, 4
  0006e	03 cb		 add	 ecx, ebx
  00070	0f 10 44 02 ef	 movups	 xmm0, XMMWORD PTR [edx+eax-17]
  00075	0f 11 04 31	 movups	 XMMWORD PTR [ecx+esi], xmm0
  00079	8a 44 02 ff	 mov	 al, BYTE PTR [edx+eax-1]
  0007d	88 44 31 10	 mov	 BYTE PTR [ecx+esi+16], al

; 6049 :         _Hole             = _Bottom - 1;

  00081	8d 72 ff	 lea	 esi, DWORD PTR [edx-1]
$LN5@Pop_heap_h:

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00084	39 75 fc	 cmp	 DWORD PTR __Top$1$[ebp], esi
  00087	7d 3d		 jge	 SHORT $LN24@Pop_heap_h
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL12@Pop_heap_h:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00090	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 5920 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00093	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00096	d1 f8		 sar	 eax, 1

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00098	8b f8		 mov	 edi, eax
  0009a	c1 e7 04	 shl	 edi, 4
  0009d	03 fb		 add	 edi, ebx
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0009f	8a 4c 07 10	 mov	 cl, BYTE PTR [edi+eax+16]
  000a3	3a 4a 10	 cmp	 cl, BYTE PTR [edx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000a6	73 1e		 jae	 SHORT $LN24@Pop_heap_h

; 5922 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5923 :         // move _Hole up to parent
; 5924 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  000a8	0f 10 04 07	 movups	 xmm0, XMMWORD PTR [edi+eax]
  000ac	8b d6		 mov	 edx, esi
  000ae	c1 e2 04	 shl	 edx, 4
  000b1	03 d3		 add	 edx, ebx
  000b3	0f 11 04 32	 movups	 XMMWORD PTR [edx+esi], xmm0
  000b7	8a 4c 07 10	 mov	 cl, BYTE PTR [edi+eax+16]
  000bb	88 4c 32 10	 mov	 BYTE PTR [edx+esi+16], cl

; 5925 :         _Hole             = _Idx;

  000bf	8b f0		 mov	 esi, eax
  000c1	39 45 fc	 cmp	 DWORD PTR __Top$1$[ebp], eax
  000c4	7c ca		 jl	 SHORT $LL12@Pop_heap_h
$LN24@Pop_heap_h:

; 5926 :     }
; 5927 : 
; 5928 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  000c6	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000c9	8b ce		 mov	 ecx, esi
  000cb	c1 e1 04	 shl	 ecx, 4
  000ce	03 cb		 add	 ecx, ebx
  000d0	5f		 pop	 edi
  000d1	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000d4	0f 11 04 31	 movups	 XMMWORD PTR [ecx+esi], xmm0
  000d8	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  000db	88 44 31 10	 mov	 BYTE PTR [ecx+esi+16], al
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx

; 6050 :     }
; 6051 : 
; 6052 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 6053 : }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ENDP ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Val$1 = -20						; size = 17
__Pred$ = 8						; size = 1
??$_Pop_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z PROC ; std::_Pop_heap_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6067 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6068 :     // pop *_First to *(_Last - 1) and reheap
; 6069 :     if (2 <= _Last - _First) {

  00003	8b c2		 mov	 eax, edx
  00005	83 ec 14	 sub	 esp, 20			; 00000014H
  00008	2b c1		 sub	 eax, ecx
  0000a	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
  00010	83 f8 02	 cmp	 eax, 2
  00013	7c 39		 jl	 SHORT $LN2@Pop_heap_u

; 6070 :         --_Last;
; 6071 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00015	0f 10 42 ef	 movups	 xmm0, XMMWORD PTR [edx-17]
  00019	0f b6 42 ff	 movzx	 eax, BYTE PTR [edx-1]
  0001d	83 ea 11	 sub	 edx, 17			; 00000011H

; 6062 :     _Pop_heap_hole_by_index(

  00020	ff 75 08	 push	 DWORD PTR __Pred$[ebp]

; 6070 :         --_Last;
; 6071 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00023	0f 11 45 ec	 movups	 XMMWORD PTR __Val$1[ebp], xmm0
  00027	88 45 fc	 mov	 BYTE PTR __Val$1[ebp+16], al

; 6060 :     *_Dest      = _STD move(*_First);

  0002a	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  0002d	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00030	0f b6 41 10	 movzx	 eax, BYTE PTR [ecx+16]
  00034	88 42 10	 mov	 BYTE PTR [edx+16], al

; 6061 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6062 :     _Pop_heap_hole_by_index(

  00037	8d 45 ec	 lea	 eax, DWORD PTR __Val$1[ebp]
  0003a	2b d1		 sub	 edx, ecx
  0003c	50		 push	 eax
  0003d	69 c2 f1 f0 f0
	f0		 imul	 eax, edx, -252645135
  00043	33 d2		 xor	 edx, edx
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Pop_heap_u:

; 6072 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6073 :     }
; 6074 : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
??$_Pop_heap_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@0UItemStockSortFunc@@@Z ENDP ; std::_Pop_heap_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Prev_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z
_TEXT	SEGMENT
??$_Prev_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z PROC ; std::_Prev_iter<SShopItemTable *>, COMDAT
; __First$ = ecx

; 1191 :     return --_First;

  00000	8d 41 ef	 lea	 eax, DWORD PTR [ecx-17]

; 1192 : }

  00003	c3		 ret	 0
??$_Prev_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ENDP ; std::_Prev_iter<SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z
_TEXT	SEGMENT
tv173 = -12						; size = 4
__First$1$ = -8						; size = 4
__Mid$1$ = -4						; size = 4
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Guess_median_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z PROC ; std::_Guess_median_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 7548 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f2		 mov	 esi, edx
  00009	8b d1		 mov	 edx, ecx

; 7549 :     // sort median element to middle
; 7550 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7551 :     const _Diff _Count = _Last - _First;

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	8b c1		 mov	 eax, ecx
  00010	2b c2		 sub	 eax, edx
  00012	89 75 fc	 mov	 DWORD PTR __Mid$1$[ebp], esi
  00015	69 c0 f1 f0 f0
	f0		 imul	 eax, eax, -252645135
  0001b	89 55 f8	 mov	 DWORD PTR __First$1$[ebp], edx

; 7552 :     if (40 < _Count) { // Tukey's ninther

  0001e	83 f8 28	 cmp	 eax, 40			; 00000028H
  00021	7e 68		 jle	 SHORT $LN2@Guess_medi

; 7553 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  00023	40		 inc	 eax
  00024	c1 f8 03	 sar	 eax, 3

; 7554 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit
; 7555 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00027	8b c8		 mov	 ecx, eax
  00029	8b f0		 mov	 esi, eax
  0002b	c1 e1 04	 shl	 ecx, 4
  0002e	03 c8		 add	 ecx, eax
  00030	c1 e6 04	 shl	 esi, 4
  00033	03 c9		 add	 ecx, ecx
  00035	03 f0		 add	 esi, eax
  00037	53		 push	 ebx
  00038	57		 push	 edi
  00039	8b 7d 0c	 mov	 edi, DWORD PTR __Pred$[ebp]
  0003c	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  0003f	89 4d f4	 mov	 DWORD PTR tv173[ebp], ecx
  00042	8b 4d f8	 mov	 ecx, DWORD PTR __First$1$[ebp]
  00045	8d 1c 16	 lea	 ebx, DWORD PTR [esi+edx]
  00048	57		 push	 edi
  00049	50		 push	 eax
  0004a	8b d3		 mov	 edx, ebx
  0004c	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7556 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00051	8b 55 fc	 mov	 edx, DWORD PTR __Mid$1$[ebp]
  00054	8b ca		 mov	 ecx, edx
  00056	57		 push	 edi
  00057	2b ce		 sub	 ecx, esi
  00059	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7557 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  00062	8b 45 08	 mov	 eax, DWORD PTR __Last$[ebp]
  00065	8b d0		 mov	 edx, eax
  00067	57		 push	 edi
  00068	50		 push	 eax
  00069	2b 45 f4	 sub	 eax, DWORD PTR tv173[ebp]
  0006c	2b d6		 sub	 edx, esi
  0006e	8b c8		 mov	 ecx, eax
  00070	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>

; 7558 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  00075	57		 push	 edi
  00076	52		 push	 edx
  00077	8b 55 fc	 mov	 edx, DWORD PTR __Mid$1$[ebp]
  0007a	8b cb		 mov	 ecx, ebx
  0007c	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
  00081	83 c4 20	 add	 esp, 32			; 00000020H
  00084	5f		 pop	 edi
  00085	5b		 pop	 ebx
  00086	5e		 pop	 esi

; 7561 :     }
; 7562 : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN2@Guess_medi:

; 7559 :     } else {
; 7560 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

  0008b	ff 75 0c	 push	 DWORD PTR __Pred$[ebp]
  0008e	8b d6		 mov	 edx, esi
  00090	51		 push	 ecx
  00091	8b 4d f8	 mov	 ecx, DWORD PTR __First$1$[ebp]
  00094	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
  00099	83 c4 08	 add	 esp, 8
  0009c	5e		 pop	 esi

; 7561 :     }
; 7562 : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
??$_Guess_median_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ENDP ; std::_Guess_median_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Next_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z
_TEXT	SEGMENT
??$_Next_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z PROC ; std::_Next_iter<SShopItemTable *>, COMDAT
; __First$ = ecx

; 1178 :     return ++_First;

  00000	8d 41 11	 lea	 eax, DWORD PTR [ecx+17]

; 1179 : }

  00003	c3		 ret	 0
??$_Next_iter@PAUSShopItemTable@@@std@@YAPAUSShopItemTable@@PAU1@@Z ENDP ; std::_Next_iter<SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$iter_swap@PAUSShopItemTable@@PAU1@@std@@YAXPAUSShopItemTable@@0@Z
_TEXT	SEGMENT
??$iter_swap@PAUSShopItemTable@@PAU1@@std@@YAXPAUSShopItemTable@@0@Z PROC ; std::iter_swap<SShopItemTable *,SShopItemTable *>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 101  :     _Left    = _STD move(_Right);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

  00003	53		 push	 ebx

; 100  :     _Ty _Tmp = _STD move(_Left);

  00004	8a 59 10	 mov	 bl, BYTE PTR [ecx+16]
  00007	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]

; 101  :     _Left    = _STD move(_Right);

  0000a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000d	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  00010	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 102  :     _Right   = _STD move(_Tmp);

  00013	0f 11 0a	 movups	 XMMWORD PTR [edx], xmm1
  00016	88 5a 10	 mov	 BYTE PTR [edx+16], bl
  00019	5b		 pop	 ebx

; 78   :     swap(*_Left, *_Right);
; 79   : }

  0001a	c3		 ret	 0
??$iter_swap@PAUSShopItemTable@@PAU1@@std@@YAXPAUSShopItemTable@@0@Z ENDP ; std::iter_swap<SShopItemTable *,SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$?0AAPAUSShopItemTable@@AAPAU0@$0A@@?$pair@PAUSShopItemTable@@PAU1@@std@@QAE@AAPAUSShopItemTable@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAUSShopItemTable@@AAPAU0@$0A@@?$pair@PAUSShopItemTable@@PAU1@@std@@QAE@AAPAUSShopItemTable@@0@Z PROC ; std::pair<SShopItemTable *,SShopItemTable *>::pair<SShopItemTable *,SShopItemTable *><SShopItemTable * &,SShopItemTable * &,0>, COMDAT
; _this$ = ecx

; 172  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 173  :     }

  00012	8b c1		 mov	 eax, ecx
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAPAUSShopItemTable@@AAPAU0@$0A@@?$pair@PAUSShopItemTable@@PAU1@@std@@QAE@AAPAUSShopItemTable@@0@Z ENDP ; std::pair<SShopItemTable *,SShopItemTable *>::pair<SShopItemTable *,SShopItemTable *><SShopItemTable * &,SShopItemTable * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
;	COMDAT ??$addressof@USShopItemTable@@@std@@YAPAUSShopItemTable@@AAU1@@Z
_TEXT	SEGMENT
??$addressof@USShopItemTable@@@std@@YAPAUSShopItemTable@@AAU1@@Z PROC ; std::addressof<SShopItemTable>, COMDAT
; __Val$ = ecx

; 281  :     return __builtin_addressof(_Val);

  00000	8b c1		 mov	 eax, ecx

; 282  : }

  00002	c3		 ret	 0
??$addressof@USShopItemTable@@@std@@YAPAUSShopItemTable@@AAU1@@Z ENDP ; std::addressof<SShopItemTable>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$construct_at@USShopItemTable@@ABU1@$0A@@std@@YAPAUSShopItemTable@@QAU1@ABU1@@Z
_TEXT	SEGMENT
??$construct_at@USShopItemTable@@ABU1@$0A@@std@@YAPAUSShopItemTable@@QAU1@ABU1@@Z PROC ; std::construct_at<SShopItemTable,SShopItemTable const &,0>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 218  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00003	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00006	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  00009	88 41 10	 mov	 BYTE PTR [ecx+16], al
  0000c	8b c1		 mov	 eax, ecx

; 219  : }

  0000e	c3		 ret	 0
??$construct_at@USShopItemTable@@ABU1@$0A@@std@@YAPAUSShopItemTable@@QAU1@ABU1@@Z ENDP ; std::construct_at<SShopItemTable,SShopItemTable const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Voidify_iter@PAUSShopItemTable@@@std@@YAPAXPAUSShopItemTable@@@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAUSShopItemTable@@@std@@YAPAXPAUSShopItemTable@@@Z PROC ; std::_Voidify_iter<SShopItemTable *>, COMDAT
; __It$ = ecx

; 201  :     if constexpr (is_pointer_v<_Iter>) {
; 202  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00000	8b c1		 mov	 eax, ecx

; 203  :     } else {
; 204  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 205  :     }
; 206  : }

  00002	c3		 ret	 0
??$_Voidify_iter@PAUSShopItemTable@@@std@@YAPAXPAUSShopItemTable@@@Z ENDP ; std::_Voidify_iter<SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$construct_at@USShopItemTable@@U1@$0A@@std@@YAPAUSShopItemTable@@QAU1@$$QAU1@@Z
_TEXT	SEGMENT
??$construct_at@USShopItemTable@@U1@$0A@@std@@YAPAUSShopItemTable@@QAU1@$$QAU1@@Z PROC ; std::construct_at<SShopItemTable,SShopItemTable,0>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 218  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00003	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00006	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  00009	88 41 10	 mov	 BYTE PTR [ecx+16], al
  0000c	8b c1		 mov	 eax, ecx

; 219  : }

  0000e	c3		 ret	 0
??$construct_at@USShopItemTable@@U1@$0A@@std@@YAPAUSShopItemTable@@QAU1@$$QAU1@@Z ENDP ; std::construct_at<SShopItemTable,SShopItemTable,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::nullptr_t>, COMDAT
; __Val$ = ecx
; __New_val$ = edx

; 652  :     // assign _New_val to _Val, return previous _Val
; 653  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 654  :     _Val         = static_cast<_Other&&>(_New_val);

  00002	8b 12		 mov	 edx, DWORD PTR [edx]
  00004	89 11		 mov	 DWORD PTR [ecx], edx

; 655  :     return _Old_val;
; 656  : }

  00006	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00029	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002c	89 06		 mov	 DWORD PTR [esi], eax
  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  0003c	6a 24		 push	 36			; 00000024H

; 1012 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 77   :         return ::operator new(_Bytes);

  00045	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1013 :         _Ptr = _Al.allocate(1);

  0004a	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 77   :         return ::operator new(_Bytes);

  0004d	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xtree

; 787  :     }

  00050	8b c6		 mov	 eax, esi
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1011 :     _CONSTEXPR20 void _Allocate() { // disengage *this, then allocate a new memory block

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 77   :         return ::operator new(_Bytes);

  00003	6a 24		 push	 36			; 00000024H

; 1012 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00005	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 77   :         return ::operator new(_Bytes);

  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 1013 :         _Ptr = _Al.allocate(1);

  00014	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00017	5e		 pop	 esi

; 1014 :     }

  00018	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >, COMDAT
; _this$ = ecx

; 1005 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::construct<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 673  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00006	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00009	66 89 02	 mov	 WORD PTR [edx], ax
  0000c	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  00010	88 42 02	 mov	 BYTE PTR [edx+2], al
  00013	0f 10 41 03	 movups	 xmm0, XMMWORD PTR [ecx+3]
  00017	0f 11 42 03	 movups	 XMMWORD PTR [edx+3], xmm0
  0001b	0f b6 41 13	 movzx	 eax, BYTE PTR [ecx+19]
  0001f	88 42 13	 mov	 BYTE PTR [edx+19], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 682  :     }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$construct@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@1@QAU?$pair@$$CBUSItemPos@@USShopItemTable@@@1@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> > >::construct<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@0@Z
_TEXT	SEGMENT
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>, COMDAT
; __Obj$ = ecx
; _<_Args_0>$ = edx

; 225  : #if _HAS_CXX20
; 226  :     if (_STD is_constant_evaluated()) {
; 227  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 228  :     } else
; 229  : #endif // _HAS_CXX20
; 230  :     {
; 231  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 232  :     }
; 233  : }

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax
  00004	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
??$forward@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z PROC ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 4146 : _CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4147 :     // implement copy_backward-like function as memmove
; 4148 :     auto _FirstPtr              = _To_address(_First);
; 4149 :     auto _LastPtr               = _To_address(_Last);
; 4150 :     auto _DestPtr               = _To_address(_Dest);
; 4151 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4152 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4153 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4154 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
; 4155 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	2b d1		 sub	 edx, ecx
  00008	52		 push	 edx
  00009	51		 push	 ecx
  0000a	2b c2		 sub	 eax, edx
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _memmove
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4156 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4157 :         return static_cast<_CtgIt2>(_Result);
; 4158 :     } else {
; 4159 :         return _Dest - (_LastPtr - _FirstPtr);
; 4160 :     }
; 4161 : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$_Copy_backward_memmove@PAUSShopItemTable@@PAU1@@std@@YAPAUSShopItemTable@@PAU1@00@Z ENDP ; std::_Copy_backward_memmove<SShopItemTable *,SShopItemTable *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Push_heap_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z PROC ; std::_Push_heap_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Hole$ = edx

; 5917 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f2		 mov	 esi, edx
  00007	8b d9		 mov	 ebx, ecx

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00009	39 75 08	 cmp	 DWORD PTR __Top$[ebp], esi
  0000c	7d 39		 jge	 SHORT $LN12@Push_heap_
  0000e	57		 push	 edi
  0000f	90		 npad	 1
$LL4@Push_heap_:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00010	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 5920 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00013	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00016	d1 f8		 sar	 eax, 1

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00018	8b f8		 mov	 edi, eax
  0001a	c1 e7 04	 shl	 edi, 4
  0001d	03 fb		 add	 edi, ebx
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0001f	8a 4c 07 10	 mov	 cl, BYTE PTR [edi+eax+16]
  00023	3a 4a 10	 cmp	 cl, BYTE PTR [edx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 5921 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00026	73 1e		 jae	 SHORT $LN13@Push_heap_

; 5922 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 5923 :         // move _Hole up to parent
; 5924 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00028	0f 10 04 07	 movups	 xmm0, XMMWORD PTR [edi+eax]
  0002c	8b d6		 mov	 edx, esi
  0002e	c1 e2 04	 shl	 edx, 4
  00031	03 d3		 add	 edx, ebx
  00033	0f 11 04 32	 movups	 XMMWORD PTR [edx+esi], xmm0
  00037	8a 4c 07 10	 mov	 cl, BYTE PTR [edi+eax+16]
  0003b	88 4c 32 10	 mov	 BYTE PTR [edx+esi+16], cl

; 5925 :         _Hole             = _Idx;

  0003f	8b f0		 mov	 esi, eax
  00041	39 45 08	 cmp	 DWORD PTR __Top$[ebp], eax
  00044	7c ca		 jl	 SHORT $LL4@Push_heap_
$LN13@Push_heap_:
  00046	5f		 pop	 edi
$LN12@Push_heap_:

; 5926 :     }
; 5927 : 
; 5928 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00047	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0004a	8b ce		 mov	 ecx, esi
  0004c	c1 e1 04	 shl	 ecx, 4
  0004f	03 cb		 add	 ecx, ebx
  00051	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00054	0f 11 04 31	 movups	 XMMWORD PTR [ecx+esi], xmm0
  00058	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  0005b	88 44 31 10	 mov	 BYTE PTR [ecx+esi+16], al
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx

; 5929 : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??$_Push_heap_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ENDP ; std::_Push_heap_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Pop_heap_hole_unchecked@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00$$QAU1@UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Val$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_hole_unchecked@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00$$QAU1@UItemStockSortFunc@@@Z PROC ; std::_Pop_heap_hole_unchecked<SShopItemTable *,SShopItemTable,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 6056 : _CONSTEXPR20 void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6057 :     // pop *_First to *_Dest and reheap
; 6058 :     // precondition: _First != _Last
; 6059 :     // precondition: _First != _Dest
; 6060 :     *_Dest      = _STD move(*_First);

  00003	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0000d	8a 41 10	 mov	 al, BYTE PTR [ecx+16]
  00010	88 46 10	 mov	 BYTE PTR [esi+16], al

; 6061 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6062 :     _Pop_heap_hole_by_index(

  00013	5e		 pop	 esi
  00014	2b d1		 sub	 edx, ecx
  00016	69 c2 f1 f0 f0
	f0		 imul	 eax, edx, -252645135
  0001c	89 45 08	 mov	 DWORD PTR __Dest$[ebp], eax
  0001f	33 d2		 xor	 edx, edx

; 6063 :         _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), _STD forward<_Ty>(_Val), _Pred);
; 6064 : }

  00021	5d		 pop	 ebp

; 6061 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6062 :     _Pop_heap_hole_by_index(

  00022	e9 00 00 00 00	 jmp	 ??$_Pop_heap_hole_by_index@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@HH$$QAU1@UItemStockSortFunc@@@Z ; std::_Pop_heap_hole_by_index<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
??$_Pop_heap_hole_unchecked@PAUSShopItemTable@@U1@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00$$QAU1@UItemStockSortFunc@@@Z ENDP ; std::_Pop_heap_hole_unchecked<SShopItemTable *,SShopItemTable,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Pred$ = 12						; size = 1
??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z PROC ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>, COMDAT
; __First$ = ecx
; __Mid$ = edx

; 7532 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00003	8a 42 10	 mov	 al, BYTE PTR [edx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7532 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00009	3a 46 10	 cmp	 al, BYTE PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7534 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0000c	73 17		 jae	 SHORT $LN13@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  0000e	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00011	8a c8		 mov	 cl, al
  00013	0f 10 0a	 movups	 xmm1, XMMWORD PTR [edx]
  00016	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00019	8a 46 10	 mov	 al, BYTE PTR [esi+16]
  0001c	88 42 10	 mov	 BYTE PTR [edx+16], al

; 102  :     _Right   = _STD move(_Tmp);

  0001f	0f 11 0e	 movups	 XMMWORD PTR [esi], xmm1
  00022	88 4e 10	 mov	 BYTE PTR [esi+16], cl
$LN13@Med3_unche:
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	8a 41 10	 mov	 al, BYTE PTR [ecx+16]
  0002b	3a 42 10	 cmp	 al, BYTE PTR [edx+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7538 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  0002e	73 34		 jae	 SHORT $LN23@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  00030	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00033	53		 push	 ebx
  00034	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]
  00037	8a d8		 mov	 bl, al
  00039	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0003c	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00040	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 102  :     _Right   = _STD move(_Tmp);

  00043	0f 11 0a	 movups	 XMMWORD PTR [edx], xmm1
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  00046	0f b6 c3	 movzx	 eax, bl
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 102  :     _Right   = _STD move(_Tmp);

  00049	88 5a 10	 mov	 BYTE PTR [edx+16], bl
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\PythonShop.cpp

; 142  : 		return rkLeft.display_pos < rkRight.display_pos;

  0004c	3a 46 10	 cmp	 al, BYTE PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7541 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0004f	73 12		 jae	 SHORT $LN24@Med3_unche
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 101  :     _Left    = _STD move(_Right);

  00051	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00054	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00057	8a 46 10	 mov	 al, BYTE PTR [esi+16]
  0005a	88 42 10	 mov	 BYTE PTR [edx+16], al

; 102  :     _Right   = _STD move(_Tmp);

  0005d	0f 11 0e	 movups	 XMMWORD PTR [esi], xmm1
  00060	88 5e 10	 mov	 BYTE PTR [esi+16], bl
$LN24@Med3_unche:
  00063	5b		 pop	 ebx
$LN23@Med3_unche:
  00064	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\algorithm

; 7545 : }

  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
??$_Med3_unchecked@PAUSShopItemTable@@UItemStockSortFunc@@@std@@YAXPAUSShopItemTable@@00UItemStockSortFunc@@@Z ENDP ; std::_Med3_unchecked<SShopItemTable *,ItemStockSortFunc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$swap@USShopItemTable@@$0A@@std@@YAXAAUSShopItemTable@@0@Z
_TEXT	SEGMENT
??$swap@USShopItemTable@@$0A@@std@@YAXAAUSShopItemTable@@0@Z PROC ; std::swap<SShopItemTable,0>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 100  :     _Ty _Tmp = _STD move(_Left);
; 101  :     _Left    = _STD move(_Right);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [edx]
  00003	53		 push	 ebx
  00004	8a 59 10	 mov	 bl, BYTE PTR [ecx+16]
  00007	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]
  0000a	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0000d	8a 42 10	 mov	 al, BYTE PTR [edx+16]
  00010	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 102  :     _Right   = _STD move(_Tmp);

  00013	0f 11 0a	 movups	 XMMWORD PTR [edx], xmm1
  00016	88 5a 10	 mov	 BYTE PTR [edx+16], bl
  00019	5b		 pop	 ebx

; 103  : }

  0001a	c3		 ret	 0
??$swap@USShopItemTable@@$0A@@std@@YAXAAUSShopItemTable@@0@Z ENDP ; std::swap<SShopItemTable,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@AAPAUSShopItemTable@@@std@@YAAAPAUSShopItemTable@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@AAPAUSShopItemTable@@@std@@YAAAPAUSShopItemTable@@AAPAU1@@Z PROC ; std::forward<SShopItemTable * &>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@AAPAUSShopItemTable@@@std@@YAAAPAUSShopItemTable@@AAPAU1@@Z ENDP ; std::forward<SShopItemTable * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$?0USItemPos@@USShopItemTable@@$0A@@?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@QAE@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0USItemPos@@USShopItemTable@@$0A@@?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@QAE@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z PROC ; std::pair<SItemPos const ,SShopItemTable>::pair<SItemPos const ,SShopItemTable><SItemPos,SShopItemTable,0>, COMDAT
; _this$ = ecx

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	66 8b 02	 mov	 ax, WORD PTR [edx]
  00009	66 89 01	 mov	 WORD PTR [ecx], ax
  0000c	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  00010	88 41 02	 mov	 BYTE PTR [ecx+2], al
  00013	0f 10 42 03	 movups	 xmm0, XMMWORD PTR [edx+3]
  00017	0f 11 41 03	 movups	 XMMWORD PTR [ecx+3], xmm0
  0001b	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  0001f	88 41 13	 mov	 BYTE PTR [ecx+19], al
  00022	8b c1		 mov	 eax, ecx
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0USItemPos@@USShopItemTable@@$0A@@?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@QAE@$$QAU?$pair@USItemPos@@USShopItemTable@@@1@@Z ENDP ; std::pair<SItemPos const ,SShopItemTable>::pair<SItemPos const ,SShopItemTable><SItemPos,SShopItemTable,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$construct_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@$0A@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@QAU10@$$QAU?$pair@USItemPos@@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
??$construct_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@$0A@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@QAU10@$$QAU?$pair@USItemPos@@USShopItemTable@@@0@@Z PROC ; std::construct_at<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable>,0>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 200  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00000	66 8b 02	 mov	 ax, WORD PTR [edx]
  00003	66 89 01	 mov	 WORD PTR [ecx], ax
  00006	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  0000a	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0000d	0f 10 42 03	 movups	 xmm0, XMMWORD PTR [edx+3]
  00011	0f 11 41 03	 movups	 XMMWORD PTR [ecx+3], xmm0
  00015	0f b6 42 13	 movzx	 eax, BYTE PTR [edx+19]
  00019	88 41 13	 mov	 BYTE PTR [ecx+19], al
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility

; 218  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  0001c	8b c1		 mov	 eax, ecx

; 219  : }

  0001e	c3		 ret	 0
??$construct_at@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@U?$pair@USItemPos@@USShopItemTable@@@2@$0A@@std@@YAPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@QAU10@$$QAU?$pair@USItemPos@@USShopItemTable@@@0@@Z ENDP ; std::construct_at<std::pair<SItemPos const ,SShopItemTable>,std::pair<SItemPos,SShopItemTable>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$_Voidify_iter@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAXPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z
_TEXT	SEGMENT
??$_Voidify_iter@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAXPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z PROC ; std::_Voidify_iter<std::pair<SItemPos const ,SShopItemTable> *>, COMDAT
; __It$ = ecx

; 201  :     if constexpr (is_pointer_v<_Iter>) {
; 202  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00000	8b c1		 mov	 eax, ecx

; 203  :     } else {
; 204  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 205  :     }
; 206  : }

  00002	c3		 ret	 0
??$_Voidify_iter@PAU?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@@std@@YAPAXPAU?$pair@$$CBUSItemPos@@USShopItemTable@@@0@@Z ENDP ; std::_Voidify_iter<std::pair<SItemPos const ,SShopItemTable> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xutility
;	COMDAT ??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@$0A@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@AAPAU10@@Z
_TEXT	SEGMENT
??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@$0A@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@AAPAU10@@Z PROC ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>, COMDAT
; __Location$ = ecx
; _<_Args_0>$ = edx

; 218  :     _MSVC_CONSTEXPR return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	89 01		 mov	 DWORD PTR [ecx], eax
  00004	8b c1		 mov	 eax, ecx

; 219  : }

  00006	c3		 ret	 0
??$construct_at@PAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@std@@AAPAU12@$0A@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBUSItemPos@@USShopItemTable@@@std@@PAX@0@QAPAU10@AAPAU10@@Z ENDP ; std::construct_at<std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> *,std::_Tree_node<std::pair<SItemPos const ,SShopItemTable>,void *> * &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\type_traits
;	COMDAT ??$forward@USItemPos@@@std@@YA$$QAUSItemPos@@AAU1@@Z
_TEXT	SEGMENT
??$forward@USItemPos@@@std@@YA$$QAUSItemPos@@AAU1@@Z PROC ; std::forward<SItemPos>, COMDAT
; __Arg$ = ecx

; 1426 :     return static_cast<_Ty&&>(_Arg);

  00000	8b c1		 mov	 eax, ecx

; 1427 : }

  00002	c3		 ret	 0
??$forward@USItemPos@@@std@@YA$$QAUSItemPos@@AAU1@@Z ENDP ; std::forward<SItemPos>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.h
;	COMDAT ??MSItemPos@@QBE_NABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??MSItemPos@@QBE_NABU0@@Z PROC				; SItemPos::operator<, COMDAT
; _this$ = ecx

; 269  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00003	8b 55 08	 mov	 edx, DWORD PTR _rhs$[ebp]
  00006	8a 01		 mov	 al, BYTE PTR [ecx]
  00008	53		 push	 ebx
  00009	3a 02		 cmp	 al, BYTE PTR [edx]
  0000b	72 13		 jb	 SHORT $LN4@operator
  0000d	75 0a		 jne	 SHORT $LN3@operator
  0000f	66 8b 41 01	 mov	 ax, WORD PTR [ecx+1]
  00013	66 3b 42 01	 cmp	 ax, WORD PTR [edx+1]
  00017	72 07		 jb	 SHORT $LN4@operator
$LN3@operator:
  00019	32 c0		 xor	 al, al
  0001b	5b		 pop	 ebx

; 271  : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
$LN4@operator:

; 270  : 		return (window_type < rhs.window_type) || ((window_type == rhs.window_type) && (cell < rhs.cell));

  00020	b0 01		 mov	 al, 1
  00022	5b		 pop	 ebx

; 271  : 	}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??MSItemPos@@QBE_NABU0@@Z ENDP				; SItemPos::operator<
_TEXT	ENDS
END
