; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

	TITLE	e:\metin2_server\solwaynesf v6\clientvs22\vs_files\userinterface\distribute\gametype.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@HALCDGDI@d?3?1ymir?5work?1ui?1@	; `string'
PUBLIC	??_C@_04FAHLGLIA@?4fnt@				; `string'
PUBLIC	??_C@_01KBJDNOO@i@				; `string'
PUBLIC	??_C@_05MJKNGIJO@mark?1@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0L@GNKPCGDN@?$CFs?$CF03d?4jpg@		; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?c_aSlotTypeToInvenType@@3PAEA			; c_aSlotTypeToInvenType
EXTRN	?_getf@@YAPBDPBDZZ:PROC				; _getf
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	_strchr:PROC
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	_atexit:PROC
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ??_C@_0L@GNKPCGDN@?$CFs?$CF03d?4jpg@
CONST	SEGMENT
??_C@_0L@GNKPCGDN@?$CFs?$CF03d?4jpg@ DB '%s%03d.jpg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJKNGIJO@mark?1@
CONST	SEGMENT
??_C@_05MJKNGIJO@mark?1@ DB 'mark/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KBJDNOO@i@
CONST	SEGMENT
??_C@_01KBJDNOO@i@ DB 'i', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04FAHLGLIA@?4fnt@
CONST	SEGMENT
??_C@_04FAHLGLIA@?4fnt@ DB '.fnt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HALCDGDI@d?3?1ymir?5work?1ui?1@
CONST	SEGMENT
??_C@_0BB@HALCDGDI@d?3?1ymir?5work?1ui?1@ DB 'd:/ymir work/ui/', 00H ; `string'
?c_aSlotTypeToInvenType@@3PAEA DB 00H			; c_aSlotTypeToInvenType
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	05H
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
PUBLIC	??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QAD0I0I@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
PUBLIC	?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ; CSingleton<CResourceManager>::Instance
PUBLIC	?SlotTypeToInvenType@@YAEE@Z			; SlotTypeToInvenType
PUBLIC	?GetGuildSymbolFileName@@YAPBDK@Z		; GetGuildSymbolFileName
PUBLIC	?SetGuildSymbolPath@@YAXPBD@Z			; SetGuildSymbolPath
PUBLIC	?DefaultItalicFont_GetResource@@YAPAVCResource@@XZ ; DefaultItalicFont_GetResource
PUBLIC	?DefaultFont_GetResource@@YAPAVCResource@@XZ	; DefaultFont_GetResource
PUBLIC	?ReloadDefaultFonts@@YA_NXZ			; ReloadDefaultFonts
PUBLIC	?DefaultFont_SetName@@YAXPBD@Z			; DefaultFont_SetName
PUBLIC	?DefaultFont_Cleanup@@YAXXZ			; DefaultFont_Cleanup
PUBLIC	?DefaultFont_Startup@@YAXXZ			; DefaultFont_Startup
PUBLIC	?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strResourcePath
PUBLIC	?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strImagePath
PUBLIC	?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
	ALIGN	4

?gs_pkDefaultFont@@3PAVCResource@@A DD 01H DUP (?)	; gs_pkDefaultFont
?gs_pkDefaultItalicFont@@3PAVCResource@@A DD 01H DUP (?) ; gs_pkDefaultItalicFont
?gs_isReloadDefaultFont@@3_NA DB 01H DUP (?)		; gs_isReloadDefaultFont
_BSS	ENDS
CRT$XCU	SEGMENT
?g_strResourcePath$initializer$@@3P6AXXZA DD FLAT:??__Fg_strResourcePath@@YAXXZ ; g_strResourcePath$initializer$
?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 064H ; g_strResourcePath
	DB	03aH
	DB	02fH
	DB	079H
	DB	06dH
	DB	069H
	DB	072H
	DB	020H
	DB	077H
	DB	06fH
	DB	072H
	DB	06bH
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DD	0dH
	DD	0fH
?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 014H DUP (?)
	DD	0fH					; g_strImagePath
?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 06dH ; g_strGuildSymbolPathName
	DB	061H
	DB	072H
	DB	06bH
	DB	02fH
	DB	031H
	DB	030H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	08H
	DD	0fH
?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 0b1H ; gs_strDefaultFontName
	DB	0bcH
	DB	0b8H
	DB	0b2H
	DB	0c3H
	DB	0bcH
	DB	03aH
	DB	031H
	DB	032H
	DB	02eH
	DB	066H
	DB	06eH
	DB	074H
	DB	00H
	DB	00H
	DB	00H
	DD	0dH
	DD	0fH
?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 0b1H ; gs_strDefaultItalicFontName
	DB	0bcH
	DB	0b8H
	DB	0b2H
	DB	0c3H
	DB	0bcH
	DB	03aH
	DB	031H
	DB	032H
	DB	069H
	DB	02eH
	DB	066H
	DB	06eH
	DB	074H
	DB	00H
	DB	00H
	DD	0eH
	DD	0fH
CRT$XCU	SEGMENT
?g_strImagePath$initializer$@@3P6AXXZA DD FLAT:??__Eg_strImagePath@@YAXXZ ; g_strImagePath$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?g_strGuildSymbolPathName$initializer$@@3P6AXXZA DD FLAT:??__Fg_strGuildSymbolPathName@@YAXXZ ; g_strGuildSymbolPathName$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_strDefaultFontName$initializer$@@3P6AXXZA DD FLAT:??__Fgs_strDefaultFontName@@YAXXZ ; gs_strDefaultFontName$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_strDefaultItalicFontName$initializer$@@3P6AXXZA DD FLAT:??__Fgs_strDefaultItalicFontName@@YAXXZ ; gs_strDefaultItalicFontName$initializer$
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ??__Fg_strResourcePath@@YAXXZ
text$di	SEGMENT
??__Fg_strResourcePath@@YAXXZ PROC			; `dynamic atexit destructor for 'g_strResourcePath'', COMDAT

; 4    : std::string g_strResourcePath = "d:/ymir work/";

  00000	68 00 00 00 00	 push	 OFFSET ??__Fg_strResourcePath@@YAXXZ ; `dynamic atexit destructor for 'g_strResourcePath''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Fg_strResourcePath@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_strResourcePath''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??__Fg_strResourcePath@@YAXXZ
text$yd	SEGMENT
??__Fg_strResourcePath@@YAXXZ PROC			; `dynamic atexit destructor for 'g_strResourcePath'', COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2301 :         return _BUF_SIZE <= _Myres;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 5008 :         if (_My_data._Large_string_engaged()) {

  00009	72 2a		 jb	 SHORT $LN15@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5013 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00010	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN27@dynamic

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 28		 ja	 SHORT $LN24@dynamic

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN27@dynamic:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5016 :         _My_data._Mysize = 0;

  00035	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 5017 :         _My_data._Myres  = _BUF_SIZE - 1;

  0003f	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 5018 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5019 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00049	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00050	c3		 ret	 0
$LN24@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00051	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??__Fg_strResourcePath@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_strResourcePath''
text$yd	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ??__Eg_strImagePath@@YAXXZ
text$di	SEGMENT
??__Eg_strImagePath@@YAXXZ PROC				; `dynamic initializer for 'g_strImagePath'', COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 77   :         return ::operator new(_Bytes);

  00000	6a 20		 push	 32			; 00000020H
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00007	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BB@HALCDGDI@d?3?1ymir?5work?1ui?1@

; 2770 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0000e	a3 00 00 00 00	 mov	 DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, eax

; 2771 : 
; 2772 : #if _HAS_CXX20
; 2773 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2774 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2775 :         }
; 2776 : #endif // _HAS_CXX20
; 2777 : 
; 2778 :         _My_data._Mysize = _Count;

  00013	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 16 ; 00000010H

; 2779 :         _My_data._Myres  = _New_capacity;

  0001d	c7 05 14 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 31 ; 0000001fH

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00027	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 5    : std::string g_strImagePath = "d:/ymir work/ui/";

  0002a	68 00 00 00 00	 push	 OFFSET ??__Fg_strImagePath@@YAXXZ ; `dynamic atexit destructor for 'g_strImagePath''
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2785 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0002f	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 5    : std::string g_strImagePath = "d:/ymir work/ui/";

  00033	e8 00 00 00 00	 call	 _atexit
  00038	83 c4 08	 add	 esp, 8
  0003b	c3		 ret	 0
??__Eg_strImagePath@@YAXXZ ENDP				; `dynamic initializer for 'g_strImagePath''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??__Fg_strImagePath@@YAXXZ
text$yd	SEGMENT
??__Fg_strImagePath@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strImagePath'', COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2301 :         return _BUF_SIZE <= _Myres;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 5008 :         if (_My_data._Large_string_engaged()) {

  00009	72 2a		 jb	 SHORT $LN15@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5013 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00010	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN27@dynamic

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 28		 ja	 SHORT $LN24@dynamic

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN27@dynamic:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5016 :         _My_data._Mysize = 0;

  00035	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 5017 :         _My_data._Myres  = _BUF_SIZE - 1;

  0003f	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 5018 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5019 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00049	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00050	c3		 ret	 0
$LN24@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00051	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??__Fg_strImagePath@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strImagePath''
text$yd	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ??__Fg_strGuildSymbolPathName@@YAXXZ
text$di	SEGMENT
??__Fg_strGuildSymbolPathName@@YAXXZ PROC		; `dynamic atexit destructor for 'g_strGuildSymbolPathName'', COMDAT

; 7    : std::string g_strGuildSymbolPathName = "mark/10/";

  00000	68 00 00 00 00	 push	 OFFSET ??__Fg_strGuildSymbolPathName@@YAXXZ ; `dynamic atexit destructor for 'g_strGuildSymbolPathName''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Fg_strGuildSymbolPathName@@YAXXZ ENDP		; `dynamic atexit destructor for 'g_strGuildSymbolPathName''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??__Fg_strGuildSymbolPathName@@YAXXZ
text$yd	SEGMENT
??__Fg_strGuildSymbolPathName@@YAXXZ PROC		; `dynamic atexit destructor for 'g_strGuildSymbolPathName'', COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2301 :         return _BUF_SIZE <= _Myres;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 5008 :         if (_My_data._Large_string_engaged()) {

  00009	72 2a		 jb	 SHORT $LN15@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5013 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00010	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN27@dynamic

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 28		 ja	 SHORT $LN24@dynamic

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN27@dynamic:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5016 :         _My_data._Mysize = 0;

  00035	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 5017 :         _My_data._Myres  = _BUF_SIZE - 1;

  0003f	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 5018 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5019 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00049	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00050	c3		 ret	 0
$LN24@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00051	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??__Fg_strGuildSymbolPathName@@YAXXZ ENDP		; `dynamic atexit destructor for 'g_strGuildSymbolPathName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ??__Fgs_strDefaultFontName@@YAXXZ
text$di	SEGMENT
??__Fgs_strDefaultFontName@@YAXXZ PROC			; `dynamic atexit destructor for 'gs_strDefaultFontName'', COMDAT

; 10   : static std::string gs_strDefaultFontName = "±¼¸²Ã¼:12.fnt";

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_strDefaultFontName@@YAXXZ ; `dynamic atexit destructor for 'gs_strDefaultFontName''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Fgs_strDefaultFontName@@YAXXZ ENDP			; `dynamic atexit destructor for 'gs_strDefaultFontName''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??__Fgs_strDefaultFontName@@YAXXZ
text$yd	SEGMENT
??__Fgs_strDefaultFontName@@YAXXZ PROC			; `dynamic atexit destructor for 'gs_strDefaultFontName'', COMDAT

; 2301 :         return _BUF_SIZE <= _Myres;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 5008 :         if (_My_data._Large_string_engaged()) {

  00009	72 2f		 jb	 SHORT $LN15@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5013 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00011	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	8b c2		 mov	 eax, edx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 14		 jb	 SHORT $LN27@dynamic

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H
  00022	2b c2		 sub	 eax, edx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn
$LN27@dynamic:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5016 :         _My_data._Mysize = 0;

  0003a	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 5017 :         _My_data._Myres  = _BUF_SIZE - 1;

  00044	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 5018 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5019 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00055	c3		 ret	 0
??__Fgs_strDefaultFontName@@YAXXZ ENDP			; `dynamic atexit destructor for 'gs_strDefaultFontName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ??__Fgs_strDefaultItalicFontName@@YAXXZ
text$di	SEGMENT
??__Fgs_strDefaultItalicFontName@@YAXXZ PROC		; `dynamic atexit destructor for 'gs_strDefaultItalicFontName'', COMDAT

; 11   : static std::string gs_strDefaultItalicFontName = "±¼¸²Ã¼:12i.fnt";

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_strDefaultItalicFontName@@YAXXZ ; `dynamic atexit destructor for 'gs_strDefaultItalicFontName''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Fgs_strDefaultItalicFontName@@YAXXZ ENDP		; `dynamic atexit destructor for 'gs_strDefaultItalicFontName''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??__Fgs_strDefaultItalicFontName@@YAXXZ
text$yd	SEGMENT
??__Fgs_strDefaultItalicFontName@@YAXXZ PROC		; `dynamic atexit destructor for 'gs_strDefaultItalicFontName'', COMDAT

; 2301 :         return _BUF_SIZE <= _Myres;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 5008 :         if (_My_data._Large_string_engaged()) {

  00009	72 2f		 jb	 SHORT $LN15@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5013 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00011	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	8b c2		 mov	 eax, edx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 14		 jb	 SHORT $LN27@dynamic

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H
  00022	2b c2		 sub	 eax, edx

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn
$LN27@dynamic:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 5016 :         _My_data._Mysize = 0;

  0003a	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 5017 :         _My_data._Myres  = _BUF_SIZE - 1;

  00044	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 5018 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5019 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00055	c3		 ret	 0
??__Fgs_strDefaultItalicFontName@@YAXXZ ENDP		; `dynamic atexit destructor for 'gs_strDefaultItalicFontName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?DefaultFont_Startup@@YAXXZ
_TEXT	SEGMENT
?DefaultFont_Startup@@YAXXZ PROC			; DefaultFont_Startup, COMDAT

; 19   : 	gs_pkDefaultFont = NULL;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A, 0

; 20   : }

  0000a	c3		 ret	 0
?DefaultFont_Startup@@YAXXZ ENDP			; DefaultFont_Startup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?DefaultFont_Cleanup@@YAXXZ
_TEXT	SEGMENT
?DefaultFont_Cleanup@@YAXXZ PROC			; DefaultFont_Cleanup, COMDAT

; 24   : 	if (gs_pkDefaultFont)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A
  00006	85 c9		 test	 ecx, ecx
  00008	0f 85 00 00 00
	00		 jne	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 25   : 		gs_pkDefaultFont->Release();
; 26   : }

  0000e	c3		 ret	 0
?DefaultFont_Cleanup@@YAXXZ ENDP			; DefaultFont_Cleanup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?DefaultFont_SetName@@YAXPBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
$T2 = -4						; size = 1
$T3 = -4						; size = 1
?DefaultFont_SetName@@YAXPBD@Z PROC			; DefaultFont_SetName, COMDAT
; _c_szFontName$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 415  :             return __builtin_strlen(_First);

  00007	8b d6		 mov	 edx, esi
  00009	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0000c	0f 1f 40 00	 npad	 4
$LL142@DefaultFon:
  00010	8a 02		 mov	 al, BYTE PTR [edx]
  00012	42		 inc	 edx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL142@DefaultFon
  00017	2b d1		 sub	 edx, ecx

; 3546 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  0001e	52		 push	 edx
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3421 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00025	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  0002b	8b c2		 mov	 eax, edx
  0002d	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00033	2b c1		 sub	 eax, ecx

; 3422 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00035	83 f8 04	 cmp	 eax, 4
  00038	72 25		 jb	 SHORT $LN17@DefaultFon

; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0003a	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 2301 :         return _BUF_SIZE <= _Myres;

  0003d	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00040	a3 10 00 00 00	 mov	 DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 2283 :         value_type* _Result = _Bx._Buf;

  00045	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2284 :         if (_Large_string_engaged()) {

  0004a	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00051	c7 04 08 2e 66
	6e 74		 mov	 DWORD PTR [eax+ecx], 1953392174 ; 746e662eH

; 3427 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00058	c6 44 08 04 00	 mov	 BYTE PTR [eax+ecx+4], 0

; 3428 :             return *this;

  0005d	eb 16		 jmp	 SHORT $LN16@DefaultFon
$LN17@DefaultFon:

; 3431 :         return _Reallocate_grow_by(

  0005f	6a 04		 push	 4
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_04FAHLGLIA@?4fnt@
  00066	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  0006e	6a 04		 push	 4
  00070	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
$LN16@DefaultFon:

; 415  :             return __builtin_strlen(_First);

  00075	8b ce		 mov	 ecx, esi
  00077	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL143@DefaultFon:
  00080	8a 01		 mov	 al, BYTE PTR [ecx]
  00082	41		 inc	 ecx
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL143@DefaultFon
  00087	2b ca		 sub	 ecx, edx

; 3546 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00089	51		 push	 ecx
  0008a	56		 push	 esi
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00090	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 34   : 	if(strchr(c_szFontName, ':'))

  00095	6a 3a		 push	 58			; 0000003aH
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 _strchr
  0009d	83 c4 08	 add	 esp, 8
  000a0	5e		 pop	 esi
  000a1	85 c0		 test	 eax, eax
  000a3	74 4a		 je	 SHORT $LN80@DefaultFon
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 3421 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000a5	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  000ab	8b c2		 mov	 eax, edx
  000ad	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  000b3	2b c1		 sub	 eax, ecx

; 3422 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  000b5	83 f8 01	 cmp	 eax, 1
  000b8	72 1f		 jb	 SHORT $LN81@DefaultFon

; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  000ba	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2301 :         return _BUF_SIZE <= _Myres;

  000bd	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  000c0	a3 10 00 00 00	 mov	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 2283 :         value_type* _Result = _Bx._Buf;

  000c5	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2284 :         if (_Large_string_engaged()) {

  000ca	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000d1	66 c7 04 08 69
	00		 mov	 WORD PTR [eax+ecx], 105	; 00000069H

; 3428 :             return *this;

  000d7	eb 16		 jmp	 SHORT $LN80@DefaultFon
$LN81@DefaultFon:

; 3431 :         return _Reallocate_grow_by(

  000d9	6a 01		 push	 1
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  000e0	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  000e8	6a 01		 push	 1
  000ea	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
$LN80@DefaultFon:

; 3421 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000ef	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  000f5	8b c2		 mov	 eax, edx
  000f7	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  000fd	2b c1		 sub	 eax, ecx

; 3422 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  000ff	83 f8 04	 cmp	 eax, 4
  00102	72 2e		 jb	 SHORT $LN52@DefaultFon

; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00104	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 39   : }

  00107	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0010e	a3 10 00 00 00	 mov	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 2301 :         return _BUF_SIZE <= _Myres;

  00113	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2283 :         value_type* _Result = _Bx._Buf;

  00116	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2284 :         if (_Large_string_engaged()) {

  0011b	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00122	c7 04 08 2e 66
	6e 74		 mov	 DWORD PTR [eax+ecx], 1953392174 ; 746e662eH

; 3427 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00129	c6 44 08 04 00	 mov	 BYTE PTR [eax+ecx+4], 0
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 39   : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
$LN52@DefaultFon:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 3431 :         return _Reallocate_grow_by(

  00132	6a 04		 push	 4
  00134	68 00 00 00 00	 push	 OFFSET ??_C@_04FAHLGLIA@?4fnt@
  00139	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0013c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00141	6a 04		 push	 4
  00143	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 39   : }

  00148	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 1
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
?DefaultFont_SetName@@YAXPBD@Z ENDP			; DefaultFont_SetName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?ReloadDefaultFonts@@YA_NXZ
_TEXT	SEGMENT
?ReloadDefaultFonts@@YA_NXZ PROC			; ReloadDefaultFonts, COMDAT
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2301 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2292 :         const value_type* _Result = _Bx._Buf;

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 42   : {

  0000c	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2293 :         if (_Large_string_engaged()) {

  0000d	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 43   : 	CResourceManager& rkResMgr = CResourceManager::Instance();

  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton

; 44   : 
; 45   : 	gs_isReloadDefaultFont = false;
; 46   : 
; 47   : 	CResource* pkNewFont = rkResMgr.GetResourcePointer(gs_strDefaultFontName.c_str());

  0001a	8b ce		 mov	 ecx, esi
  0001c	57		 push	 edi
  0001d	50		 push	 eax
  0001e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 0
  00025	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0002a	8b f8		 mov	 edi, eax

; 48   : 	pkNewFont->AddReference();

  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference

; 49   : 	if (gs_pkDefaultFont)

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A
  00039	85 c9		 test	 ecx, ecx
  0003b	74 05		 je	 SHORT $LN2@ReloadDefa

; 50   : 		gs_pkDefaultFont->Release();

  0003d	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN2@ReloadDefa:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2301 :         return _BUF_SIZE <= _Myres;

  00042	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2292 :         const value_type* _Result = _Bx._Buf;

  00049	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 53   : 	CResource* pkNewItalicFont = rkResMgr.GetResourcePointer(gs_strDefaultItalicFontName.c_str());

  0004e	8b ce		 mov	 ecx, esi
  00050	89 3d 00 00 00
	00		 mov	 DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2293 :         if (_Large_string_engaged()) {

  00056	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 53   : 	CResource* pkNewItalicFont = rkResMgr.GetResourcePointer(gs_strDefaultItalicFontName.c_str());

  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00063	8b f0		 mov	 esi, eax

; 54   : 	pkNewItalicFont->AddReference();

  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference

; 55   : 	if (gs_pkDefaultItalicFont)

  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pkDefaultItalicFont@@3PAVCResource@@A
  00072	85 c9		 test	 ecx, ecx
  00074	74 05		 je	 SHORT $LN19@ReloadDefa

; 56   : 		gs_pkDefaultItalicFont->Release();

  00076	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN19@ReloadDefa:
  0007b	5f		 pop	 edi

; 57   : 	gs_pkDefaultItalicFont = pkNewItalicFont;
; 58   : 
; 59   : 	return true;
; 60   : }

  0007c	89 35 00 00 00
	00		 mov	 DWORD PTR ?gs_pkDefaultItalicFont@@3PAVCResource@@A, esi
  00082	b0 01		 mov	 al, 1
  00084	5e		 pop	 esi
  00085	c3		 ret	 0
?ReloadDefaultFonts@@YA_NXZ ENDP			; ReloadDefaultFonts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?DefaultFont_GetResource@@YAPAVCResource@@XZ
_TEXT	SEGMENT
?DefaultFont_GetResource@@YAPAVCResource@@XZ PROC	; DefaultFont_GetResource, COMDAT

; 64   : 	if (!gs_pkDefaultFont || gs_isReloadDefaultFont)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN3@DefaultFon
  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 0
  00010	74 0a		 je	 SHORT $LN2@DefaultFon
$LN3@DefaultFon:

; 65   : 		ReloadDefaultFonts();

  00012	e8 00 00 00 00	 call	 ?ReloadDefaultFonts@@YA_NXZ ; ReloadDefaultFonts

; 66   : 	return gs_pkDefaultFont;

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A
$LN2@DefaultFon:

; 67   : }

  0001c	c3		 ret	 0
?DefaultFont_GetResource@@YAPAVCResource@@XZ ENDP	; DefaultFont_GetResource
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?DefaultItalicFont_GetResource@@YAPAVCResource@@XZ
_TEXT	SEGMENT
?DefaultItalicFont_GetResource@@YAPAVCResource@@XZ PROC	; DefaultItalicFont_GetResource, COMDAT

; 71   : 	if (!gs_pkDefaultItalicFont || gs_isReloadDefaultFont)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_pkDefaultItalicFont@@3PAVCResource@@A
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN3@DefaultIta
  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 0
  00010	74 0a		 je	 SHORT $LN2@DefaultIta
$LN3@DefaultIta:

; 72   : 		ReloadDefaultFonts();

  00012	e8 00 00 00 00	 call	 ?ReloadDefaultFonts@@YA_NXZ ; ReloadDefaultFonts

; 73   : 	return gs_pkDefaultItalicFont;

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_pkDefaultItalicFont@@3PAVCResource@@A
$LN2@DefaultIta:

; 74   : }

  0001c	c3		 ret	 0
?DefaultItalicFont_GetResource@@YAPAVCResource@@XZ ENDP	; DefaultItalicFont_GetResource
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?SetGuildSymbolPath@@YAXPBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
?SetGuildSymbolPath@@YAXPBD@Z PROC			; SetGuildSymbolPath, COMDAT
; _c_szPathName$ = ecx

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 3546 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00005	6a 05		 push	 5
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 79   : {

  00007	8b f1		 mov	 esi, ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 3546 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_05MJKNGIJO@mark?1@
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3383 :         return append(_Ptr);

  00018	56		 push	 esi
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
  0001e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3422 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00023	8b 15 14 00 00
	00		 mov	 edx, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00029	8b c2		 mov	 eax, edx
  0002b	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00031	2b c1		 sub	 eax, ecx
  00033	5e		 pop	 esi
  00034	83 f8 01	 cmp	 eax, 1
  00037	72 21		 jb	 SHORT $LN18@SetGuildSy

; 3423 :             _ASAN_STRING_MODIFY(static_cast<difference_type>(_Count));
; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00039	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 2301 :         return _BUF_SIZE <= _Myres;

  0003c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0003f	a3 10 00 00 00	 mov	 DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, eax

; 2283 :         value_type* _Result = _Bx._Buf;

  00044	b8 00 00 00 00	 mov	 eax, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName

; 2284 :         if (_Large_string_engaged()) {

  00049	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00050	66 c7 04 08 2f
	00		 mov	 WORD PTR [eax+ecx], 47	; 0000002fH
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 83   : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
$LN18@SetGuildSy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 3431 :         return _Reallocate_grow_by(

  0005a	6a 01		 push	 1
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1@
  00061	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00064	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
  00069	6a 01		 push	 1
  0006b	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 83   : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?SetGuildSymbolPath@@YAXPBD@Z ENDP			; SetGuildSymbolPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?GetGuildSymbolFileName@@YAPBDK@Z
_TEXT	SEGMENT
?GetGuildSymbolFileName@@YAPBDK@Z PROC			; GetGuildSymbolFileName, COMDAT
; _dwGuildID$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2301 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2292 :         const value_type* _Result = _Bx._Buf;

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 87   : 	return _getf("%s%03d.jpg", g_strGuildSymbolPathName.c_str(), dwGuildID);

  0000c	51		 push	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2293 :         if (_Large_string_engaged()) {

  0000d	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp

; 87   : 	return _getf("%s%03d.jpg", g_strGuildSymbolPathName.c_str(), dwGuildID);

  00014	50		 push	 eax
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GNKPCGDN@?$CFs?$CF03d?4jpg@
  0001a	e8 00 00 00 00	 call	 ?_getf@@YAPBDPBDZZ	; _getf
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 88   : }

  00022	c3		 ret	 0
?GetGuildSymbolFileName@@YAPBDK@Z ENDP			; GetGuildSymbolFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\UserInterface\GameType.cpp
;	COMDAT ?SlotTypeToInvenType@@YAEE@Z
_TEXT	SEGMENT
?SlotTypeToInvenType@@YAEE@Z PROC			; SlotTypeToInvenType, COMDAT
; _bSlotType$ = cl

; 108  : 	if (bSlotType >= SLOT_TYPE_MAX)

  00000	80 f9 0c	 cmp	 cl, 12			; 0000000cH
  00003	72 03		 jb	 SHORT $LN2@SlotTypeTo

; 109  : 		return RESERVED_WINDOW;

  00005	32 c0		 xor	 al, al

; 112  : }

  00007	c3		 ret	 0
$LN2@SlotTypeTo:

; 110  : 	else
; 111  : 		return c_aSlotTypeToInvenType[bSlotType];

  00008	0f b6 c1	 movzx	 eax, cl
  0000b	8a 80 00 00 00
	00		 mov	 al, BYTE PTR ?c_aSlotTypeToInvenType@@3PAEA[eax]

; 112  : }

  00011	c3		 ret	 0
?SlotTypeToInvenType@@YAEE@Z ENDP			; SlotTypeToInvenType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Metin2_server\SolWayneSF v6\ClientVS22\source\eterBase\Singleton.h
;	COMDAT ?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ
_TEXT	SEGMENT
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ PROC ; CSingleton<CResourceManager>::Instance, COMDAT

; 26   : 		assert(ms_singleton);
; 27   : 		return (*ms_singleton);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton

; 28   : 	}

  00005	c3		 ret	 0
?Instance@?$CSingleton@VCResourceManager@@@@SAAAVCResourceManager@@XZ ENDP ; CSingleton<CResourceManager>::Instance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QAD0I0I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QAD0I0I@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator(), COMDAT
; _this$ = ecx

; 3434 :                 const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]

; 3434 :                 const size_type _Count) {

  00007	57		 push	 edi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00008	8b 7d 10	 mov	 edi, DWORD PTR __Old_size$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy

; 3435 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3436 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00015	03 fe		 add	 edi, esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00017	8b 75 18	 mov	 esi, DWORD PTR __Count$[ebp]
  0001a	56		 push	 esi
  0001b	ff 75 14	 push	 DWORD PTR __Ptr$[ebp]
  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 _memcpy
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 3437 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00027	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi

; 3438 :             },

  0002d	5d		 pop	 ebp
  0002e	c2 14 00	 ret	 20			; 00000014H
??R<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QAD0I0I@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z
_TEXT	SEGMENT
__First1$1$ = -8					; size = 4
__New_size$1$ = -8					; size = 4
tv606 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
$T1 = 8							; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4931 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 4932 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4933 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4934 :         auto& _My_data            = _Mypair._Myval2;
; 4935 :         const size_type _Old_size = _My_data._Mysize;
; 4936 :         if (max_size() - _Old_size < _Size_increase) {

  00008	8b 75 08	 mov	 esi, DWORD PTR __Size_increase$[ebp]
  0000b	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  00010	57		 push	 edi
  00011	8b f9		 mov	 edi, ecx
  00013	8b c2		 mov	 eax, edx
  00015	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00018	2b c1		 sub	 eax, ecx
  0001a	89 4d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001d	3b c6		 cmp	 eax, esi
  0001f	0f 82 23 01 00
	00		 jb	 $LN122@Reallocate

; 4941 :         const size_type _Old_capacity = _My_data._Myres;

  00025	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00028	8d 1c 31	 lea	 ebx, DWORD PTR [ecx+esi]

; 4880 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0002b	8b f3		 mov	 esi, ebx

; 4938 :         }
; 4939 : 
; 4940 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	89 5d f8	 mov	 DWORD PTR __New_size$1$[ebp], ebx

; 4880 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00030	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4941 :         const size_type _Old_capacity = _My_data._Myres;

  00033	89 45 08	 mov	 DWORD PTR $T1[ebp], eax

; 4880 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00036	3b f2		 cmp	 esi, edx

; 4881 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00038	76 17		 jbe	 SHORT $LN10@Reallocate

; 4882 :             return _Max;

  0003a	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0003f	8b f2		 mov	 esi, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00047	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  0004a	83 c4 04	 add	 esp, 4
  0004d	8b d8		 mov	 ebx, eax
  0004f	eb 5b		 jmp	 SHORT $LN17@Reallocate
$LN10@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 4885 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00051	8b d8		 mov	 ebx, eax
  00053	d1 eb		 shr	 ebx, 1
  00055	2b d3		 sub	 edx, ebx
  00057	3b c2		 cmp	 eax, edx
  00059	76 1a		 jbe	 SHORT $LN11@Reallocate

; 4886 :             return _Max;

  0005b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00060	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  0006e	83 c4 04	 add	 esp, 4
  00071	8b d8		 mov	 ebx, eax
  00073	eb 37		 jmp	 SHORT $LN17@Reallocate
$LN11@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 4889 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00075	03 c3		 add	 eax, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

  00077	3b f0		 cmp	 esi, eax
  00079	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 4944 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0007c	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00084	72 10		 jb	 SHORT $LN19@Reallocate

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  0008f	83 c4 04	 add	 esp, 4
  00092	8b d8		 mov	 ebx, eax
  00094	eb 16		 jmp	 SHORT $LN17@Reallocate
$LN19@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  00096	85 c0		 test	 eax, eax
  00098	74 10		 je	 SHORT $LN20@Reallocate

; 77   :         return ::operator new(_Bytes);

  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

  000a0	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 77   :         return ::operator new(_Bytes);

  000a3	83 c4 04	 add	 esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

  000a6	8b d8		 mov	 ebx, eax
  000a8	eb 02		 jmp	 SHORT $LN17@Reallocate
$LN20@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  000aa	33 db		 xor	 ebx, ebx
$LN17@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 4953 :         _My_data._Mysize      = _New_size;

  000ac	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  000af	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 4954 :         _My_data._Myres       = _New_capacity;

  000b2	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  000b5	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000b8	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]
  000bb	03 c6		 add	 eax, esi
  000bd	89 75 f8	 mov	 DWORD PTR __First1$1$[ebp], esi

; 4955 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4956 :         if (_BUF_SIZE <= _Old_capacity) {

  000c0	83 7d 08 10	 cmp	 DWORD PTR $T1[ebp], 16	; 00000010H
  000c4	89 45 fc	 mov	 DWORD PTR tv606[ebp], eax
  000c7	51		 push	 ecx
  000c8	72 55		 jb	 SHORT $LN4@Reallocate

; 4957 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ca	8b 37		 mov	 esi, DWORD PTR [edi]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cc	56		 push	 esi
  000cd	53		 push	 ebx
  000ce	e8 00 00 00 00	 call	 _memcpy
  000d3	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000d6	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000d9	ff 75 f8	 push	 DWORD PTR __First1$1$[ebp]
  000dc	e8 00 00 00 00	 call	 _memcpy

; 3437 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000e1	8b 45 fc	 mov	 eax, DWORD PTR tv606[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000e4	83 c4 18	 add	 esp, 24			; 00000018H

; 4958 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4959 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e7	8b 4d 08	 mov	 ecx, DWORD PTR $T1[ebp]
  000ea	41		 inc	 ecx

; 3437 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000eb	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000ee	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f4	72 12		 jb	 SHORT $LN69@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f6	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000f9	83 c1 23	 add	 ecx, 35			; 00000023H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fc	2b f2		 sub	 esi, edx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fe	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00101	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00104	77 47		 ja	 SHORT $LN66@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00106	8b f2		 mov	 esi, edx
$LN69@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00108	51		 push	 ecx
  00109	56		 push	 esi
  0010a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010f	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 4967 :         return *this;

  00112	89 1f		 mov	 DWORD PTR [edi], ebx
  00114	8b c7		 mov	 eax, edi
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx

; 4968 :     }

  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 10 00	 ret	 16			; 00000010H
$LN4@Reallocate:

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011f	57		 push	 edi
  00120	53		 push	 ebx
  00121	e8 00 00 00 00	 call	 _memcpy
  00126	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00129	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  0012c	56		 push	 esi
  0012d	e8 00 00 00 00	 call	 _memcpy

; 3437 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00132	8b 45 fc	 mov	 eax, DWORD PTR tv606[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00135	83 c4 18	 add	 esp, 24			; 00000018H

; 3437 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00138	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4967 :         return *this;

  0013b	8b c7		 mov	 eax, edi
  0013d	89 1f		 mov	 DWORD PTR [edi], ebx
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx

; 4968 :     }

  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 10 00	 ret	 16			; 00000010H
$LN122@Reallocate:

; 4937 :             _Xlen_string(); // result too long

  00148	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN66@Reallocate:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0014d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN120@Reallocate:
  00152	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3419 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3420 :         // append [_Ptr, _Ptr + _Count)
; 3421 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3422 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0000d	8b c2		 mov	 eax, edx
  0000f	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00012	2b c1		 sub	 eax, ecx
  00014	3b d8		 cmp	 ebx, eax
  00016	77 2d		 ja	 SHORT $LN2@append

; 3423 :             _ASAN_STRING_MODIFY(static_cast<difference_type>(_Count));
; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00018	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  0001b	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2283 :         value_type* _Result = _Bx._Buf;

  0001e	8b c7		 mov	 eax, edi

; 2301 :         return _BUF_SIZE <= _Myres;

  00020	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2284 :         if (_Large_string_engaged()) {

  00023	72 02		 jb	 SHORT $LN5@append

; 2285 :             _Result = _Unfancy(_Bx._Ptr);

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:
  00027	56		 push	 esi

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	53		 push	 ebx
  00029	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3425 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3426 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0002c	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 _memmove
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3427 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00038	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 3428 :             return *this;

  0003c	8b c7		 mov	 eax, edi
  0003e	5e		 pop	 esi
  0003f	5f		 pop	 edi

; 3432 :             _Count,
; 3433 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3434 :                 const size_type _Count) {
; 3435 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3436 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3437 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3438 :             },
; 3439 :             _Ptr, _Count);
; 3440 :     }

  00040	5b		 pop	 ebx
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
$LN2@append:

; 3429 :         }
; 3430 : 
; 3431 :         return _Reallocate_grow_by(

  00045	53		 push	 ebx
  00046	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00049	8b cf		 mov	 ecx, edi
  0004b	ff 75 08	 push	 DWORD PTR $T1[ebp]
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
  00054	5f		 pop	 edi

; 3432 :             _Count,
; 3433 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3434 :                 const size_type _Count) {
; 3435 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3436 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3437 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3438 :             },
; 3439 :             _Ptr, _Count);
; 3440 :     }

  00055	5b		 pop	 ebx
  00056	5d		 pop	 ebp
  00057	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3442 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b d9		 mov	 ebx, ecx

; 415  :             return __builtin_strlen(_First);

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000a	8b f1		 mov	 esi, ecx

; 3442 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  0000c	57		 push	 edi

; 415  :             return __builtin_strlen(_First);

  0000d	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
$LL43@append:
  00010	8a 06		 mov	 al, BYTE PTR [esi]
  00012	46		 inc	 esi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL43@append

; 3422 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00017	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]

; 415  :             return __builtin_strlen(_First);

  0001a	2b f2		 sub	 esi, edx

; 3421 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0001c	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]

; 3422 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0001f	8b c7		 mov	 eax, edi
  00021	2b c2		 sub	 eax, edx
  00023	3b f0		 cmp	 esi, eax
  00025	77 2a		 ja	 SHORT $LN6@append

; 3423 :             _ASAN_STRING_MODIFY(static_cast<difference_type>(_Count));
; 3424 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00027	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  0002a	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 2283 :         value_type* _Result = _Bx._Buf;

  0002d	8b c3		 mov	 eax, ebx

; 2301 :         return _BUF_SIZE <= _Myres;

  0002f	83 ff 10	 cmp	 edi, 16			; 00000010H

; 2284 :         if (_Large_string_engaged()) {

  00032	72 02		 jb	 SHORT $LN9@append

; 2285 :             _Result = _Unfancy(_Bx._Ptr);

  00034	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN9@append:

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00036	56		 push	 esi

; 3426 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8d 3c 10	 lea	 edi, DWORD PTR [eax+edx]

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0003a	51		 push	 ecx
  0003b	57		 push	 edi
  0003c	e8 00 00 00 00	 call	 _memmove
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3427 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00044	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0

; 3443 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00048	8b c3		 mov	 eax, ebx
  0004a	5f		 pop	 edi

; 3444 :     }

  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN6@append:

; 3431 :         return _Reallocate_grow_by(

  00051	56		 push	 esi
  00052	51		 push	 ecx
  00053	ff 75 08	 push	 DWORD PTR $T1[ebp]
  00056	8b cb		 mov	 ecx, ebx
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??append@01@QAEAAV01@QBDI@Z@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append'::`2'::<lambda_1>,char const *,unsigned int>
  0005e	5f		 pop	 edi

; 3444 :     }

  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 3382 :     _CONSTEXPR20 basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3384 :     }

  00003	5d		 pop	 ebp

; 3383 :         return append(_Ptr);

  00004	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1295 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 08 00	 ret	 8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$ = ecx

; 1298 :     _CONSTEXPR20 void _Release() noexcept {}

  00000	c2 00 00	 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 2728 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 2729 :         auto& _My_data = _Mypair._Myval2;
; 2730 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2731 :         _STL_INTERNAL_CHECK(_STD count(_My_data._Bx._Buf, _My_data._Bx._Buf + _BUF_SIZE, _Elem()) == _BUF_SIZE);
; 2732 : 
; 2733 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2734 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2735 :         } else {
; 2736 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2737 :         }
; 2738 : 
; 2739 :         if (_Count > max_size()) {

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00010	0f 87 9b 00 00
	00		 ja	 $LN92@Construct

; 2741 :         }
; 2742 : 
; 2743 :         auto& _Al       = _Getal();
; 2744 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2745 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2746 : 
; 2747 :         if (_Count < _BUF_SIZE) {

  00016	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
  0001d	83 ff 10	 cmp	 edi, 16			; 00000010H
  00020	73 16		 jae	 SHORT $LN3@Construct

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00022	57		 push	 edi
  00023	ff 75 08	 push	 DWORD PTR __Arg$[ebp]

; 2748 :             _My_data._Mysize = _Count;

  00026	89 7b 10	 mov	 DWORD PTR [ebx+16], edi

; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00029	53		 push	 ebx
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	5f		 pop	 edi

; 2786 :         } else { // _Strat == _Construct_strategy::_From_string
; 2787 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2788 :         }
; 2789 : 
; 2790 :         _ASAN_STRING_CREATE(*this);
; 2791 :         _Proxy._Release();
; 2792 :     }

  00033	5b		 pop	 ebx
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN3@Construct:
  00038	56		 push	 esi

; 4880 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00039	8b f7		 mov	 esi, edi
  0003b	83 ce 0f	 or	 esi, 15			; 0000000fH
  0003e	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4881 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00044	76 15		 jbe	 SHORT $LN24@Construct

; 4882 :             return _Max;

  00046	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0004b	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00056	83 c4 04	 add	 esp, 4
  00059	eb 30		 jmp	 SHORT $LN90@Construct
$LN24@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

  0005b	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00060	3b f0		 cmp	 esi, eax
  00062	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 2769 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00065	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00068	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0006d	72 0b		 jb	 SHORT $LN33@Construct

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00075	83 c4 04	 add	 esp, 4
  00078	eb 11		 jmp	 SHORT $LN90@Construct
$LN33@Construct:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  0007a	85 c0		 test	 eax, eax
  0007c	74 0b		 je	 SHORT $LN34@Construct

; 77   :         return ::operator new(_Bytes);

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00084	83 c4 04	 add	 esp, 4

; 235  :         return _Traits::_Allocate(_Bytes);

  00087	eb 02		 jmp	 SHORT $LN90@Construct
$LN34@Construct:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  00089	33 c0		 xor	 eax, eax
$LN90@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008b	57		 push	 edi
  0008c	ff 75 08	 push	 DWORD PTR __Arg$[ebp]

; 2770 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0008f	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00092	50		 push	 eax

; 2770 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00093	89 03		 mov	 DWORD PTR [ebx], eax

; 2771 : 
; 2772 : #if _HAS_CXX20
; 2773 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2774 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2775 :         }
; 2776 : #endif // _HAS_CXX20
; 2777 : 
; 2778 :         _My_data._Mysize = _Count;

  00095	89 7b 10	 mov	 DWORD PTR [ebx+16], edi

; 2779 :         _My_data._Myres  = _New_capacity;

  00098	89 73 14	 mov	 DWORD PTR [ebx+20], esi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0009b	e8 00 00 00 00	 call	 _memcpy

; 2780 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2781 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2782 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2783 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2784 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2785 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000a0	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2780 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2781 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2782 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2783 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2784 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2785 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000a6	5e		 pop	 esi
  000a7	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000ab	5f		 pop	 edi

; 2786 :         } else { // _Strat == _Construct_strategy::_From_string
; 2787 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2788 :         }
; 2789 : 
; 2790 :         _ASAN_STRING_CREATE(*this);
; 2791 :         _Proxy._Release();
; 2792 :     }

  000ac	5b		 pop	 ebx
  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
$LN92@Construct:

; 2740 :             _Xlen_string(); // result too long

  000b1	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN89@Construct:
  000b6	cc		 int	 3
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2673 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 415  :             return __builtin_strlen(_First);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 2673 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 415  :             return __builtin_strlen(_First);

  0000c	8b c2		 mov	 eax, edx

; 2673 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  0000e	57		 push	 edi

; 2339 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000f	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 2348 :     size_type _Mysize = 0; // current length of string

  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 415  :             return __builtin_strlen(_First);

  00019	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2349 :     size_type _Myres  = 0; // current storage reserved for string

  0001c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL13@basic_stri:

; 415  :             return __builtin_strlen(_First);

  00023	8a 08		 mov	 cl, BYTE PTR [eax]
  00025	40		 inc	 eax
  00026	84 c9		 test	 cl, cl
  00028	75 f9		 jne	 SHORT $LL13@basic_stri
  0002a	2b c7		 sub	 eax, edi

; 2674 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002c	8b ce		 mov	 ecx, esi
  0002e	50		 push	 eax
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2675 :     }

  00035	5f		 pop	 edi
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
END
